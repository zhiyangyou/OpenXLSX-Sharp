// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace OpenXLSX
{
    namespace OpenXLSX
    {
        /// <summary>An implementation class encapsulating the properties and behaviours of a spreadsheet cell.</summary>
        public unsafe partial class XLCell : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 64)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_XLCell;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_cellNode;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal global::OpenXLSX.OpenXLSX.XLCellValueProxy.__Internal m_valueProxy;
                internal global::OpenXLSX.OpenXLSX.XLFormulaProxy.__Internal m_formulaProxy;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCell@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCell@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@AEBVXLSharedStrings@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr cellNode, __IntPtr sharedStrings);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCell@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?copyFrom@XLCell@OpenXLSX@@QEAAXAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CopyFrom(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLCell@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLCell@OpenXLSX@@QEAAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance, uint keep);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?offset@XLCell@OpenXLSX@@QEBA?AV12@GG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Offset(__IntPtr __instance, __IntPtr @return, ushort rowOffset, ushort colOffset);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setCellFormat@XLCell@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetCellFormat(__IntPtr __instance, ulong cellFormatIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLCell@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLCell@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?empty@XLCell@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Empty(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?value@XLCell@OpenXLSX@@QEAAAEAVXLCellValueProxy@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Value(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellReference@XLCell@OpenXLSX@@QEBA?AVXLCellReference@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CellReference(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasFormula@XLCell@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasFormula(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?formula@XLCell@OpenXLSX@@QEAAAEAVXLFormulaProxy@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Formula(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getString@XLCell@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetString(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellFormat@XLCell@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong CellFormat(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCell> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCell>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCell managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCell managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCell __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCell(native.ToPointer(), skipVTables);
            }

            internal static XLCell __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCell)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCell __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLCell)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLCell __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCell(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCell.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCell(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCell(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            /// <summary>Default constructor. Constructs a null object.</summary>
            public XLCell()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCell.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLCell");
            }

            public XLCell(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node cellNode, global::OpenXLSX.OpenXLSX.XLSharedStrings sharedStrings)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCell.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(cellNode, null))
                    throw new global::System.ArgumentNullException("cellNode", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = cellNode.__Instance;
                if (ReferenceEquals(sharedStrings, null))
                    throw new global::System.ArgumentNullException("sharedStrings", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = sharedStrings.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLCell");
            }

            /// <summary>Copy constructor</summary>
            /// <param name="other">The XLCell object to be copied.</param>
            /// <remarks>
            /// <para>The copy constructor has been deleted, as it makes no sense to copy a cell. If the objective is to</para>
            /// <para>copy the getValue, create the the target object and then use the copy assignment operator.</para>
            /// </remarks>
            public XLCell(global::OpenXLSX.OpenXLSX.XLCell other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCell.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLCell");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Copy contents of a cell, value&amp;formula</summary>
            /// <param name="other">The XLCell object from which to copy</param>
            public void CopyFrom(global::OpenXLSX.OpenXLSX.XLCell other)
            {
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.CopyFrom(__Instance, __arg0);
            }

            /// <summary>opposite of empty()</summary>
            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLCell __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            /// <summary>clear all cell content and attributes except for the cell reference (attribute r)</summary>
            /// <param name="keep">
            /// <para>do not clear cell properties whose flags are set in keep (XLKeepCellStyle, XLKeepCellType,</para>
            /// <para>XLKeepCellValue, XLKeepCellFormula), flags can be combined with bitwise OR</para>
            /// </param>
            public void Clear(uint keep)
            {
                __Internal.Clear(__Instance, keep);
            }

            /// <summary>get the XLCell object from the current cell offset</summary>
            /// <returns>A reference to the XLCell object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCell Offset(ushort rowOffset, ushort colOffset)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCell.__Internal();
                __Internal.Offset(__Instance, new IntPtr(&___ret), rowOffset, colOffset);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCell.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::OpenXLSX.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Set the cell style (attribute s) with a reference to the array index of xl/styles.xml:&gt;:&gt;</summary>
            /// <param name="cellFormatIndex">The style to set, corresponding to the nidex of XLStyles::cellStyles()</param>
            /// <remarks>True on success, false on failure</remarks>
            public bool SetCellFormat(ulong cellFormatIndex)
            {
                var ___ret = __Internal.SetCellFormat(__Instance, cellFormatIndex);
                return ___ret;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLCell lhs, global::OpenXLSX.OpenXLSX.XLCell rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLCell;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLCell.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLCell lhs, global::OpenXLSX.OpenXLSX.XLCell rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>test if cell object has no (valid) content</summary>
            public bool Empty
            {
                get
                {
                    var ___ret = __Internal.Empty(__Instance);
                    return ___ret;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLCellValueProxy Value
            {
                get
                {
                    var ___ret = __Internal.Value(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellValueProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>get the XLCellReference object for the cell.</summary>
            /// <returns>A reference to the cells' XLCellReference object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellReference CellReference
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLCellReference.__Internal();
                    __Internal.CellReference(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLCellReference.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLCellReference.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public bool HasFormula
            {
                get
                {
                    var ___ret = __Internal.HasFormula(__Instance);
                    return ___ret;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLFormulaProxy Formula
            {
                get
                {
                    var ___ret = __Internal.Formula(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLFormulaProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public string String
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetString(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>
            /// <para>Get the array index of xl/styles.xml:&gt;:&gt; for the style used in this cell.</para>
            /// <para>This value is stored in the s attribute of a cell like so: s=&quot;2&quot;</para>
            /// </summary>
            /// <param name="cellFormatIndex">The style to set, corresponding to the nidex of XLStyles::cellStyles()</param>
            /// <remarks>
            /// <para>The index of the applicable format style</para>
            /// <para>Set the cell style (attribute s) with a reference to the array index of xl/styles.xml:&gt;:&gt;</para>
            /// <para>True on success, false on failure</para>
            /// </remarks>
            public ulong CellFormat
            {
                get
                {
                    var ___ret = __Internal.CellFormat(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCellFormat(__Instance, value);
                }
            }

            #region Virtual table interop

            // virtual ~XLCell()
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLCell.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLCellAssignable : global::OpenXLSX.OpenXLSX.XLCell, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 64)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_XLCell;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_cellNode;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal global::OpenXLSX.OpenXLSX.XLCellValueProxy.__Internal m_valueProxy;
                internal global::OpenXLSX.OpenXLSX.XLFormulaProxy.__Internal m_formulaProxy;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellAssignable@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellAssignable@OpenXLSX@@QEAA@$$QEAVXLCell@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellAssignable@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);
            }

            internal static new XLCellAssignable __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellAssignable(native.ToPointer(), skipVTables);
            }

            internal static new XLCellAssignable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellAssignable)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLCellAssignable __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLCellAssignable)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLCellAssignable __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellAssignable(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellAssignable.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellAssignable(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellAssignable(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            /// <summary>Default constructor. Constructs a null object.</summary>
            public XLCellAssignable()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellAssignable.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLCellAssignable");
            }

            /// <summary>Move constructor. Constructs an assignable XLCell from a temporary (r)value</summary>
            /// <param name="other">the cell to construct from</param>
            public XLCellAssignable(global::OpenXLSX.OpenXLSX.XLCell other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellAssignable.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.ctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLCellAssignable");
            }

            public XLCellAssignable(global::OpenXLSX.OpenXLSX.XLCellAssignable other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellAssignable.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLCellAssignable");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            #region Virtual table interop

            // XLCellAssignable
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLCellAssignable.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 4, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[4];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLCell
        {
            public partial struct __Internal
            {
            }

            public const uint XLKeepCellStyle = 1;
            public const uint XLKeepCellType = 2;
            public const uint XLKeepCellValue = 4;
            public const uint XLKeepCellFormula = 8;        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLCellReference : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal uint m_row;
                internal ushort m_column;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_cellAddress;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellReference@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr cellAddress);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellReference@OpenXLSX@@QEAA@IG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, uint row, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellReference@OpenXLSX@@QEAA@IAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, uint row, __IntPtr column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellReference@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellReference@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??EXLCellReference@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorPlusPlus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??FXLCellReference@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorMinusMinus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRowAndColumn@XLCellReference@OpenXLSX@@QEAAXIG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRowAndColumn(__IntPtr __instance, uint row, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowAsString@XLCellReference@OpenXLSX@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RowAsString(__IntPtr @return, uint row);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowAsNumber@XLCellReference@OpenXLSX@@SAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint RowAsNumber(__IntPtr row);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?columnAsString@XLCellReference@OpenXLSX@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ColumnAsString(__IntPtr @return, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?columnAsNumber@XLCellReference@OpenXLSX@@SAGAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort ColumnAsNumber(__IntPtr column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??MOpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLess(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??OOpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreater(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??NOpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??POpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?row@XLCellReference@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint Row(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRow@XLCellReference@OpenXLSX@@QEAAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRow(__IntPtr __instance, uint row);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?column@XLCellReference@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort Column(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColumn@XLCellReference@OpenXLSX@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColumn(__IntPtr __instance, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?address@XLCellReference@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Address(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setAddress@XLCellReference@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAddress(__IntPtr __instance, __IntPtr address);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellReference> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellReference>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellReference managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellReference managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellReference __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellReference(native.ToPointer(), skipVTables);
            }

            internal static XLCellReference __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellReference)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellReference __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellReference(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellReference.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellReference(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellReference(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor taking a cell address as argument.</summary>
            /// <param name="cellAddress">The address of the cell, e.g. 'A1'.</param>
            /// <remarks>
            /// <para>The constructor creates a new XLCellReference from a string, e.g. 'A1'. If there's no input,</para>
            /// <para>the default reference will be cell A1.</para>
            /// </remarks>
            public XLCellReference(string cellAddress)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, cellAddress);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Constructor taking the cell coordinates as arguments.</summary>
            /// <param name="row">The row number of the cell.</param>
            /// <param name="column">The column number of the cell.</param>
            public XLCellReference(uint row, ushort column)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, row, column);
            }

            /// <summary>Constructor taking the row number and the column letter as arguments.</summary>
            /// <param name="row">The row number of the cell.</param>
            /// <param name="column">The column letter of the cell.</param>
            public XLCellReference(uint row, string column)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, column);
                var __arg1 = __basicString1.__Instance;
                __Internal.ctor(__Instance, row, __arg1);
                __basicString1.Dispose();
            }

            /// <summary>Copy constructor</summary>
            /// <param name="other">The object to be copied.</param>
            public XLCellReference(global::OpenXLSX.OpenXLSX.XLCellReference other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::OpenXLSX.OpenXLSX.XLCellReference operator ++(global::OpenXLSX.OpenXLSX.XLCellReference __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorPlusPlus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellReference.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::OpenXLSX.OpenXLSX.XLCellReference operator --(global::OpenXLSX.OpenXLSX.XLCellReference __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorMinusMinus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellReference.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Set both row and column number of the XLCellReference.</summary>
            /// <param name="row">The row number.</param>
            /// <param name="column">The column number.</param>
            public void SetRowAndColumn(uint row, ushort column)
            {
                __Internal.SetRowAndColumn(__Instance, row, column);
            }

            public static implicit operator global::OpenXLSX.OpenXLSX.XLCellReference(string cellAddress)
            {
                return new global::OpenXLSX.OpenXLSX.XLCellReference(cellAddress);
            }

            public static string RowAsString(uint row)
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.RowAsString(new IntPtr(&___ret), row);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public static uint RowAsNumber(string row)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, row);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.RowAsNumber(__arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Static helper function to convert column number to column letter (e.g. column 1 becomes 'A')</summary>
            /// <param name="column">The column number.</param>
            /// <returns>The column letter</returns>
            public static string ColumnAsString(ushort column)
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.ColumnAsString(new IntPtr(&___ret), column);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Static helper function to convert column letter to column number (e.g. column 'A' becomes 1)</summary>
            /// <param name="column">The column letter, e.g. 'A'</param>
            /// <returns>The column number.</returns>
            public static ushort ColumnAsNumber(string column)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, column);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.ColumnAsNumber(__arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Helper function to check equality between two XLCellReferences.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if equal; otherwise false.</returns>
            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLCellReference;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal*) __Instance).GetHashCode();
            }

            /// <summary>Helper function to check for in-equality between two XLCellReferences</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>false if equal; otherwise true.</returns>
            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Helper function to check if one XLCellReference is smaller than another.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if lhs&lt;rhs; otherwise false.</returns>
            public static bool operator <(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLess(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Helper function to check if one XLCellReference is larger than another.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if lhs &gt; rhs; otherwise false.</returns>
            public static bool operator >(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreater(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Helper function to check if one XLCellReference is smaller than or equal to another.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if lhs&lt;= rhs; otherwise false</returns>
            public static bool operator <=(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLessEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Helper function to check if one XLCellReference is larger than or equal to another.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if lhs &gt;= rhs; otherwise false.</returns>
            public static bool operator >=(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Get the row number of the XLCellReference.</summary>
            /// <param name="row">The row number.</param>
            /// <returns>
            /// <para>The row.</para>
            /// <para>Set the row number for the XLCellReference.</para>
            /// </returns>
            public uint Row
            {
                get
                {
                    var ___ret = __Internal.Row(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRow(__Instance, value);
                }
            }

            /// <summary>Get the column number of the XLCellReference.</summary>
            /// <param name="column">The column number.</param>
            /// <returns>
            /// <para>The column number.</para>
            /// <para>Set the column number of the XLCellReference.</para>
            /// </returns>
            public ushort Column
            {
                get
                {
                    var ___ret = __Internal.Column(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetColumn(__Instance, value);
                }
            }

            /// <summary>Get the address of the XLCellReference</summary>
            /// <param name="address">The address, e.g. 'A1'</param>
            /// <returns>
            /// <para>The address, e.g. 'A1'</para>
            /// <para>Set the address of the XLCellReference</para>
            /// </returns>
            /// <remarks>The address input string must be a valid Excel cell reference. Otherwise the behaviour is undefined.</remarks>
            public string Address
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Address(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetAddress(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>Enum defining the valid value types for a an Excel spreadsheet cell.</summary>
        public enum XLValueType
        {
            Empty = 0,
            Boolean = 1,
            Integer = 2,
            Float = 3,
            Error = 4,
            String = 5
        }

        public unsafe partial class VisitXLCellValueTypeToString : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C packageName;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0VisitXLCellValueTypeToString@OpenXLSX@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0VisitXLCellValueTypeToString@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1VisitXLCellValueTypeToString@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.VisitXLCellValueTypeToString> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.VisitXLCellValueTypeToString>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.VisitXLCellValueTypeToString managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.VisitXLCellValueTypeToString managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static VisitXLCellValueTypeToString __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new VisitXLCellValueTypeToString(native.ToPointer(), skipVTables);
            }

            internal static VisitXLCellValueTypeToString __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (VisitXLCellValueTypeToString)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static VisitXLCellValueTypeToString __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VisitXLCellValueTypeToString(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.VisitXLCellValueTypeToString.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private VisitXLCellValueTypeToString(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected VisitXLCellValueTypeToString(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public VisitXLCellValueTypeToString(global::OpenXLSX.OpenXLSX.VisitXLCellValueTypeToString _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.VisitXLCellValueTypeToString.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public VisitXLCellValueTypeToString()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.VisitXLCellValueTypeToString.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string PackageName
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->packageName));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->packageName), value);
                }
            }
        }

        /// <summary>Class encapsulating a cell value.</summary>
        public unsafe partial class XLCellValue : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public partial struct __Internal
            {
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value_str;
                internal long m_value_int64;
                internal double m_value_double;
                internal byte m_value_bool;
                internal global::OpenXLSX.OpenXLSX.XLValueType m_type;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellValue@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellValue@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellValue@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setError@XLCellValue@OpenXLSX@@QEAAAEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetError(__IntPtr __instance, __IntPtr error);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??MOpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLess(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??OOpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreater(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??NOpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??POpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getString@XLCellValue@OpenXLSX@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetString(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLCellValue@OpenXLSX@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLCellValue@OpenXLSX@@QEBA?AW4XLValueType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLValueType Type(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?typeAsString@XLCellValue@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TypeAsString(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellValue> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellValue>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellValue managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellValue managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellValue __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellValue(native.ToPointer(), skipVTables);
            }

            internal static XLCellValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellValue)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellValue __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellValue(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellValue.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellValue(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellValue(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor</summary>
            public XLCellValue()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellValue.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">The object to be copied.</param>
            public XLCellValue(global::OpenXLSX.OpenXLSX.XLCellValue other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellValue.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the value type to XLValueType::Error.</summary>
            /// <returns>Returns a reference to the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellValue SetError(string error)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, error);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SetError(__Instance, __arg0);
                __basicString0.Dispose();
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellValue.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLCellValue;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLCellValue.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator <(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLess(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator >(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreater(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator <=(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLessEqual(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator >=(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>get the cell value as a std::string, regardless of value type</summary>
            /// <returns>A std::string representation of value</returns>
            /// <remarks>XLValueTypeError if the XLCellValue object is not convertible to string.</remarks>
            public string String
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetString(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Clears the contents of the XLCellValue object.</summary>
            /// <returns>Returns a reference to the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellValue Clear
            {
                get
                {
                    var ___ret = __Internal.Clear(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellValue.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the value type of the current object.</summary>
            /// <returns>An XLValueType for the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLValueType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the value type of the current object, as a string representation</summary>
            /// <returns>A std::string representation of the value type.</returns>
            public string TypeAsString
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.TypeAsString(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>The XLCellValueProxy class is used for proxy (or placeholder) objects for XLCellValue objects.</summary>
        /// <remarks>
        /// <para>The XLCellValueProxy class is used for proxy (or placeholder) objects for XLCellValue objects.</para>
        /// <para>The purpose is to enable implicit conversion during assignment operations. XLCellValueProxy objects</para>
        /// <para>can not be constructed manually by the user, only through XLCell objects.</para>
        /// </remarks>
        public unsafe partial class XLCellValueProxy : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr m_cell;
                internal __IntPtr m_cellNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellValueProxy@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setError@XLCellValueProxy@OpenXLSX@@QEAAAEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetError(__IntPtr __instance, __IntPtr error);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLCellValueProxy@OpenXLSX@@QEBA?AVXLCellValue@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLCellValueProxy@OpenXLSX@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLCellValueProxy@OpenXLSX@@QEBA?AW4XLValueType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLValueType Type(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?typeAsString@XLCellValueProxy@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TypeAsString(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getString@XLCellValueProxy@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetString(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellValueProxy> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellValueProxy>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellValueProxy managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellValueProxy managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellValueProxy __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellValueProxy(native.ToPointer(), skipVTables);
            }

            internal static XLCellValueProxy __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellValueProxy)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellValueProxy __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellValueProxy(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLCellValueProxy(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellValueProxy(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set the cell value to a error state.</summary>
            /// <returns>A reference to the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellValueProxy SetError(string error)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, error);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SetError(__Instance, __arg0);
                __basicString0.Dispose();
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellValueProxy.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Implicitly convert the XLCellValueProxy object to a XLCellValue object.</summary>
            /// <returns>An XLCellValue object, corresponding to the cell value.</returns>
            public static implicit operator global::OpenXLSX.OpenXLSX.XLCellValue(global::OpenXLSX.OpenXLSX.XLCellValueProxy __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellValue.__Internal();
                __Internal.OperatorConversion(__arg0, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellValue.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellValue.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Clear the contents of the cell.</summary>
            /// <returns>A reference to the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellValueProxy Clear
            {
                get
                {
                    var ___ret = __Internal.Clear(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellValueProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the value type for the cell.</summary>
            /// <returns>An XLCellValue corresponding to the cell value.</returns>
            public global::OpenXLSX.OpenXLSX.XLValueType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the value type of the current object, as a string representation</summary>
            /// <returns>A std::string representation of the value type.</returns>
            public string TypeAsString
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.TypeAsString(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>get the cell value as a std::string, regardless of value type</summary>
            /// <returns>A std::string representation of value</returns>
            /// <remarks>XLValueTypeError if the XLCellValue object is not convertible to string.</remarks>
            public string String
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetString(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLDateTime : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal double m_serial;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTime@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTime@OpenXLSX@@QEAA@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, double serial);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTime@OpenXLSX@@QEAA@_J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor_1(__IntPtr __instance, long unixtime);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTime@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLDateTime@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?serial@XLDateTime@OpenXLSX@@QEBANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Serial(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDateTime> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDateTime>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLDateTime managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLDateTime managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLDateTime __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLDateTime(native.ToPointer(), skipVTables);
            }

            internal static XLDateTime __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLDateTime)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLDateTime __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLDateTime(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLDateTime.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLDateTime(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLDateTime(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor.</summary>
            public XLDateTime()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTime.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor taking an Excel time point serial number as an argument.</summary>
            /// <param name="serial">Excel time point serial number.</param>
            public XLDateTime(double serial)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTime.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, serial);
            }

            /// <summary>Constructor taking a unixtime format (seconds since 1/1/1970) as an argument.</summary>
            /// <param name="unixtime">A time_t number.</param>
            public XLDateTime(long unixtime)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTime.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor_1(__Instance, unixtime);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLDateTime(global::OpenXLSX.OpenXLSX.XLDateTime other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTime.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLDateTime(double serial)
            {
                return new global::OpenXLSX.OpenXLSX.XLDateTime(serial);
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLDateTime(long unixtime)
            {
                return new global::OpenXLSX.OpenXLSX.XLDateTime(unixtime);
            }

            /// <summary>Get the date/time in the form of an Excel date/time serial number.</summary>
            /// <returns>A double with the serial number.</returns>
            public double Serial
            {
                get
                {
                    var ___ret = __Internal.Serial(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLException : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLException@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLException> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLException>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLException managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLException managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLException(native.ToPointer(), skipVTables);
            }

            internal static XLException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLException(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLException(string err)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLException.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLException");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLException(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLException(err);
            }

            #region Virtual table interop

            // XLException
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLOverflowError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLOverflowError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLOverflowError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLOverflowError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLOverflowError(native.ToPointer(), skipVTables);
            }

            internal static new XLOverflowError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLOverflowError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLOverflowError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLOverflowError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLOverflowError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLOverflowError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLOverflowError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLOverflowError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLOverflowError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLOverflowError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLOverflowError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLOverflowError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLOverflowError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLOverflowError(err);
            }

            #region Virtual table interop

            // XLOverflowError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLOverflowError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLValueTypeError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLValueTypeError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLValueTypeError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLValueTypeError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLValueTypeError(native.ToPointer(), skipVTables);
            }

            internal static new XLValueTypeError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLValueTypeError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLValueTypeError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLValueTypeError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLValueTypeError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLValueTypeError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLValueTypeError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLValueTypeError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLValueTypeError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLValueTypeError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLValueTypeError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLValueTypeError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLValueTypeError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLValueTypeError(err);
            }

            #region Virtual table interop

            // XLValueTypeError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLValueTypeError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLCellAddressError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellAddressError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellAddressError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLCellAddressError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellAddressError(native.ToPointer(), skipVTables);
            }

            internal static new XLCellAddressError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellAddressError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLCellAddressError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLCellAddressError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLCellAddressError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellAddressError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellAddressError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellAddressError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellAddressError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLCellAddressError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellAddressError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLCellAddressError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLCellAddressError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLCellAddressError(err);
            }

            #region Virtual table interop

            // XLCellAddressError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLCellAddressError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLInputError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLInputError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLInputError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLInputError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLInputError(native.ToPointer(), skipVTables);
            }

            internal static new XLInputError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLInputError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLInputError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLInputError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLInputError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLInputError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLInputError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLInputError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLInputError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLInputError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLInputError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLInputError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLInputError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLInputError(err);
            }

            #region Virtual table interop

            // XLInputError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLInputError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLInternalError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLInternalError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLInternalError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLInternalError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLInternalError(native.ToPointer(), skipVTables);
            }

            internal static new XLInternalError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLInternalError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLInternalError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLInternalError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLInternalError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLInternalError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLInternalError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLInternalError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLInternalError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLInternalError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLInternalError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLInternalError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLInternalError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLInternalError(err);
            }

            #region Virtual table interop

            // XLInternalError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLInternalError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLPropertyError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLPropertyError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLPropertyError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLPropertyError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLPropertyError(native.ToPointer(), skipVTables);
            }

            internal static new XLPropertyError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLPropertyError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLPropertyError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLPropertyError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLPropertyError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLPropertyError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLPropertyError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLPropertyError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLPropertyError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLPropertyError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLPropertyError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLPropertyError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLPropertyError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLPropertyError(err);
            }

            #region Virtual table interop

            // XLPropertyError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLPropertyError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLSheetError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSheetError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSheetError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLSheetError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLSheetError(native.ToPointer(), skipVTables);
            }

            internal static new XLSheetError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLSheetError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLSheetError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLSheetError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLSheetError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLSheetError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLSheetError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLSheetError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLSheetError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLSheetError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLSheetError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLSheetError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLSheetError(err);
            }

            #region Virtual table interop

            // XLSheetError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLSheetError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLDateTimeError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTimeError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTimeError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLDateTimeError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLDateTimeError(native.ToPointer(), skipVTables);
            }

            internal static new XLDateTimeError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLDateTimeError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLDateTimeError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLDateTimeError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLDateTimeError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLDateTimeError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLDateTimeError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLDateTimeError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLDateTimeError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLDateTimeError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTimeError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLDateTimeError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLDateTimeError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLDateTimeError(err);
            }

            #region Virtual table interop

            // XLDateTimeError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLDateTimeError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLFormulaError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFormulaError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFormulaError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLFormulaError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFormulaError(native.ToPointer(), skipVTables);
            }

            internal static new XLFormulaError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFormulaError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLFormulaError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLFormulaError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLFormulaError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFormulaError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLFormulaError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLFormulaError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFormulaError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLFormulaError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFormulaError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLFormulaError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLFormulaError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLFormulaError(err);
            }

            #region Virtual table interop

            // XLFormulaError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLFormulaError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    public unsafe partial class XLXmlParser
    {
        public partial struct __Internal
        {
        }

        public const int XLMaxNamespacedNameLen = 100;    }

    namespace OpenXLSX
    {
        public unsafe partial class OpenXLSX_xml_node : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr _root;
                internal int name_begin;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0OpenXLSX_xml_node@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0OpenXLSX_xml_node@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name_without_namespace@OpenXLSX_xml_node@OpenXLSX@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr NameWithoutNamespace(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?namespaced_name_char@OpenXLSX_xml_node@OpenXLSX@@QEBAPEBDPEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr NamespacedNameChar(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_, bool force_ns);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?child@OpenXLSX_xml_node@OpenXLSX@@QEBA?AV12@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Child(__IntPtr __instance, __IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?next_sibling@OpenXLSX_xml_node@OpenXLSX@@QEBA?AV12@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NextSibling(__IntPtr __instance, __IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?next_sibling@OpenXLSX_xml_node@OpenXLSX@@QEBA?AV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NextSibling(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?previous_sibling@OpenXLSX_xml_node@OpenXLSX@@QEBA?AV12@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PreviousSibling(__IntPtr __instance, __IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?previous_sibling@OpenXLSX_xml_node@OpenXLSX@@QEBA?AV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PreviousSibling(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?child_value@OpenXLSX_xml_node@OpenXLSX@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ChildValue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?child_value@OpenXLSX_xml_node@OpenXLSX@@QEBAPEBDPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ChildValue(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set_name@OpenXLSX_xml_node@OpenXLSX@@QEAA_NPEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string rhs, bool force_ns);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set_name@OpenXLSX_xml_node@OpenXLSX@@QEAA_NPEBD_K_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string rhs, ulong size, bool force_ns);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?append_child@OpenXLSX_xml_node@OpenXLSX@@QEAA?AV12@PEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AppendChild(__IntPtr __instance, __IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_, bool force_ns);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?prepend_child@OpenXLSX_xml_node@OpenXLSX@@QEAA?AV12@PEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PrependChild(__IntPtr __instance, __IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_, bool force_ns);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?remove_child@OpenXLSX_xml_node@OpenXLSX@@QEAA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool RemoveChild(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?find_child_by_attribute@OpenXLSX_xml_node@OpenXLSX@@QEBA?AV12@PEBD00@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FindChildByAttribute(__IntPtr __instance, __IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name_, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string attr_name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string attr_value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?find_child_by_attribute@OpenXLSX_xml_node@OpenXLSX@@QEBA?AV12@PEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FindChildByAttribute(__IntPtr __instance, __IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string attr_name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string attr_value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name@OpenXLSX_xml_node@OpenXLSX@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Name(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?raw_name@OpenXLSX_xml_node@OpenXLSX@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr RawName(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?parent@OpenXLSX_xml_node@OpenXLSX@@QEAA?AV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Parent(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static OpenXLSX_xml_node __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new OpenXLSX_xml_node(native.ToPointer(), skipVTables);
            }

            internal static OpenXLSX_xml_node __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (OpenXLSX_xml_node)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static OpenXLSX_xml_node __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new OpenXLSX_xml_node(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private OpenXLSX_xml_node(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected OpenXLSX_xml_node(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor. Constructs a null object.</summary>
            public OpenXLSX_xml_node()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public OpenXLSX_xml_node(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Strip any namespace from name_</summary>
            /// <param name="name_">A node name which may be prefixed with any namespace like so &quot;namespace:nodename&quot;</param>
            /// <returns>The name_ stripped of a namespace prefix</returns>
            public string NameWithoutNamespace(string name_)
            {
                var ___ret = __Internal.NameWithoutNamespace(__Instance, name_);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>add this node's namespace to name_</summary>
            /// <param name="name_">a node name which shall be prefixed with this node's current namespace</param>
            /// <param name="force_ns">if true, will return name_ unmodified</param>
            /// <returns>this node's current namespace + &quot;:&quot; + name_ as a const pugi::char_t *</returns>
            public string NamespacedNameChar(string name_, bool force_ns)
            {
                var ___ret = __Internal.NamespacedNameChar(__Instance, name_, force_ns);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node Child(string name_)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.Child(__Instance, new IntPtr(&___ret), name_);
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node NextSibling(string name_)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.NextSibling(__Instance, new IntPtr(&___ret), name_);
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node NextSibling()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.NextSibling(__Instance, new IntPtr(&___ret));
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node PreviousSibling(string name_)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.PreviousSibling(__Instance, new IntPtr(&___ret), name_);
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node PreviousSibling()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.PreviousSibling(__Instance, new IntPtr(&___ret));
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            public string ChildValue()
            {
                var ___ret = __Internal.ChildValue(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public string ChildValue(string name_)
            {
                var ___ret = __Internal.ChildValue(__Instance, name_);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            public bool SetName(string rhs, bool force_ns)
            {
                var ___ret = __Internal.SetName(__Instance, rhs, force_ns);
                return ___ret;
            }

            public bool SetName(string rhs, ulong size, bool force_ns)
            {
                var ___ret = __Internal.SetName(__Instance, rhs, size, force_ns);
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node AppendChild(string name_, bool force_ns)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.AppendChild(__Instance, new IntPtr(&___ret), name_, force_ns);
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node PrependChild(string name_, bool force_ns)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.PrependChild(__Instance, new IntPtr(&___ret), name_, force_ns);
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            public bool RemoveChild(string name_)
            {
                var ___ret = __Internal.RemoveChild(__Instance, name_);
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node FindChildByAttribute(string name_, string attr_name, string attr_value)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.FindChildByAttribute(__Instance, new IntPtr(&___ret), name_, attr_name, attr_value);
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node FindChildByAttribute(string attr_name, string attr_value)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                __Internal.FindChildByAttribute(__Instance, new IntPtr(&___ret), attr_name, attr_value);
                return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
            }

            /// <summary>get node name while stripping namespace, if so configured (name_begin &gt; 0)</summary>
            /// <returns>the node name without a namespace</returns>
            public string Name
            {
                get
                {
                    var ___ret = __Internal.Name(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            /// <summary>get actual node name from pugi::xml_node::name, including namespace, if any</summary>
            /// <returns>the raw node name</returns>
            public string RawName
            {
                get
                {
                    var ___ret = __Internal.RawName(__Instance);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            /// <summary>for all functions returning xml_node: invoke base class function, but with a return type of XMLNode (OpenXLSX_xml_node)</summary>
            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node Parent
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                    __Internal.Parent(__Instance, new IntPtr(&___ret));
                    return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
                }
            }
        }

        public unsafe partial class OpenXLSX_xml_document : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 208)]
            public partial struct __Internal
            {
                internal __IntPtr _root;
                internal __IntPtr _buffer;
                internal fixed sbyte _memory[192];

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0OpenXLSX_xml_document@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1OpenXLSX_xml_document@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?document_element@OpenXLSX_xml_document@OpenXLSX@@QEBA?AVOpenXLSX_xml_node@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DocumentElement(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static OpenXLSX_xml_document __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new OpenXLSX_xml_document(native.ToPointer(), skipVTables);
            }

            internal static OpenXLSX_xml_document __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (OpenXLSX_xml_document)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static OpenXLSX_xml_document __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new OpenXLSX_xml_document(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private OpenXLSX_xml_document(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected OpenXLSX_xml_document(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor. Constructs a null object.</summary>
            public OpenXLSX_xml_document()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>for all functions: invoke the base class function, but with a return type of OpenXLSX_xml_node</summary>
            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node DocumentElement
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal();
                    __Internal.DocumentElement(__Instance, new IntPtr(&___ret));
                    return global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__CreateInstance(___ret);
                }
            }
        }

        public unsafe partial class XLXmlParser
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?enable_xml_namespaces@OpenXLSX@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool EnableXmlNamespaces();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?disable_xml_namespaces@OpenXLSX@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DisableXmlNamespaces();
            }

            /// <summary>Set NO_XML_NS to false</summary>
            /// <returns>true if PUGI_AUGMENTED is defined (success), false if PUGI_AUGMENTED is not in use (function would be pointless)</returns>
            /// <remarks>CAUTION: this setting should be established before any other OpenXLSX function is used</remarks>
            public static bool EnableXmlNamespaces()
            {
                var ___ret = __Internal.EnableXmlNamespaces();
                return ___ret;
            }

            /// <summary>Set NO_XML_NS to true</summary>
            /// <returns>true if PUGI_AUGMENTED is defined (success), false if PUGI_AUGMENTED is not in use (function would be pointless)</returns>
            /// <remarks>CAUTION: this setting should be established before any other OpenXLSX function is used</remarks>
            public static bool DisableXmlNamespaces()
            {
                var ___ret = __Internal.DisableXmlNamespaces();
                return ___ret;
            }

            public const bool XLForceNamespace = true;
            /// <summary>
            /// <para>With namespace support: where OpenXLSX already addresses nodes by their namespace, doubling the namespace in a node name</para>
            /// <para>upon node create can be avoided by passing the optional parameter XLForceNamespace - this will use the node name passed to the</para>
            /// <para>insertion function &quot;as-is&quot;.</para>
            /// <para>Affected XMLNode methods: ::set_name, ::append_child, ::prepend_child, ::insert_child_after, ::insert_child_before</para>
            /// </summary>
            public static bool NO_XML_NS
            {
                get
                {
                    var __ptr = (bool*)global::OpenXLSX.__Symbols.OpenXLSX._NO_XML_NS_OpenXLSX__3_NA;
                    return *__ptr;
                }

                set
                {
                    var __ptr = (bool*)global::OpenXLSX.__Symbols.OpenXLSX._NO_XML_NS_OpenXLSX__3_NA;
                    *__ptr = value;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLFormula class encapsulates the concept of an Excel formula. The class is essentially</para>
        /// <para>a wrapper around a std::string.</para>
        /// </summary>
        /// <remarks>
        /// <para>This class currently only supports simple formulas. Array formulas and shared formulas are</para>
        /// <para>not supported. Unfortunately, many spreadsheets have shared formulas, so this class is probably</para>
        /// <para>best used for adding formulas, not reading them from an existing spreadsheet.</para>
        /// <para>Enable handling of shared and array formulas.</para>
        /// </remarks>
        public unsafe partial class XLFormula : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_formulaString;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFormula@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFormula@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLFormula@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?get@XLFormula@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Get(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLFormula@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLFormula@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLFormula@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLFormula@OpenXLSX@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clear(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFormula> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFormula>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLFormula managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLFormula managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLFormula __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFormula(native.ToPointer(), skipVTables);
            }

            internal static XLFormula __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFormula)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLFormula __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFormula(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLFormula.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLFormula(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFormula(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor</summary>
            public XLFormula()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFormula.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLFormula(global::OpenXLSX.OpenXLSX.XLFormula other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFormula.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the formula as a std::string.</summary>
            /// <returns>A std::string with the formula.</returns>
            public string Get()
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Get(__Instance, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Conversion operator, for converting object to a std::string.</summary>
            /// <returns>The formula as a std::string.</returns>
            public static implicit operator string(global::OpenXLSX.OpenXLSX.XLFormula __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.OperatorConversion(__arg0, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLFormula lhs, global::OpenXLSX.OpenXLSX.XLFormula rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLFormula;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLFormula.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLFormula lhs, global::OpenXLSX.OpenXLSX.XLFormula rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Clear the formula.</summary>
            /// <returns>Return a reference to the cleared object.</returns>
            public global::OpenXLSX.OpenXLSX.XLFormula Clear
            {
                get
                {
                    var ___ret = __Internal.Clear(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLFormula.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        /// <summary>
        /// <para>The XLFormulaProxy serves as a placeholder for XLFormula objects. This enable</para>
        /// <para>getting and setting formulas through the same interface.</para>
        /// </summary>
        public unsafe partial class XLFormulaProxy : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr m_cell;
                internal __IntPtr m_cellNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLFormulaProxy@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?get@XLFormulaProxy@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Get(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLFormulaProxy@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLFormulaProxy@OpenXLSX@@QEBA?AVXLFormula@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion_1(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLFormulaProxy@OpenXLSX@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clear(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFormulaProxy> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFormulaProxy>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLFormulaProxy managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLFormulaProxy managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLFormulaProxy __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFormulaProxy(native.ToPointer(), skipVTables);
            }

            internal static XLFormulaProxy __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFormulaProxy)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLFormulaProxy __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFormulaProxy(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLFormulaProxy(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFormulaProxy(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the formula as a std::string.</summary>
            /// <returns>A std::string with the formula.</returns>
            public string Get()
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Get(__Instance, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Conversion operator, for converting the object to a std::string.</summary>
            /// <returns>The formula as a std::string.</returns>
            public static implicit operator string(global::OpenXLSX.OpenXLSX.XLFormulaProxy __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.OperatorConversion(__arg0, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Implicit conversion to XLFormula object.</summary>
            /// <returns>Returns the corresponding XLFormula object.</returns>
            public static implicit operator global::OpenXLSX.OpenXLSX.XLFormula(global::OpenXLSX.OpenXLSX.XLFormulaProxy __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLFormula.__Internal();
                __Internal.OperatorConversion_1(__arg0, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLFormula.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLFormula.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Clear the formula.</summary>
            /// <returns>Return a reference to the cleared object.</returns>
            public global::OpenXLSX.OpenXLSX.XLFormulaProxy Clear
            {
                get
                {
                    var ___ret = __Internal.Clear(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLFormulaProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class XLFormula
        {
            public partial struct __Internal
            {
            }

            public const bool XLResetValue = true;
            public const bool XLPreserveValue = false;        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>This class encapsulate the Excel concept of Shared Strings. In Excel, instead of havig individual strings</para>
        /// <para>in each cell, cells have a reference to an entry in the SharedStrings register. This results in smalle file</para>
        /// <para>sizes, as repeated strings are referenced easily.</para>
        /// </summary>
        public unsafe partial class XLSharedStrings : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;
                internal __IntPtr m_stringCache;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSharedStrings@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSharedStrings@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLSharedStrings@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getStringIndex@XLSharedStrings@OpenXLSX@@QEBAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetStringIndex(__IntPtr __instance, __IntPtr str);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?stringExists@XLSharedStrings@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool StringExists(__IntPtr __instance, __IntPtr str);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getString@XLSharedStrings@OpenXLSX@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetString(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?appendString@XLSharedStrings@OpenXLSX@@QEAAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int AppendString(__IntPtr __instance, __IntPtr str);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clearString@XLSharedStrings@OpenXLSX@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearString(__IntPtr __instance, int index);
            }

            internal static new XLSharedStrings __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLSharedStrings(native.ToPointer(), skipVTables);
            }

            internal static new XLSharedStrings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLSharedStrings)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLSharedStrings __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLSharedStrings(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLSharedStrings(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLSharedStrings(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLSharedStrings()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLSharedStrings(global::OpenXLSX.OpenXLSX.XLSharedStrings other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int GetStringIndex(string str)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, str);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.GetStringIndex(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool StringExists(string str)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, str);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.StringExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public string GetString(int index)
            {
                var ___ret = __Internal.GetString(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Append a new string to the list of shared strings.</summary>
            /// <param name="str">The string to append.</param>
            /// <returns>An int32_t with the index of the appended string</returns>
            public int AppendString(string str)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, str);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.AppendString(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Clear the string at the given index.</summary>
            /// <param name="index">The index to clear.</param>
            /// <remarks>
            /// <para>There is no 'deleteString' member function, as deleting a shared string node will invalidate the</para>
            /// <para>shared string indices for the cells in the spreadsheet. Instead use this member functions, which clears</para>
            /// <para>the contents of the string, but keeps the XMLNode holding the string.</para>
            /// </remarks>
            public void ClearString(int index)
            {
                __Internal.ClearString(__Instance, index);
            }
        }

        public unsafe partial class XLSharedStrings
        {
            public partial struct __Internal
            {
            }

            public const ulong XLMaxSharedStrings = 2147483647;        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLXmlFile class provides an interface for derived classes to use.</para>
        /// <para>It functions as an ancestor to all classes which are represented by an .xml file in an .xlsx package.</para>
        /// </summary>
        /// <remarks>
        /// <para>The XLXmlFile class is not intended to be instantiated on it's own, but to provide an interface for</para>
        /// <para>derived classes. Also, it should not be used polymorphically. For that reason, the destructor is not declared virtual.</para>
        /// </remarks>
        public unsafe partial class XLXmlFile : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlFile@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlFile@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlFile@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLXmlFile@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?xmlData@XLXmlFile@OpenXLSX@@IEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void XmlData(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setXmlData@XLXmlFile@OpenXLSX@@IEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetXmlData(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?relationshipID@XLXmlFile@OpenXLSX@@IEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RelationshipID(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?parentDoc@XLXmlFile@OpenXLSX@@IEAAAEAVXLDocument@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ParentDoc(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?xmlDocument@XLXmlFile@OpenXLSX@@IEAAAEAVOpenXLSX_xml_document@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr XmlDocument(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlFile> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlFile>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLXmlFile managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLXmlFile managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLXmlFile __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLXmlFile(native.ToPointer(), skipVTables);
            }

            internal static XLXmlFile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLXmlFile)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLXmlFile __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLXmlFile(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLXmlFile(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLXmlFile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor.</summary>
            public XLXmlFile()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. Creates an object based on the xmlData input.</summary>
            /// <param name="xmlData">An XLXmlData object with the XML data to be represented by the object.</param>
            public XLXmlFile(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy constructor. Default implementation used.</summary>
            /// <param name="other">The object to copy.</param>
            public XLXmlFile(global::OpenXLSX.OpenXLSX.XLXmlFile other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal*) other.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLXmlFile(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLXmlFile(xmlData);
            }

            /// <summary>The underlying XML data object.</summary>
            protected global::OpenXLSX.OpenXLSX.XLXmlData MXmlData
            {
                get
                {
                    var __result0 = global::OpenXLSX.OpenXLSX.XLXmlData.__GetOrCreateInstance(((__Internal*)__Instance)->m_xmlData, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->m_xmlData = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            /// <summary>Method for getting the XML data represented by the object.</summary>
            /// <param name="xmlData">A std::string with the XML data.</param>
            /// <returns>
            /// <para>A std::string with the XML data.</para>
            /// <para>Provide the XML data represented by the object.</para>
            /// </returns>
            protected string XmlData
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.XmlData(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetXmlData(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>This function returns the relationship ID (the ID used in the XLRelationships objects) for the object.</summary>
            /// <returns>
            /// <para>A std::string with the ID. Not all spreadsheet objects may have a relationship ID. In those cases an empty string is</para>
            /// <para>returned.</para>
            /// </returns>
            protected string RelationshipID
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.RelationshipID(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>This function provides access to the parent XLDocument object.</summary>
            /// <returns>A reference to the parent XLDocument object.</returns>
            protected global::OpenXLSX.OpenXLSX.XLDocument ParentDoc
            {
                get
                {
                    var ___ret = __Internal.ParentDoc(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLDocument.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>This function provides access to the underlying XMLDocument object.</summary>
            /// <returns>A reference to the XMLDocument object.</returns>
            protected global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document XmlDocument
            {
                get
                {
                    var ___ret = __Internal.XmlDocument(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public enum XLUnderlineStyle : byte
        {
            XLUnderlineNone = 0,
            XLUnderlineSingle = 1,
            XLUnderlineDouble = 2,
            XLUnderlineInvalid = 255
        }

        public enum XLFontSchemeStyle : byte
        {
            XLFontSchemeNone = 0,
            XLFontSchemeMajor = 1,
            XLFontSchemeMinor = 2,
            XLFontSchemeInvalid = 255
        }

        public enum XLVerticalAlignRunStyle : byte
        {
            XLBaseline = 0,
            XLSubscript = 1,
            XLSuperscript = 2,
            XLVerticalAlignRunInvalid = 255
        }

        public enum XLFillType : byte
        {
            XLGradientFill = 0,
            XLPatternFill = 1,
            XLFillTypeInvalid = 255
        }

        public enum XLGradientType : byte
        {
            XLGradientLinear = 0,
            XLGradientPath = 1,
            XLGradientTypeInvalid = 255
        }

        public enum XLPatternType : byte
        {
            XLPatternNone = 0,
            XLPatternSolid = 1,
            XLPatternMediumGray = 2,
            XLPatternDarkGray = 3,
            XLPatternLightGray = 4,
            XLPatternDarkHorizontal = 5,
            XLPatternDarkVertical = 6,
            XLPatternDarkDown = 7,
            XLPatternDarkUp = 8,
            XLPatternDarkGrid = 9,
            XLPatternDarkTrellis = 10,
            XLPatternLightHorizontal = 11,
            XLPatternLightVertical = 12,
            XLPatternLightDown = 13,
            XLPatternLightUp = 14,
            XLPatternLightGrid = 15,
            XLPatternLightTrellis = 16,
            XLPatternGray125 = 17,
            XLPatternGray0625 = 18,
            XLPatternTypeInvalid = 255
        }

        public enum XLLineStyle : byte
        {
            XLLineStyleNone = 0,
            XLLineStyleThin = 1,
            XLLineStyleMedium = 2,
            XLLineStyleDashed = 3,
            XLLineStyleDotted = 4,
            XLLineStyleThick = 5,
            XLLineStyleDouble = 6,
            XLLineStyleHair = 7,
            XLLineStyleMediumDashed = 8,
            XLLineStyleDashDot = 9,
            XLLineStyleMediumDashDot = 10,
            XLLineStyleDashDotDot = 11,
            XLLineStyleMediumDashDotDot = 12,
            XLLineStyleSlantDashDot = 13,
            XLLineStyleInvalid = 255
        }

        public enum XLLineType : byte
        {
            XLLineLeft = 0,
            XLLineRight = 1,
            XLLineTop = 2,
            XLLineBottom = 3,
            XLLineDiagonal = 4,
            XLLineVertical = 5,
            XLLineHorizontal = 6,
            XLLineInvalid = 255
        }

        public enum XLAlignmentStyle : byte
        {
            XLAlignGeneral = 0,
            XLAlignLeft = 1,
            XLAlignRight = 2,
            XLAlignCenter = 3,
            XLAlignTop = 4,
            XLAlignBottom = 5,
            XLAlignFill = 6,
            XLAlignJustify = 7,
            XLAlignCenterContinuous = 8,
            XLAlignDistributed = 9,
            XLAlignInvalid = 255
        }

        public enum XLReadingOrder : uint
        {
            XLReadingOrderContextual = 0,
            XLReadingOrderLeftToRight = 1,
            XLReadingOrderRightToLeft = 2
        }

        public unsafe partial class XLUnsupportedElement : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLUnsupportedElement@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLUnsupportedElement@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?empty@XLUnsupportedElement@OpenXLSX@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Empty(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLUnsupportedElement> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLUnsupportedElement>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLUnsupportedElement managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLUnsupportedElement managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLUnsupportedElement __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLUnsupportedElement(native.ToPointer(), skipVTables);
            }

            internal static XLUnsupportedElement __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLUnsupportedElement)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLUnsupportedElement __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLUnsupportedElement(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLUnsupportedElement(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLUnsupportedElement(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLUnsupportedElement()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLUnsupportedElement.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLUnsupportedElement(global::OpenXLSX.OpenXLSX.XLUnsupportedElement _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLUnsupportedElement.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLUnsupportedElement.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLUnsupportedElement.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public bool Empty
            {
                get
                {
                    var ___ret = __Internal.Empty(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>An encapsulation of a number format (numFmt) item</summary>
        public unsafe partial class XLNumberFormat : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_numberFormatNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLNumberFormat@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLNumberFormat@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLNumberFormat@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLNumberFormat@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setNumberFormatId@XLNumberFormat@OpenXLSX@@QEAA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetNumberFormatId(__IntPtr __instance, uint newNumberFormatId);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFormatCode@XLNumberFormat@OpenXLSX@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFormatCode(__IntPtr __instance, __IntPtr newFormatCode);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numberFormatId@XLNumberFormat@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint NumberFormatId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?formatCode@XLNumberFormat@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FormatCode(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLNumberFormat@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLNumberFormat> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLNumberFormat>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLNumberFormat managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLNumberFormat managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLNumberFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLNumberFormat(native.ToPointer(), skipVTables);
            }

            internal static XLNumberFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLNumberFormat)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLNumberFormat __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLNumberFormat(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLNumberFormat(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLNumberFormat(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLNumberFormat()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the styles item. If no input is provided, a null node is used.</param>
            public XLNumberFormat(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLNumberFormat(global::OpenXLSX.OpenXLSX.XLNumberFormat other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Setter functions for style parameters</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetNumberFormatId(uint newNumberFormatId)
            {
                var ___ret = __Internal.SetNumberFormatId(__Instance, newNumberFormatId);
                return ___ret;
            }

            public bool SetFormatCode(string newFormatCode)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, newFormatCode);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SetFormatCode(__Instance, __arg0);
                __basicString0.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLNumberFormat(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLNumberFormat(node);
            }

            /// <summary>Get the id of the number format</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>
            /// <para>The id for this number format</para>
            /// <para>Setter functions for style parameters</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            public uint NumberFormatId
            {
                get
                {
                    var ___ret = __Internal.NumberFormatId(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetNumberFormatId(__Instance, value);
                }
            }

            /// <summary>Get the code of the number format</summary>
            /// <returns>The format code for this number format</returns>
            public string FormatCode
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.FormatCode(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetFormatCode(__Instance, __arg0);
                    __basicString0.Dispose(disposing: true, callNativeDtor:false);
                }
            }

            /// <summary>Return a string summary of the number format</summary>
            /// <returns>string with info about the number format object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of the XLSX number formats (numFmts)</summary>
        public unsafe partial class XLNumberFormats : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_numberFormatsNode;
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_OpenXLSX_S_XLNumberFormat___N_std_S_allocator__S0_ m_numberFormats;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLNumberFormats@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLNumberFormats@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLNumberFormats@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLNumberFormats@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numberFormatByIndex@XLNumberFormats@OpenXLSX@@QEBA?AVXLNumberFormat@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NumberFormatByIndex(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numberFormatById@XLNumberFormats@OpenXLSX@@QEBA?AVXLNumberFormat@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NumberFormatById(__IntPtr __instance, __IntPtr @return, uint numberFormatId);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numberFormatIdFromIndex@XLNumberFormats@OpenXLSX@@QEBAI_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint NumberFormatIdFromIndex(__IntPtr __instance, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLNumberFormats@OpenXLSX@@QEAA_KVXLNumberFormat@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Create(__IntPtr __instance, __IntPtr copyFrom, __IntPtr styleEntriesPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??AXLNumberFormats@OpenXLSX@@QEBA?AVXLNumberFormat@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorSubscript(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?count@XLNumberFormats@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Count(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLNumberFormats> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLNumberFormats>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLNumberFormats managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLNumberFormats managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLNumberFormats __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLNumberFormats(native.ToPointer(), skipVTables);
            }

            internal static XLNumberFormats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLNumberFormats)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLNumberFormats __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLNumberFormats(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLNumberFormats.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLNumberFormats(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLNumberFormats(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLNumberFormats()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLNumberFormats.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the styles item. If no input is provided, a null node is used.</param>
            public XLNumberFormats(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLNumberFormats.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLNumberFormats(global::OpenXLSX.OpenXLSX.XLNumberFormats other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLNumberFormats.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the number format identified by index</summary>
            /// <param name="index">an array index within XLStyles::numberFormats()</param>
            /// <returns>An XLNumberFormat object</returns>
            /// <remarks>XLException when index is out of m_numberFormats range</remarks>
            public global::OpenXLSX.OpenXLSX.XLNumberFormat NumberFormatByIndex(ulong index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal();
                __Internal.NumberFormatByIndex(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLNumberFormat.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the number format identified by numberFormatId</summary>
            /// <param name="numberFormatId">a numFmtId reference to a number format</param>
            /// <returns>An XLNumberFormat object</returns>
            /// <remarks>XLException if no match for numberFormatId is found within m_numberFormats</remarks>
            public global::OpenXLSX.OpenXLSX.XLNumberFormat NumberFormatById(uint numberFormatId)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal();
                __Internal.NumberFormatById(__Instance, new IntPtr(&___ret), numberFormatId);
                var _____ret = global::OpenXLSX.OpenXLSX.XLNumberFormat.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the numFmtId from the number format identified by index</summary>
            /// <param name="index">an array index within XLStyles::numberFormats()</param>
            /// <returns>the uint32_t numFmtId corresponding to index</returns>
            /// <remarks>XLException when index is out of m_numberFormats range</remarks>
            public uint NumberFormatIdFromIndex(ulong index)
            {
                var ___ret = __Internal.NumberFormatIdFromIndex(__Instance, index);
                return ___ret;
            }

            /// <summary>Append a new XLNumberFormat, based on copyFrom, and return its index in numFmts node</summary>
            /// <param name="copyFrom">Can provide an XLNumberFormat to use as template for the new style</param>
            /// <param name="styleEntriesPrefix">Prefix the newly created cell style XMLNode with this pugi::node_pcdata text</param>
            /// <remarks>
            /// <para>The index of the new style as used by operator[]</para>
            /// <para>: TBD assign a unique, non-reserved uint32_t numFmtId. Alternatively, the user should configure it manually via setNumberFormatId</para>
            /// <para>: TBD implement a &quot;getFreeNumberFormatId()&quot; method that skips reserved identifiers and iterates over m_numberFormats to avoid</para>
            /// <para>all existing number format Ids.</para>
            /// </remarks>
            public ulong Create(global::OpenXLSX.OpenXLSX.XLNumberFormat copyFrom, string styleEntriesPrefix)
            {
                if (ReferenceEquals(copyFrom, null))
                    throw new global::System.ArgumentNullException("copyFrom", "Cannot be null because it is passed by value.");
                var __arg0 = copyFrom.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, styleEntriesPrefix);
                var __arg1 = __basicString1.__Instance;
                var ___ret = __Internal.Create(__Instance, __arg0, __arg1);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLNumberFormats(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLNumberFormats(node);
            }

            public global::OpenXLSX.OpenXLSX.XLNumberFormat this[ulong index]
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal();
                    __Internal.OperatorSubscript(__Instance, new IntPtr(&___ret), index);
                    var _____ret = global::OpenXLSX.OpenXLSX.XLNumberFormat.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLNumberFormat.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the count of number formats</summary>
            /// <returns>The amount of entries in the number formats</returns>
            public ulong Count
            {
                get
                {
                    var ___ret = __Internal.Count(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>An encapsulation of a font item</summary>
        public unsafe partial class XLFont : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_fontNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFont@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFont@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFont@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLFont@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFontName@XLFont@OpenXLSX@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFontName(__IntPtr __instance, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFontCharset@XLFont@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFontCharset(__IntPtr __instance, ulong newCharset);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFontFamily@XLFont@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFontFamily(__IntPtr __instance, ulong newFamily);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFontSize@XLFont@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFontSize(__IntPtr __instance, ulong newSize);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFontColor@XLFont@OpenXLSX@@QEAA_NVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFontColor(__IntPtr __instance, __IntPtr newColor);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setBold@XLFont@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetBold(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setItalic@XLFont@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetItalic(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setStrikethrough@XLFont@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetStrikethrough(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setUnderline@XLFont@OpenXLSX@@QEAA_NW4XLUnderlineStyle@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetUnderline(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLUnderlineStyle style);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setScheme@XLFont@OpenXLSX@@QEAA_NW4XLFontSchemeStyle@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetScheme(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLFontSchemeStyle newScheme);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setVertAlign@XLFont@OpenXLSX@@QEAA_NW4XLVerticalAlignRunStyle@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetVertAlign(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLVerticalAlignRunStyle newVertAlign);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setOutline@XLFont@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetOutline(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setShadow@XLFont@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetShadow(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setCondense@XLFont@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetCondense(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setExtend@XLFont@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetExtend(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fontName@XLFont@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FontName(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fontCharset@XLFont@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong FontCharset(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fontFamily@XLFont@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong FontFamily(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fontSize@XLFont@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong FontSize(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fontColor@XLFont@OpenXLSX@@QEBA?AVXLColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FontColor(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?bold@XLFont@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Bold(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?italic@XLFont@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Italic(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?strikethrough@XLFont@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Strikethrough(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?underline@XLFont@OpenXLSX@@QEBA?AW4XLUnderlineStyle@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLUnderlineStyle Underline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?scheme@XLFont@OpenXLSX@@QEBA?AW4XLFontSchemeStyle@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLFontSchemeStyle Scheme(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?vertAlign@XLFont@OpenXLSX@@QEBA?AW4XLVerticalAlignRunStyle@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLVerticalAlignRunStyle VertAlign(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?outline@XLFont@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Outline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?shadow@XLFont@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Shadow(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?condense@XLFont@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Condense(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?extend@XLFont@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Extend(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLFont@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFont> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFont>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLFont managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLFont managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLFont __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFont(native.ToPointer(), skipVTables);
            }

            internal static XLFont __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFont)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLFont __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFont(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLFont.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLFont(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFont(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLFont()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFont.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the fonts XMLNode. If no input is provided, a null node is used.</param>
            public XLFont(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFont.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLFont(global::OpenXLSX.OpenXLSX.XLFont other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFont.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Setter functions for style parameters</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetFontName(string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, newName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SetFontName(__Instance, __arg0);
                __basicString0.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public bool SetFontCharset(ulong newCharset)
            {
                var ___ret = __Internal.SetFontCharset(__Instance, newCharset);
                return ___ret;
            }

            public bool SetFontFamily(ulong newFamily)
            {
                var ___ret = __Internal.SetFontFamily(__Instance, newFamily);
                return ___ret;
            }

            public bool SetFontSize(ulong newSize)
            {
                var ___ret = __Internal.SetFontSize(__Instance, newSize);
                return ___ret;
            }

            public bool SetFontColor(global::OpenXLSX.OpenXLSX.XLColor newColor)
            {
                if (ReferenceEquals(newColor, null))
                    throw new global::System.ArgumentNullException("newColor", "Cannot be null because it is passed by value.");
                var __arg0 = newColor.__Instance;
                var ___ret = __Internal.SetFontColor(__Instance, __arg0);
                return ___ret;
            }

            public bool SetBold(bool set)
            {
                var ___ret = __Internal.SetBold(__Instance, set);
                return ___ret;
            }

            public bool SetItalic(bool set)
            {
                var ___ret = __Internal.SetItalic(__Instance, set);
                return ___ret;
            }

            public bool SetStrikethrough(bool set)
            {
                var ___ret = __Internal.SetStrikethrough(__Instance, set);
                return ___ret;
            }

            public bool SetUnderline(global::OpenXLSX.OpenXLSX.XLUnderlineStyle style)
            {
                var ___ret = __Internal.SetUnderline(__Instance, style);
                return ___ret;
            }

            public bool SetScheme(global::OpenXLSX.OpenXLSX.XLFontSchemeStyle newScheme)
            {
                var ___ret = __Internal.SetScheme(__Instance, newScheme);
                return ___ret;
            }

            public bool SetVertAlign(global::OpenXLSX.OpenXLSX.XLVerticalAlignRunStyle newVertAlign)
            {
                var ___ret = __Internal.SetVertAlign(__Instance, newVertAlign);
                return ___ret;
            }

            public bool SetOutline(bool set)
            {
                var ___ret = __Internal.SetOutline(__Instance, set);
                return ___ret;
            }

            public bool SetShadow(bool set)
            {
                var ___ret = __Internal.SetShadow(__Instance, set);
                return ___ret;
            }

            public bool SetCondense(bool set)
            {
                var ___ret = __Internal.SetCondense(__Instance, set);
                return ___ret;
            }

            public bool SetExtend(bool set)
            {
                var ___ret = __Internal.SetExtend(__Instance, set);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLFont(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLFont(node);
            }

            /// <summary>Get the font name</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>
            /// <para>The font name</para>
            /// <para>Setter functions for style parameters</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            public string FontName
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.FontName(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetFontName(__Instance, __arg0);
                    __basicString0.Dispose(disposing: true, callNativeDtor:false);
                }
            }

            /// <summary>Get the font charset</summary>
            /// <returns>The font charset id</returns>
            public ulong FontCharset
            {
                get
                {
                    var ___ret = __Internal.FontCharset(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFontCharset(__Instance, value);
                }
            }

            /// <summary>Get the font family</summary>
            /// <returns>The font family id</returns>
            public ulong FontFamily
            {
                get
                {
                    var ___ret = __Internal.FontFamily(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFontFamily(__Instance, value);
                }
            }

            /// <summary>Get the font size</summary>
            /// <returns>The font size</returns>
            public ulong FontSize
            {
                get
                {
                    var ___ret = __Internal.FontSize(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFontSize(__Instance, value);
                }
            }

            /// <summary>Get the font color</summary>
            /// <returns>The font color</returns>
            public global::OpenXLSX.OpenXLSX.XLColor FontColor
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLColor.__Internal();
                    __Internal.FontColor(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLColor.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLColor.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    __Internal.SetFontColor(__Instance, __arg0);
                }
            }

            /// <summary>Get the font bold status</summary>
            /// <returns>true = bold, false = not bold</returns>
            public bool Bold
            {
                get
                {
                    var ___ret = __Internal.Bold(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBold(__Instance, value);
                }
            }

            /// <summary>Get the font italic (cursive) status</summary>
            /// <returns>true = italic, false = not italice</returns>
            public bool Italic
            {
                get
                {
                    var ___ret = __Internal.Italic(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetItalic(__Instance, value);
                }
            }

            /// <summary>Get the font strikethrough status</summary>
            /// <returns>true = strikethrough, false = no strikethrough</returns>
            public bool Strikethrough
            {
                get
                {
                    var ___ret = __Internal.Strikethrough(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetStrikethrough(__Instance, value);
                }
            }

            /// <summary>Get the font underline status</summary>
            /// <returns>An XLUnderlineStyle value</returns>
            public global::OpenXLSX.OpenXLSX.XLUnderlineStyle Underline
            {
                get
                {
                    var ___ret = __Internal.Underline(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetUnderline(__Instance, value);
                }
            }

            /// <summary>get the font scheme: none, major or minor</summary>
            /// <returns>An XLFontSchemeStyle</returns>
            public global::OpenXLSX.OpenXLSX.XLFontSchemeStyle Scheme
            {
                get
                {
                    var ___ret = __Internal.Scheme(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetScheme(__Instance, value);
                }
            }

            /// <summary>get the font vertical alignment run style: baseline, subscript or superscript</summary>
            /// <returns>An XLVerticalAlignRunStyle</returns>
            public global::OpenXLSX.OpenXLSX.XLVerticalAlignRunStyle VertAlign
            {
                get
                {
                    var ___ret = __Internal.VertAlign(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetVertAlign(__Instance, value);
                }
            }

            /// <summary>Get the outline status</summary>
            /// <returns>a TBD bool</returns>
            /// <remarks>need to find a use case for this</remarks>
            public bool Outline
            {
                get
                {
                    var ___ret = __Internal.Outline(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOutline(__Instance, value);
                }
            }

            /// <summary>Get the shadow status</summary>
            /// <returns>a TBD bool</returns>
            /// <remarks>need to find a use case for this</remarks>
            public bool Shadow
            {
                get
                {
                    var ___ret = __Internal.Shadow(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShadow(__Instance, value);
                }
            }

            /// <summary>Get the condense status</summary>
            /// <returns>a TBD bool</returns>
            /// <remarks>need to find a use case for this</remarks>
            public bool Condense
            {
                get
                {
                    var ___ret = __Internal.Condense(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCondense(__Instance, value);
                }
            }

            /// <summary>Get the extend status</summary>
            /// <returns>a TBD bool</returns>
            /// <remarks>need to find a use case for this</remarks>
            public bool Extend
            {
                get
                {
                    var ___ret = __Internal.Extend(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetExtend(__Instance, value);
                }
            }

            /// <summary>Return a string summary of the font properties</summary>
            /// <returns>string with info about the font object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of the XLSX fonts</summary>
        public unsafe partial class XLFonts : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_fontsNode;
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_OpenXLSX_S_XLFont___N_std_S_allocator__S0_ m_fonts;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFonts@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFonts@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFonts@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLFonts@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fontByIndex@XLFonts@OpenXLSX@@QEBA?AVXLFont@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FontByIndex(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLFonts@OpenXLSX@@QEAA_KVXLFont@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Create(__IntPtr __instance, __IntPtr copyFrom, __IntPtr styleEntriesPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??AXLFonts@OpenXLSX@@QEBA?AVXLFont@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorSubscript(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?count@XLFonts@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Count(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFonts> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFonts>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLFonts managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLFonts managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLFonts __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFonts(native.ToPointer(), skipVTables);
            }

            internal static XLFonts __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFonts)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLFonts __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFonts(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLFonts.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLFonts(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFonts(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLFonts()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFonts.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the styles item. If no input is provided, a null node is used.</param>
            public XLFonts(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFonts.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLFonts(global::OpenXLSX.OpenXLSX.XLFonts other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFonts.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the font identified by index</summary>
            /// <param name="index">The index within the XML sequence</param>
            /// <returns>An XLFont object</returns>
            public global::OpenXLSX.OpenXLSX.XLFont FontByIndex(ulong index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLFont.__Internal();
                __Internal.FontByIndex(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLFont.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLFont.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Append a new XLFont, based on copyFrom, and return its index in fonts node</summary>
            /// <param name="copyFrom">Can provide an XLFont to use as template for the new style</param>
            /// <param name="styleEntriesPrefix">Prefix the newly created cell style XMLNode with this pugi::node_pcdata text</param>
            /// <remarks>The index of the new style as used by operator[]</remarks>
            public ulong Create(global::OpenXLSX.OpenXLSX.XLFont copyFrom, string styleEntriesPrefix)
            {
                if (ReferenceEquals(copyFrom, null))
                    throw new global::System.ArgumentNullException("copyFrom", "Cannot be null because it is passed by value.");
                var __arg0 = copyFrom.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, styleEntriesPrefix);
                var __arg1 = __basicString1.__Instance;
                var ___ret = __Internal.Create(__Instance, __arg0, __arg1);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLFonts(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLFonts(node);
            }

            public global::OpenXLSX.OpenXLSX.XLFont this[ulong index]
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLFont.__Internal();
                    __Internal.OperatorSubscript(__Instance, new IntPtr(&___ret), index);
                    var _____ret = global::OpenXLSX.OpenXLSX.XLFont.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLFont.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the count of fonts</summary>
            /// <returns>The amount of font entries</returns>
            public ulong Count
            {
                get
                {
                    var ___ret = __Internal.Count(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>An encapsulation of an XLSX Data Bar Color (CT_Color) item</summary>
        public unsafe partial class XLDataBarColor : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_colorNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDataBarColor@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDataBarColor@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDataBarColor@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLDataBarColor@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRgb@XLDataBarColor@OpenXLSX@@QEAA_NVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetRgb(__IntPtr __instance, __IntPtr newColor);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set@XLDataBarColor@OpenXLSX@@QEAA_NVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Set(__IntPtr __instance, __IntPtr newColor);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setTint@XLDataBarColor@OpenXLSX@@QEAA_NN@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetTint(__IntPtr __instance, double newTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setAutomatic@XLDataBarColor@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetAutomatic(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setIndexed@XLDataBarColor@OpenXLSX@@QEAA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetIndexed(__IntPtr __instance, uint newIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setTheme@XLDataBarColor@OpenXLSX@@QEAA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetTheme(__IntPtr __instance, uint newTheme);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rgb@XLDataBarColor@OpenXLSX@@QEBA?AVXLColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rgb(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?tint@XLDataBarColor@OpenXLSX@@QEBANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Tint(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?automatic@XLDataBarColor@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Automatic(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?indexed@XLDataBarColor@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint Indexed(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?theme@XLDataBarColor@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint Theme(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLDataBarColor@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDataBarColor> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDataBarColor>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLDataBarColor managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLDataBarColor managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLDataBarColor __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLDataBarColor(native.ToPointer(), skipVTables);
            }

            internal static XLDataBarColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLDataBarColor)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLDataBarColor __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLDataBarColor(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLDataBarColor.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLDataBarColor(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLDataBarColor(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLDataBarColor()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDataBarColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLGradientStop or XLLine object.</summary>
            /// <param name="node">An XMLNode object with a data bar color XMLNode. If no input is provided, a null node is used.</param>
            public XLDataBarColor(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDataBarColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLDataBarColor(global::OpenXLSX.OpenXLSX.XLDataBarColor other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDataBarColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Setter functions for data bar color parameters</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetRgb(global::OpenXLSX.OpenXLSX.XLColor newColor)
            {
                if (ReferenceEquals(newColor, null))
                    throw new global::System.ArgumentNullException("newColor", "Cannot be null because it is passed by value.");
                var __arg0 = newColor.__Instance;
                var ___ret = __Internal.SetRgb(__Instance, __arg0);
                return ___ret;
            }

            public bool Set(global::OpenXLSX.OpenXLSX.XLColor newColor)
            {
                if (ReferenceEquals(newColor, null))
                    throw new global::System.ArgumentNullException("newColor", "Cannot be null because it is passed by value.");
                var __arg0 = newColor.__Instance;
                var ___ret = __Internal.Set(__Instance, __arg0);
                return ___ret;
            }

            public bool SetTint(double newTint)
            {
                var ___ret = __Internal.SetTint(__Instance, newTint);
                return ___ret;
            }

            public bool SetAutomatic(bool set)
            {
                var ___ret = __Internal.SetAutomatic(__Instance, set);
                return ___ret;
            }

            public bool SetIndexed(uint newIndex)
            {
                var ___ret = __Internal.SetIndexed(__Instance, newIndex);
                return ___ret;
            }

            public bool SetTheme(uint newTheme)
            {
                var ___ret = __Internal.SetTheme(__Instance, newTheme);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLDataBarColor(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLDataBarColor(node);
            }

            /// <summary>Get the line color from the rgb attribute</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>
            /// <para>An XLColor object</para>
            /// <para>Setter functions for data bar color parameters</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            public global::OpenXLSX.OpenXLSX.XLColor Rgb
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLColor.__Internal();
                    __Internal.Rgb(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLColor.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLColor.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    __Internal.SetRgb(__Instance, __arg0);
                }
            }

            /// <summary>Get the line color tint</summary>
            /// <returns>A double value as stored in the &quot;tint&quot; attribute (should be between [-1.0;+1.0]), 0.0 if attribute does not exist</returns>
            public double Tint
            {
                get
                {
                    var ___ret = __Internal.Tint(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTint(__Instance, value);
                }
            }

            /// <summary>currently unsupported getter stubs</summary>
            public bool Automatic
            {
                get
                {
                    var ___ret = __Internal.Automatic(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetAutomatic(__Instance, value);
                }
            }

            public uint Indexed
            {
                get
                {
                    var ___ret = __Internal.Indexed(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIndexed(__Instance, value);
                }
            }

            public uint Theme
            {
                get
                {
                    var ___ret = __Internal.Theme(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTheme(__Instance, value);
                }
            }

            /// <summary>Return a string summary of the color properties</summary>
            /// <returns>string with info about the color object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of an fill::gradientFill::stop item</summary>
        public unsafe partial class XLGradientStop : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_stopNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLGradientStop@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLGradientStop@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLGradientStop@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLGradientStop@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setPosition@XLGradientStop@OpenXLSX@@QEAA_NN@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetPosition(__IntPtr __instance, double newPosition);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?color@XLGradientStop@OpenXLSX@@QEBA?AVXLDataBarColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Color(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?position@XLGradientStop@OpenXLSX@@QEBANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Position(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLGradientStop@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLGradientStop> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLGradientStop>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLGradientStop managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLGradientStop managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLGradientStop __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLGradientStop(native.ToPointer(), skipVTables);
            }

            internal static XLGradientStop __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLGradientStop)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLGradientStop __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLGradientStop(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLGradientStop.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLGradientStop(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLGradientStop(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLGradientStop()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLGradientStop.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLGradientStops object.</summary>
            /// <param name="node">An XMLNode object with the gradient stop XMLNode. If no input is provided, a null node is used.</param>
            public XLGradientStop(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLGradientStop.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLGradientStop(global::OpenXLSX.OpenXLSX.XLGradientStop other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLGradientStop.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Setter functions</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            /// <remarks>for color setters, use the color() getter with the XLDataBarColor setter functions</remarks>
            public bool SetPosition(double newPosition)
            {
                var ___ret = __Internal.SetPosition(__Instance, newPosition);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLGradientStop(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLGradientStop(node);
            }

            /// <summary>Getter functions</summary>
            /// <returns>The requested gradient stop property</returns>
            public global::OpenXLSX.OpenXLSX.XLDataBarColor Color
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLDataBarColor.__Internal();
                    __Internal.Color(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLDataBarColor.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLDataBarColor.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public double Position
            {
                get
                {
                    var ___ret = __Internal.Position(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPosition(__Instance, value);
                }
            }

            /// <summary>Return a string summary of the stop properties</summary>
            /// <returns>string with info about the stop object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of an array of fill::gradientFill::stop items</summary>
        public unsafe partial class XLGradientStops : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_gradientNode;
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_OpenXLSX_S_XLGradientStop___N_std_S_allocator__S0_ m_gradientStops;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLGradientStops@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLGradientStops@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLGradientStops@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLGradientStops@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?stopByIndex@XLGradientStops@OpenXLSX@@QEBA?AVXLGradientStop@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void StopByIndex(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLGradientStops@OpenXLSX@@QEAA_KVXLGradientStop@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Create(__IntPtr __instance, __IntPtr copyFrom, __IntPtr styleEntriesPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??AXLGradientStops@OpenXLSX@@QEBA?AVXLGradientStop@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorSubscript(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?count@XLGradientStops@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Count(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLGradientStops@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLGradientStops> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLGradientStops>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLGradientStops managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLGradientStops managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLGradientStops __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLGradientStops(native.ToPointer(), skipVTables);
            }

            internal static XLGradientStops __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLGradientStops)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLGradientStops __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLGradientStops(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLGradientStops.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLGradientStops(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLGradientStops(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLGradientStops()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLGradientStops.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLFill object.</summary>
            /// <param name="node">An XMLNode object with the gradientFill item. If no input is provided, a null node is used.</param>
            public XLGradientStops(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLGradientStops.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLGradientStops(global::OpenXLSX.OpenXLSX.XLGradientStops other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLGradientStops.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the gradient stop entry identified by index</summary>
            /// <param name="index">The index within the XML sequence</param>
            /// <returns>An XLGradientStop object</returns>
            public global::OpenXLSX.OpenXLSX.XLGradientStop StopByIndex(ulong index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLGradientStop.__Internal();
                __Internal.StopByIndex(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLGradientStop.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLGradientStop.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Append a new XLGradientStop, based on copyFrom, and return its index in fills node</summary>
            /// <param name="copyFrom">Can provide an XLGradientStop to use as template for the new style</param>
            /// <param name="stopEntriesPrefix">Prefix the newly created stop XMLNode with this pugi::node_pcdata text</param>
            /// <remarks>The index of the new style as used by operator[]</remarks>
            public ulong Create(global::OpenXLSX.OpenXLSX.XLGradientStop copyFrom, string styleEntriesPrefix)
            {
                if (ReferenceEquals(copyFrom, null))
                    throw new global::System.ArgumentNullException("copyFrom", "Cannot be null because it is passed by value.");
                var __arg0 = copyFrom.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, styleEntriesPrefix);
                var __arg1 = __basicString1.__Instance;
                var ___ret = __Internal.Create(__Instance, __arg0, __arg1);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLGradientStops(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLGradientStops(node);
            }

            public global::OpenXLSX.OpenXLSX.XLGradientStop this[ulong index]
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLGradientStop.__Internal();
                    __Internal.OperatorSubscript(__Instance, new IntPtr(&___ret), index);
                    var _____ret = global::OpenXLSX.OpenXLSX.XLGradientStop.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLGradientStop.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the count of gradient stops</summary>
            /// <returns>The amount of stop entries</returns>
            public ulong Count
            {
                get
                {
                    var ___ret = __Internal.Count(__Instance);
                    return ___ret;
                }
            }

            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of a fill item</summary>
        public unsafe partial class XLFill : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_fillNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFill@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFill@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFill@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLFill@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFillType@XLFill@OpenXLSX@@QEAA_NW4XLFillType@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFillType(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLFillType newFillType, bool force);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setGradientType@XLFill@OpenXLSX@@QEAA_NW4XLGradientType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetGradientType(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLGradientType newType);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setDegree@XLFill@OpenXLSX@@QEAA_NN@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetDegree(__IntPtr __instance, double newDegree);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setLeft@XLFill@OpenXLSX@@QEAA_NN@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetLeft(__IntPtr __instance, double newLeft);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRight@XLFill@OpenXLSX@@QEAA_NN@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetRight(__IntPtr __instance, double newRight);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setTop@XLFill@OpenXLSX@@QEAA_NN@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetTop(__IntPtr __instance, double newTop);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setBottom@XLFill@OpenXLSX@@QEAA_NN@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetBottom(__IntPtr __instance, double newBottom);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setPatternType@XLFill@OpenXLSX@@QEAA_NW4XLPatternType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetPatternType(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLPatternType newPatternType);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColor@XLFill@OpenXLSX@@QEAA_NVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetColor(__IntPtr __instance, __IntPtr newColor);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setBackgroundColor@XLFill@OpenXLSX@@QEAA_NVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetBackgroundColor(__IntPtr __instance, __IntPtr newBgColor);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fillType@XLFill@OpenXLSX@@QEBA?AW4XLFillType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLFillType FillType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?gradientType@XLFill@OpenXLSX@@QEAA?AW4XLGradientType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLGradientType GradientType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?degree@XLFill@OpenXLSX@@QEAANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Degree(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?left@XLFill@OpenXLSX@@QEAANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Left(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?right@XLFill@OpenXLSX@@QEAANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Right(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?top@XLFill@OpenXLSX@@QEAANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Top(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?bottom@XLFill@OpenXLSX@@QEAANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Bottom(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?stops@XLFill@OpenXLSX@@QEAA?AVXLGradientStops@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Stops(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?patternType@XLFill@OpenXLSX@@QEAA?AW4XLPatternType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLPatternType PatternType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?color@XLFill@OpenXLSX@@QEAA?AVXLColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Color(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?backgroundColor@XLFill@OpenXLSX@@QEAA?AVXLColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void BackgroundColor(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLFill@OpenXLSX@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFill> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFill>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLFill managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLFill managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLFill __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFill(native.ToPointer(), skipVTables);
            }

            internal static XLFill __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFill)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLFill __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFill(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLFill.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLFill(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFill(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLFill()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFill.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the fill XMLNode. If no input is provided, a null node is used.</param>
            public XLFill(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFill.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLFill(global::OpenXLSX.OpenXLSX.XLFill other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFill.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Create&amp;set the base XML element describing the fill</summary>
            /// <param name="newFillType">that shall be set</param>
            /// <param name="force">erase an existing fillType() if not equal newFillType</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetFillType(global::OpenXLSX.OpenXLSX.XLFillType newFillType, bool force)
            {
                var ___ret = __Internal.SetFillType(__Instance, newFillType, force);
                return ___ret;
            }

            /// <summary>Setter functions for gradientFill - will throwOnFillType(XLPatternFill, __func__)</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            /// <remarks>
            /// <para>for gradient stops, use the stops() getter with the XLGradientStops access functions (create, stopByIndex, [])</para>
            /// <para>and the XLGradientStop setter functions</para>
            /// </remarks>
            public bool SetGradientType(global::OpenXLSX.OpenXLSX.XLGradientType newType)
            {
                var ___ret = __Internal.SetGradientType(__Instance, newType);
                return ___ret;
            }

            public bool SetDegree(double newDegree)
            {
                var ___ret = __Internal.SetDegree(__Instance, newDegree);
                return ___ret;
            }

            public bool SetLeft(double newLeft)
            {
                var ___ret = __Internal.SetLeft(__Instance, newLeft);
                return ___ret;
            }

            public bool SetRight(double newRight)
            {
                var ___ret = __Internal.SetRight(__Instance, newRight);
                return ___ret;
            }

            public bool SetTop(double newTop)
            {
                var ___ret = __Internal.SetTop(__Instance, newTop);
                return ___ret;
            }

            public bool SetBottom(double newBottom)
            {
                var ___ret = __Internal.SetBottom(__Instance, newBottom);
                return ___ret;
            }

            /// <summary>Setter functions for patternFill - will throwOnFillType(XLGradientFill, __func__)</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetPatternType(global::OpenXLSX.OpenXLSX.XLPatternType newPatternType)
            {
                var ___ret = __Internal.SetPatternType(__Instance, newPatternType);
                return ___ret;
            }

            public bool SetColor(global::OpenXLSX.OpenXLSX.XLColor newColor)
            {
                if (ReferenceEquals(newColor, null))
                    throw new global::System.ArgumentNullException("newColor", "Cannot be null because it is passed by value.");
                var __arg0 = newColor.__Instance;
                var ___ret = __Internal.SetColor(__Instance, __arg0);
                return ___ret;
            }

            public bool SetBackgroundColor(global::OpenXLSX.OpenXLSX.XLColor newBgColor)
            {
                if (ReferenceEquals(newBgColor, null))
                    throw new global::System.ArgumentNullException("newBgColor", "Cannot be null because it is passed by value.");
                var __arg0 = newBgColor.__Instance;
                var ___ret = __Internal.SetBackgroundColor(__Instance, __arg0);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLFill(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLFill(node);
            }

            /// <summary>Get the name of the element describing a fill</summary>
            /// <returns>The XLFillType derived from the name of the first child element of the fill node</returns>
            public global::OpenXLSX.OpenXLSX.XLFillType FillType
            {
                get
                {
                    var ___ret = __Internal.FillType(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Getter functions for gradientFill - will throwOnFillType(XLPatternFill, __func__)</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>
            /// <para>The requested gradientFill property</para>
            /// <para>Setter functions for gradientFill - will throwOnFillType(XLPatternFill, __func__)</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            /// <remarks>
            /// <para>for gradient stops, use the stops() getter with the XLGradientStops access functions (create, stopByIndex, [])</para>
            /// <para>and the XLGradientStop setter functions</para>
            /// </remarks>
            public global::OpenXLSX.OpenXLSX.XLGradientType GradientType
            {
                get
                {
                    var ___ret = __Internal.GradientType(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetGradientType(__Instance, value);
                }
            }

            public double Degree
            {
                get
                {
                    var ___ret = __Internal.Degree(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDegree(__Instance, value);
                }
            }

            public double Left
            {
                get
                {
                    var ___ret = __Internal.Left(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLeft(__Instance, value);
                }
            }

            public double Right
            {
                get
                {
                    var ___ret = __Internal.Right(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRight(__Instance, value);
                }
            }

            public double Top
            {
                get
                {
                    var ___ret = __Internal.Top(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTop(__Instance, value);
                }
            }

            public double Bottom
            {
                get
                {
                    var ___ret = __Internal.Bottom(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBottom(__Instance, value);
                }
            }

            public global::OpenXLSX.OpenXLSX.XLGradientStops Stops
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLGradientStops.__Internal();
                    __Internal.Stops(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLGradientStops.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLGradientStops.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Getter functions for patternFill - will throwOnFillType(XLGradientFill, __func__)</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>
            /// <para>The requested patternFill property</para>
            /// <para>Setter functions for patternFill - will throwOnFillType(XLGradientFill, __func__)</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            public global::OpenXLSX.OpenXLSX.XLPatternType PatternType
            {
                get
                {
                    var ___ret = __Internal.PatternType(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPatternType(__Instance, value);
                }
            }

            public global::OpenXLSX.OpenXLSX.XLColor Color
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLColor.__Internal();
                    __Internal.Color(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLColor.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLColor.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    __Internal.SetColor(__Instance, __arg0);
                }
            }

            public global::OpenXLSX.OpenXLSX.XLColor BackgroundColor
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLColor.__Internal();
                    __Internal.BackgroundColor(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLColor.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLColor.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    var __arg0 = value.__Instance;
                    __Internal.SetBackgroundColor(__Instance, __arg0);
                }
            }

            /// <summary>Return a string summary of the fill properties</summary>
            /// <returns>string with info about the fill object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of the XLSX fills</summary>
        public unsafe partial class XLFills : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_fillsNode;
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_OpenXLSX_S_XLFill___N_std_S_allocator__S0_ m_fills;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFills@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFills@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFills@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLFills@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fillByIndex@XLFills@OpenXLSX@@QEBA?AVXLFill@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FillByIndex(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLFills@OpenXLSX@@QEAA_KVXLFill@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Create(__IntPtr __instance, __IntPtr copyFrom, __IntPtr styleEntriesPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??AXLFills@OpenXLSX@@QEBA?AVXLFill@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorSubscript(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?count@XLFills@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Count(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFills> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFills>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLFills managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLFills managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLFills __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFills(native.ToPointer(), skipVTables);
            }

            internal static XLFills __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFills)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLFills __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFills(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLFills.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLFills(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFills(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLFills()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFills.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the fills item. If no input is provided, a null node is used.</param>
            public XLFills(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFills.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLFills(global::OpenXLSX.OpenXLSX.XLFills other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFills.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the fill entry identified by index</summary>
            /// <param name="index">The index within the XML sequence</param>
            /// <returns>An XLFill object</returns>
            public global::OpenXLSX.OpenXLSX.XLFill FillByIndex(ulong index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLFill.__Internal();
                __Internal.FillByIndex(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLFill.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLFill.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Append a new XLFill, based on copyFrom, and return its index in fills node</summary>
            /// <param name="copyFrom">Can provide an XLFill to use as template for the new style</param>
            /// <param name="styleEntriesPrefix">Prefix the newly created cell style XMLNode with this pugi::node_pcdata text</param>
            /// <remarks>The index of the new style as used by operator[]</remarks>
            public ulong Create(global::OpenXLSX.OpenXLSX.XLFill copyFrom, string styleEntriesPrefix)
            {
                if (ReferenceEquals(copyFrom, null))
                    throw new global::System.ArgumentNullException("copyFrom", "Cannot be null because it is passed by value.");
                var __arg0 = copyFrom.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, styleEntriesPrefix);
                var __arg1 = __basicString1.__Instance;
                var ___ret = __Internal.Create(__Instance, __arg0, __arg1);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLFills(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLFills(node);
            }

            public global::OpenXLSX.OpenXLSX.XLFill this[ulong index]
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLFill.__Internal();
                    __Internal.OperatorSubscript(__Instance, new IntPtr(&___ret), index);
                    var _____ret = global::OpenXLSX.OpenXLSX.XLFill.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLFill.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the count of fills</summary>
            /// <returns>The amount of fill entries</returns>
            public ulong Count
            {
                get
                {
                    var ___ret = __Internal.Count(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>An encapsulation of a line item</summary>
        public unsafe partial class XLLine : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_lineNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLLine@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLLine@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLLine@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLLine@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLLine@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?style@XLLine@OpenXLSX@@QEBA?AW4XLLineStyle@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLLineStyle Style(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?color@XLLine@OpenXLSX@@QEBA?AVXLDataBarColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Color(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLLine@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLLine> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLLine>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLLine managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLLine managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLLine __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLLine(native.ToPointer(), skipVTables);
            }

            internal static XLLine __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLLine)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLLine __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLLine(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLLine.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLLine(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLLine(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLLine()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLLine.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLBorder object.</summary>
            /// <param name="node">An XMLNode object with the line XMLNode. If no input is provided, a null node is used.</param>
            public XLLine(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLLine.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLLine(global::OpenXLSX.OpenXLSX.XLLine other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLLine.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Evaluate XLLine as bool</summary>
            /// <returns>true if line is set, false if not</returns>
            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLLine __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLLine(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLLine(node);
            }

            /// <summary>Get the line style</summary>
            /// <returns>An XLLineStyle enum</returns>
            public global::OpenXLSX.OpenXLSX.XLLineStyle Style
            {
                get
                {
                    var ___ret = __Internal.Style(__Instance);
                    return ___ret;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLDataBarColor Color
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLDataBarColor.__Internal();
                    __Internal.Color(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLDataBarColor.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLDataBarColor.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Return a string summary of the line properties</summary>
            /// <returns>string with info about the line object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of a border item</summary>
        public unsafe partial class XLBorder : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_borderNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLBorder@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLBorder@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLBorder@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLBorder@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?right@XLBorder@OpenXLSX@@QEBA?AVXLLine@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Right(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setDiagonalUp@XLBorder@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetDiagonalUp(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setDiagonalDown@XLBorder@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetDiagonalDown(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setOutline@XLBorder@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetOutline(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setLine@XLBorder@OpenXLSX@@QEAA_NW4XLLineType@2@W4XLLineStyle@2@VXLColor@2@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetLine(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLLineType lineType, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, __IntPtr lineColor, double lineTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setLeft@XLBorder@OpenXLSX@@QEAA_NW4XLLineStyle@2@VXLColor@2@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetLeft(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, __IntPtr lineColor, double lineTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRight@XLBorder@OpenXLSX@@QEAA_NW4XLLineStyle@2@VXLColor@2@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetRight(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, __IntPtr lineColor, double lineTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setTop@XLBorder@OpenXLSX@@QEAA_NW4XLLineStyle@2@VXLColor@2@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetTop(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, __IntPtr lineColor, double lineTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setBottom@XLBorder@OpenXLSX@@QEAA_NW4XLLineStyle@2@VXLColor@2@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetBottom(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, __IntPtr lineColor, double lineTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setDiagonal@XLBorder@OpenXLSX@@QEAA_NW4XLLineStyle@2@VXLColor@2@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetDiagonal(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, __IntPtr lineColor, double lineTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setVertical@XLBorder@OpenXLSX@@QEAA_NW4XLLineStyle@2@VXLColor@2@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetVertical(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, __IntPtr lineColor, double lineTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHorizontal@XLBorder@OpenXLSX@@QEAA_NW4XLLineStyle@2@VXLColor@2@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetHorizontal(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, __IntPtr lineColor, double lineTint);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?diagonalUp@XLBorder@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DiagonalUp(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?diagonalDown@XLBorder@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DiagonalDown(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?outline@XLBorder@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Outline(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?left@XLBorder@OpenXLSX@@QEBA?AVXLLine@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Left(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?top@XLBorder@OpenXLSX@@QEBA?AVXLLine@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Top(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?bottom@XLBorder@OpenXLSX@@QEBA?AVXLLine@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Bottom(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?diagonal@XLBorder@OpenXLSX@@QEBA?AVXLLine@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Diagonal(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?vertical@XLBorder@OpenXLSX@@QEBA?AVXLLine@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Vertical(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?horizontal@XLBorder@OpenXLSX@@QEBA?AVXLLine@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Horizontal(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLBorder@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLBorder> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLBorder>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLBorder managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLBorder managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLBorder __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLBorder(native.ToPointer(), skipVTables);
            }

            internal static XLBorder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLBorder)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLBorder __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLBorder(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLBorder.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLBorder(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLBorder(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLBorder()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLBorder.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the border XMLNode. If no input is provided, a null node is used.</param>
            public XLBorder(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLBorder.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLBorder(global::OpenXLSX.OpenXLSX.XLBorder other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLBorder.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the left line property</summary>
            /// <returns>An XLLine object</returns>
            public global::OpenXLSX.OpenXLSX.XLLine Right()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLLine.__Internal();
                __Internal.Right(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLLine.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLLine.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Setter functions for style parameters</summary>
            /// <param name="value">that shall be set</param>
            /// <param name="value2">(optional) that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetDiagonalUp(bool set)
            {
                var ___ret = __Internal.SetDiagonalUp(__Instance, set);
                return ___ret;
            }

            public bool SetDiagonalDown(bool set)
            {
                var ___ret = __Internal.SetDiagonalDown(__Instance, set);
                return ___ret;
            }

            public bool SetOutline(bool set)
            {
                var ___ret = __Internal.SetOutline(__Instance, set);
                return ___ret;
            }

            public bool SetLine(global::OpenXLSX.OpenXLSX.XLLineType lineType, global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, global::OpenXLSX.OpenXLSX.XLColor lineColor, double lineTint)
            {
                if (ReferenceEquals(lineColor, null))
                    throw new global::System.ArgumentNullException("lineColor", "Cannot be null because it is passed by value.");
                var __arg2 = lineColor.__Instance;
                var ___ret = __Internal.SetLine(__Instance, lineType, lineStyle, __arg2, lineTint);
                return ___ret;
            }

            public bool SetLeft(global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, global::OpenXLSX.OpenXLSX.XLColor lineColor, double lineTint)
            {
                if (ReferenceEquals(lineColor, null))
                    throw new global::System.ArgumentNullException("lineColor", "Cannot be null because it is passed by value.");
                var __arg1 = lineColor.__Instance;
                var ___ret = __Internal.SetLeft(__Instance, lineStyle, __arg1, lineTint);
                return ___ret;
            }

            public bool SetRight(global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, global::OpenXLSX.OpenXLSX.XLColor lineColor, double lineTint)
            {
                if (ReferenceEquals(lineColor, null))
                    throw new global::System.ArgumentNullException("lineColor", "Cannot be null because it is passed by value.");
                var __arg1 = lineColor.__Instance;
                var ___ret = __Internal.SetRight(__Instance, lineStyle, __arg1, lineTint);
                return ___ret;
            }

            public bool SetTop(global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, global::OpenXLSX.OpenXLSX.XLColor lineColor, double lineTint)
            {
                if (ReferenceEquals(lineColor, null))
                    throw new global::System.ArgumentNullException("lineColor", "Cannot be null because it is passed by value.");
                var __arg1 = lineColor.__Instance;
                var ___ret = __Internal.SetTop(__Instance, lineStyle, __arg1, lineTint);
                return ___ret;
            }

            public bool SetBottom(global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, global::OpenXLSX.OpenXLSX.XLColor lineColor, double lineTint)
            {
                if (ReferenceEquals(lineColor, null))
                    throw new global::System.ArgumentNullException("lineColor", "Cannot be null because it is passed by value.");
                var __arg1 = lineColor.__Instance;
                var ___ret = __Internal.SetBottom(__Instance, lineStyle, __arg1, lineTint);
                return ___ret;
            }

            public bool SetDiagonal(global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, global::OpenXLSX.OpenXLSX.XLColor lineColor, double lineTint)
            {
                if (ReferenceEquals(lineColor, null))
                    throw new global::System.ArgumentNullException("lineColor", "Cannot be null because it is passed by value.");
                var __arg1 = lineColor.__Instance;
                var ___ret = __Internal.SetDiagonal(__Instance, lineStyle, __arg1, lineTint);
                return ___ret;
            }

            public bool SetVertical(global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, global::OpenXLSX.OpenXLSX.XLColor lineColor, double lineTint)
            {
                if (ReferenceEquals(lineColor, null))
                    throw new global::System.ArgumentNullException("lineColor", "Cannot be null because it is passed by value.");
                var __arg1 = lineColor.__Instance;
                var ___ret = __Internal.SetVertical(__Instance, lineStyle, __arg1, lineTint);
                return ___ret;
            }

            public bool SetHorizontal(global::OpenXLSX.OpenXLSX.XLLineStyle lineStyle, global::OpenXLSX.OpenXLSX.XLColor lineColor, double lineTint)
            {
                if (ReferenceEquals(lineColor, null))
                    throw new global::System.ArgumentNullException("lineColor", "Cannot be null because it is passed by value.");
                var __arg1 = lineColor.__Instance;
                var ___ret = __Internal.SetHorizontal(__Instance, lineStyle, __arg1, lineTint);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLBorder(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLBorder(node);
            }

            /// <summary>Get the diagonal up property</summary>
            /// <param name="value">that shall be set</param>
            /// <param name="value2">(optional) that shall be set</param>
            /// <returns>
            /// <para>true if set, otherwise false</para>
            /// <para>Setter functions for style parameters</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            public bool DiagonalUp
            {
                get
                {
                    var ___ret = __Internal.DiagonalUp(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDiagonalUp(__Instance, value);
                }
            }

            /// <summary>Get the diagonal down property</summary>
            /// <returns>true if set, otherwise false</returns>
            public bool DiagonalDown
            {
                get
                {
                    var ___ret = __Internal.DiagonalDown(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDiagonalDown(__Instance, value);
                }
            }

            /// <summary>Get the outline property</summary>
            /// <returns>true if set, otherwise false</returns>
            public bool Outline
            {
                get
                {
                    var ___ret = __Internal.Outline(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOutline(__Instance, value);
                }
            }

            /// <summary>Get the left line property</summary>
            /// <returns>An XLLine object</returns>
            public global::OpenXLSX.OpenXLSX.XLLine Left
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLLine.__Internal();
                    __Internal.Left(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLLine.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLLine.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the left line property</summary>
            /// <returns>An XLLine object</returns>
            public global::OpenXLSX.OpenXLSX.XLLine Top
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLLine.__Internal();
                    __Internal.Top(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLLine.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLLine.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the bottom line property</summary>
            /// <returns>An XLLine object</returns>
            public global::OpenXLSX.OpenXLSX.XLLine Bottom
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLLine.__Internal();
                    __Internal.Bottom(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLLine.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLLine.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the diagonal line property</summary>
            /// <returns>An XLLine object</returns>
            public global::OpenXLSX.OpenXLSX.XLLine Diagonal
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLLine.__Internal();
                    __Internal.Diagonal(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLLine.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLLine.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the vertical line property</summary>
            /// <returns>An XLLine object</returns>
            public global::OpenXLSX.OpenXLSX.XLLine Vertical
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLLine.__Internal();
                    __Internal.Vertical(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLLine.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLLine.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the horizontal line property</summary>
            /// <returns>An XLLine object</returns>
            public global::OpenXLSX.OpenXLSX.XLLine Horizontal
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLLine.__Internal();
                    __Internal.Horizontal(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLLine.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLLine.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Return a string summary of the font properties</summary>
            /// <returns>string with info about the font object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of the XLSX borders</summary>
        public unsafe partial class XLBorders : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_bordersNode;
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_OpenXLSX_S_XLBorder___N_std_S_allocator__S0_ m_borders;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLBorders@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLBorders@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLBorders@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLBorders@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?borderByIndex@XLBorders@OpenXLSX@@QEBA?AVXLBorder@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void BorderByIndex(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLBorders@OpenXLSX@@QEAA_KVXLBorder@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Create(__IntPtr __instance, __IntPtr copyFrom, __IntPtr styleEntriesPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??AXLBorders@OpenXLSX@@QEBA?AVXLBorder@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorSubscript(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?count@XLBorders@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Count(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLBorders> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLBorders>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLBorders managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLBorders managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLBorders __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLBorders(native.ToPointer(), skipVTables);
            }

            internal static XLBorders __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLBorders)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLBorders __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLBorders(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLBorders.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLBorders(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLBorders(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLBorders()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLBorders.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the borders item. If no input is provided, a null node is used.</param>
            public XLBorders(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLBorders.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLBorders(global::OpenXLSX.OpenXLSX.XLBorders other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLBorders.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the border description identified by index</summary>
            /// <param name="index">The index within the XML sequence</param>
            /// <returns>An XLBorder object</returns>
            public global::OpenXLSX.OpenXLSX.XLBorder BorderByIndex(ulong index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLBorder.__Internal();
                __Internal.BorderByIndex(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLBorder.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLBorder.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Append a new XLBorder, based on copyFrom, and return its index in borders node</summary>
            /// <param name="copyFrom">Can provide an XLBorder to use as template for the new style</param>
            /// <param name="styleEntriesPrefix">Prefix the newly created cell style XMLNode with this pugi::node_pcdata text</param>
            /// <remarks>The index of the new style as used by operator[]</remarks>
            public ulong Create(global::OpenXLSX.OpenXLSX.XLBorder copyFrom, string styleEntriesPrefix)
            {
                if (ReferenceEquals(copyFrom, null))
                    throw new global::System.ArgumentNullException("copyFrom", "Cannot be null because it is passed by value.");
                var __arg0 = copyFrom.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, styleEntriesPrefix);
                var __arg1 = __basicString1.__Instance;
                var ___ret = __Internal.Create(__Instance, __arg0, __arg1);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLBorders(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLBorders(node);
            }

            public global::OpenXLSX.OpenXLSX.XLBorder this[ulong index]
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLBorder.__Internal();
                    __Internal.OperatorSubscript(__Instance, new IntPtr(&___ret), index);
                    var _____ret = global::OpenXLSX.OpenXLSX.XLBorder.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLBorder.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the count of border descriptions</summary>
            /// <returns>The amount of border description entries</returns>
            public ulong Count
            {
                get
                {
                    var ___ret = __Internal.Count(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>An encapsulation of an alignment item</summary>
        public unsafe partial class XLAlignment : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_alignmentNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAlignment@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAlignment@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAlignment@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLAlignment@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHorizontal@XLAlignment@OpenXLSX@@QEAA_NW4XLAlignmentStyle@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetHorizontal(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLAlignmentStyle newStyle);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setVertical@XLAlignment@OpenXLSX@@QEAA_NW4XLAlignmentStyle@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetVertical(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLAlignmentStyle newStyle);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setTextRotation@XLAlignment@OpenXLSX@@QEAA_NG@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetTextRotation(__IntPtr __instance, ushort newRotation);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setWrapText@XLAlignment@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetWrapText(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setIndent@XLAlignment@OpenXLSX@@QEAA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetIndent(__IntPtr __instance, uint newIndent);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRelativeIndent@XLAlignment@OpenXLSX@@QEAA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetRelativeIndent(__IntPtr __instance, int newIndent);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setJustifyLastLine@XLAlignment@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetJustifyLastLine(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setShrinkToFit@XLAlignment@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetShrinkToFit(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setReadingOrder@XLAlignment@OpenXLSX@@QEAA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetReadingOrder(__IntPtr __instance, uint newReadingOrder);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?horizontal@XLAlignment@OpenXLSX@@QEBA?AW4XLAlignmentStyle@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLAlignmentStyle Horizontal(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?vertical@XLAlignment@OpenXLSX@@QEBA?AW4XLAlignmentStyle@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLAlignmentStyle Vertical(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?textRotation@XLAlignment@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort TextRotation(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?wrapText@XLAlignment@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool WrapText(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?indent@XLAlignment@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint Indent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?relativeIndent@XLAlignment@OpenXLSX@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int RelativeIndent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?justifyLastLine@XLAlignment@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool JustifyLastLine(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?shrinkToFit@XLAlignment@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ShrinkToFit(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?readingOrder@XLAlignment@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint ReadingOrder(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLAlignment@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLAlignment> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLAlignment>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLAlignment managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLAlignment managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLAlignment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLAlignment(native.ToPointer(), skipVTables);
            }

            internal static XLAlignment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLAlignment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLAlignment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLAlignment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLAlignment.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLAlignment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLAlignment(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLAlignment()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAlignment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLBorder object.</summary>
            /// <param name="node">An XMLNode object with the alignment XMLNode. If no input is provided, a null node is used.</param>
            public XLAlignment(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAlignment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLAlignment(global::OpenXLSX.OpenXLSX.XLAlignment other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAlignment.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Setter functions for style parameters</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetHorizontal(global::OpenXLSX.OpenXLSX.XLAlignmentStyle newStyle)
            {
                var ___ret = __Internal.SetHorizontal(__Instance, newStyle);
                return ___ret;
            }

            public bool SetVertical(global::OpenXLSX.OpenXLSX.XLAlignmentStyle newStyle)
            {
                var ___ret = __Internal.SetVertical(__Instance, newStyle);
                return ___ret;
            }

            /// <remarks>
            /// <para>on setTextRotation from XLSX specification:</para>
            /// <para>Text rotation in cells. Expressed in degrees. Values range from 0 to 180. The first letter of the text</para>
            /// <para>is considered the center-point of the arc.</para>
            /// <para>For 0 - 90, the value represents degrees above horizon. For 91-180 the degrees below the horizon is calculated as:</para>
            /// <para>[degrees below horizon] = 90 - [newRotation].</para>
            /// <para>Examples: setTextRotation( 45): / (text is formatted along a line from lower left to upper right)</para>
            /// <para>setTextRotation(135):\(text is formatted along a line from upper left to lower right)</para>
            /// </remarks>
            public bool SetTextRotation(ushort newRotation)
            {
                var ___ret = __Internal.SetTextRotation(__Instance, newRotation);
                return ___ret;
            }

            public bool SetWrapText(bool set)
            {
                var ___ret = __Internal.SetWrapText(__Instance, set);
                return ___ret;
            }

            public bool SetIndent(uint newIndent)
            {
                var ___ret = __Internal.SetIndent(__Instance, newIndent);
                return ___ret;
            }

            public bool SetRelativeIndent(int newIndent)
            {
                var ___ret = __Internal.SetRelativeIndent(__Instance, newIndent);
                return ___ret;
            }

            public bool SetJustifyLastLine(bool set)
            {
                var ___ret = __Internal.SetJustifyLastLine(__Instance, set);
                return ___ret;
            }

            public bool SetShrinkToFit(bool set)
            {
                var ___ret = __Internal.SetShrinkToFit(__Instance, set);
                return ___ret;
            }

            public bool SetReadingOrder(uint newReadingOrder)
            {
                var ___ret = __Internal.SetReadingOrder(__Instance, newReadingOrder);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLAlignment(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLAlignment(node);
            }

            /// <summary>Get the horizontal alignment</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>
            /// <para>An XLAlignmentStyle</para>
            /// <para>Setter functions for style parameters</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            public global::OpenXLSX.OpenXLSX.XLAlignmentStyle Horizontal
            {
                get
                {
                    var ___ret = __Internal.Horizontal(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHorizontal(__Instance, value);
                }
            }

            /// <summary>Get the vertical alignment</summary>
            /// <returns>An XLAlignmentStyle</returns>
            public global::OpenXLSX.OpenXLSX.XLAlignmentStyle Vertical
            {
                get
                {
                    var ___ret = __Internal.Vertical(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetVertical(__Instance, value);
                }
            }

            /// <summary>Get the text rotation</summary>
            /// <returns>A value in degrees (TBD: clockwise? counter-clockwise?)</returns>
            /// <remarks>
            /// <para>on setTextRotation from XLSX specification:</para>
            /// <para>Text rotation in cells. Expressed in degrees. Values range from 0 to 180. The first letter of the text</para>
            /// <para>is considered the center-point of the arc.</para>
            /// <para>For 0 - 90, the value represents degrees above horizon. For 91-180 the degrees below the horizon is calculated as:</para>
            /// <para>[degrees below horizon] = 90 - [newRotation].</para>
            /// <para>Examples: setTextRotation( 45): / (text is formatted along a line from lower left to upper right)</para>
            /// <para>setTextRotation(135):\(text is formatted along a line from upper left to lower right)</para>
            /// </remarks>
            public ushort TextRotation
            {
                get
                {
                    var ___ret = __Internal.TextRotation(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetTextRotation(__Instance, value);
                }
            }

            /// <summary>Check whether text wrapping is enabled</summary>
            /// <returns>true if enabled, false otherwise</returns>
            public bool WrapText
            {
                get
                {
                    var ___ret = __Internal.WrapText(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWrapText(__Instance, value);
                }
            }

            /// <summary>Get the indent setting</summary>
            /// <returns>An integer value, where an increment of 1 represents 3 spaces.</returns>
            public uint Indent
            {
                get
                {
                    var ___ret = __Internal.Indent(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIndent(__Instance, value);
                }
            }

            /// <summary>Get the relative indent setting</summary>
            /// <returns>An integer value, where an increment of 1 represents 1 space, in addition to indent()*3 spaces</returns>
            /// <remarks>can be negative</remarks>
            public int RelativeIndent
            {
                get
                {
                    var ___ret = __Internal.RelativeIndent(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRelativeIndent(__Instance, value);
                }
            }

            /// <summary>Check whether justification of last line is enabled</summary>
            /// <returns>true if enabled, false otherwise</returns>
            public bool JustifyLastLine
            {
                get
                {
                    var ___ret = __Internal.JustifyLastLine(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetJustifyLastLine(__Instance, value);
                }
            }

            /// <summary>Check whether shrink to fit is enabled</summary>
            /// <returns>true if enabled, false otherwise</returns>
            public bool ShrinkToFit
            {
                get
                {
                    var ___ret = __Internal.ShrinkToFit(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetShrinkToFit(__Instance, value);
                }
            }

            /// <summary>Get the reading order setting</summary>
            /// <returns>An integer value: 0 - Context Dependent, 1 - Left-to-Right, 2 - Right-to-Left (any other value should be invalid)</returns>
            public uint ReadingOrder
            {
                get
                {
                    var ___ret = __Internal.ReadingOrder(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetReadingOrder(__Instance, value);
                }
            }

            /// <summary>Return a string summary of the alignment properties</summary>
            /// <returns>string with info about the alignment object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of a cell format item</summary>
        public unsafe partial class XLCellFormat : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_cellFormatNode;
                internal byte m_permitXfId;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellFormat@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellFormat@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node, bool permitXfId);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellFormat@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellFormat@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?alignment@XLCellFormat@OpenXLSX@@QEBA?AVXLAlignment@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Alignment(__IntPtr __instance, __IntPtr @return, bool createIfMissing);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setNumberFormatId@XLCellFormat@OpenXLSX@@QEAA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetNumberFormatId(__IntPtr __instance, uint newNumFmtId);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFontIndex@XLCellFormat@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFontIndex(__IntPtr __instance, ulong newFontIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFillIndex@XLCellFormat@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFillIndex(__IntPtr __instance, ulong newFillIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setBorderIndex@XLCellFormat@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetBorderIndex(__IntPtr __instance, ulong newBorderIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setXfId@XLCellFormat@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetXfId(__IntPtr __instance, ulong newXfId);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setApplyNumberFormat@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetApplyNumberFormat(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setApplyFont@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetApplyFont(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setApplyFill@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetApplyFill(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setApplyBorder@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetApplyBorder(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setApplyAlignment@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetApplyAlignment(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setApplyProtection@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetApplyProtection(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setQuotePrefix@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetQuotePrefix(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setPivotButton@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetPivotButton(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setLocked@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetLocked(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHidden@XLCellFormat@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetHidden(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setExtLst@XLCellFormat@OpenXLSX@@QEAA_NAEBVXLUnsupportedElement@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetExtLst(__IntPtr __instance, __IntPtr newExtLst);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numberFormatId@XLCellFormat@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint NumberFormatId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fontIndex@XLCellFormat@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong FontIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fillIndex@XLCellFormat@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong FillIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?borderIndex@XLCellFormat@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong BorderIndex(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?xfId@XLCellFormat@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong XfId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?applyNumberFormat@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ApplyNumberFormat(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?applyFont@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ApplyFont(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?applyFill@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ApplyFill(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?applyBorder@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ApplyBorder(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?applyAlignment@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ApplyAlignment(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?applyProtection@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ApplyProtection(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?quotePrefix@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool QuotePrefix(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?pivotButton@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool PivotButton(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?locked@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Locked(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hidden@XLCellFormat@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Hidden(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?extLst@XLCellFormat@OpenXLSX@@QEBA?AVXLUnsupportedElement@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ExtLst(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLCellFormat@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellFormat> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellFormat>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellFormat managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellFormat managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellFormat(native.ToPointer(), skipVTables);
            }

            internal static XLCellFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellFormat)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellFormat __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellFormat(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellFormat.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellFormat(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellFormat(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLCellFormat()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellFormat.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the xf XMLNode. If no input is provided, a null node is used.</param>
            /// <param name="permitXfId">true (XLPermitXfID) -&gt; getter xfId and setter setXfId are enabled, otherwise will throw XLException if invoked</param>
            public XLCellFormat(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node, bool permitXfId)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellFormat.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0, permitXfId);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLCellFormat(global::OpenXLSX.OpenXLSX.XLCellFormat other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellFormat.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Return a reference to applicable alignment</summary>
            /// <param name="createIfMissing">triggers creation of alignment node - should be used with setter functions of XLAlignment</param>
            /// <returns>An XLAlignment object reference</returns>
            public global::OpenXLSX.OpenXLSX.XLAlignment Alignment(bool createIfMissing)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLAlignment.__Internal();
                __Internal.Alignment(__Instance, new IntPtr(&___ret), createIfMissing);
                var _____ret = global::OpenXLSX.OpenXLSX.XLAlignment.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLAlignment.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Setter functions for style parameters</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetNumberFormatId(uint newNumFmtId)
            {
                var ___ret = __Internal.SetNumberFormatId(__Instance, newNumFmtId);
                return ___ret;
            }

            public bool SetFontIndex(ulong newFontIndex)
            {
                var ___ret = __Internal.SetFontIndex(__Instance, newFontIndex);
                return ___ret;
            }

            public bool SetFillIndex(ulong newFillIndex)
            {
                var ___ret = __Internal.SetFillIndex(__Instance, newFillIndex);
                return ___ret;
            }

            public bool SetBorderIndex(ulong newBorderIndex)
            {
                var ___ret = __Internal.SetBorderIndex(__Instance, newBorderIndex);
                return ___ret;
            }

            public bool SetXfId(ulong newXfId)
            {
                var ___ret = __Internal.SetXfId(__Instance, newXfId);
                return ___ret;
            }

            public bool SetApplyNumberFormat(bool set)
            {
                var ___ret = __Internal.SetApplyNumberFormat(__Instance, set);
                return ___ret;
            }

            public bool SetApplyFont(bool set)
            {
                var ___ret = __Internal.SetApplyFont(__Instance, set);
                return ___ret;
            }

            public bool SetApplyFill(bool set)
            {
                var ___ret = __Internal.SetApplyFill(__Instance, set);
                return ___ret;
            }

            public bool SetApplyBorder(bool set)
            {
                var ___ret = __Internal.SetApplyBorder(__Instance, set);
                return ___ret;
            }

            public bool SetApplyAlignment(bool set)
            {
                var ___ret = __Internal.SetApplyAlignment(__Instance, set);
                return ___ret;
            }

            public bool SetApplyProtection(bool set)
            {
                var ___ret = __Internal.SetApplyProtection(__Instance, set);
                return ___ret;
            }

            public bool SetQuotePrefix(bool set)
            {
                var ___ret = __Internal.SetQuotePrefix(__Instance, set);
                return ___ret;
            }

            public bool SetPivotButton(bool set)
            {
                var ___ret = __Internal.SetPivotButton(__Instance, set);
                return ___ret;
            }

            public bool SetLocked(bool set)
            {
                var ___ret = __Internal.SetLocked(__Instance, set);
                return ___ret;
            }

            public bool SetHidden(bool set)
            {
                var ___ret = __Internal.SetHidden(__Instance, set);
                return ___ret;
            }

            /// <summary>Unsupported setter</summary>
            public bool SetExtLst(global::OpenXLSX.OpenXLSX.XLUnsupportedElement newExtLst)
            {
                if (ReferenceEquals(newExtLst, null))
                    throw new global::System.ArgumentNullException("newExtLst", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = newExtLst.__Instance;
                var ___ret = __Internal.SetExtLst(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>Get the number format id</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>
            /// <para>The identifier of a number format, built-in (predefined by office) or defind in XLNumberFormats</para>
            /// <para>Setter functions for style parameters</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            public uint NumberFormatId
            {
                get
                {
                    var ___ret = __Internal.NumberFormatId(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetNumberFormatId(__Instance, value);
                }
            }

            /// <summary>Get the font index</summary>
            /// <returns>The index(!) of a font as defined in XLFonts</returns>
            public ulong FontIndex
            {
                get
                {
                    var ___ret = __Internal.FontIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFontIndex(__Instance, value);
                }
            }

            /// <summary>Get the fill index</summary>
            /// <returns>The index(!) of a fill as defined in XLFills</returns>
            public ulong FillIndex
            {
                get
                {
                    var ___ret = __Internal.FillIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFillIndex(__Instance, value);
                }
            }

            /// <summary>Get the border index</summary>
            /// <returns>The index(!) of a border as defined in XLBorders</returns>
            public ulong BorderIndex
            {
                get
                {
                    var ___ret = __Internal.BorderIndex(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBorderIndex(__Instance, value);
                }
            }

            /// <summary>Get the id of a referred&gt; entry</summary>
            /// <returns>The id referring to an index in cell style formats (cellStyleXfs)</returns>
            /// <remarks>
            /// <para>XLException when invoked from cellStyleFormats</para>
            /// <para>- only permitted for cellFormats</para>
            /// </remarks>
            public ulong XfId
            {
                get
                {
                    var ___ret = __Internal.XfId(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetXfId(__Instance, value);
                }
            }

            /// <summary>Report whether number format is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            public bool ApplyNumberFormat
            {
                get
                {
                    var ___ret = __Internal.ApplyNumberFormat(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetApplyNumberFormat(__Instance, value);
                }
            }

            /// <summary>Report whether font is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            public bool ApplyFont
            {
                get
                {
                    var ___ret = __Internal.ApplyFont(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetApplyFont(__Instance, value);
                }
            }

            /// <summary>Report whether fill is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            public bool ApplyFill
            {
                get
                {
                    var ___ret = __Internal.ApplyFill(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetApplyFill(__Instance, value);
                }
            }

            /// <summary>Report whether border is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            public bool ApplyBorder
            {
                get
                {
                    var ___ret = __Internal.ApplyBorder(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetApplyBorder(__Instance, value);
                }
            }

            /// <summary>Report whether alignment is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            public bool ApplyAlignment
            {
                get
                {
                    var ___ret = __Internal.ApplyAlignment(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetApplyAlignment(__Instance, value);
                }
            }

            /// <summary>Report whether protection is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            public bool ApplyProtection
            {
                get
                {
                    var ___ret = __Internal.ApplyProtection(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetApplyProtection(__Instance, value);
                }
            }

            /// <summary>Report whether quotePrefix is enabled</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            /// <remarks>
            /// <para>from documentation: A boolean value indicating whether the text string in a cell should be prefixed by a single quote mark</para>
            /// <para>(e.g., 'text). In these cases, the quote is not stored in the Shared Strings Part.</para>
            /// </remarks>
            public bool QuotePrefix
            {
                get
                {
                    var ___ret = __Internal.QuotePrefix(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetQuotePrefix(__Instance, value);
                }
            }

            /// <summary>Report whether pivot button is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            /// <remarks>
            /// <para>from documentation: A boolean value indicating whether the cell rendering includes a pivot table dropdown button.</para>
            /// <para>need to find a use case for this</para>
            /// </remarks>
            public bool PivotButton
            {
                get
                {
                    var ___ret = __Internal.PivotButton(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetPivotButton(__Instance, value);
                }
            }

            /// <summary>Report whether protection locked is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            public bool Locked
            {
                get
                {
                    var ___ret = __Internal.Locked(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetLocked(__Instance, value);
                }
            }

            /// <summary>Report whether protection hidden is applied</summary>
            /// <returns>true for a setting enabled, or false if disabled</returns>
            public bool Hidden
            {
                get
                {
                    var ___ret = __Internal.Hidden(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHidden(__Instance, value);
                }
            }

            /// <summary>Unsupported getter</summary>
            /// <remarks>Unsupported setter</remarks>
            public global::OpenXLSX.OpenXLSX.XLUnsupportedElement ExtLst
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLUnsupportedElement.__Internal();
                    __Internal.ExtLst(__Instance, new IntPtr(&___ret));
                    return global::OpenXLSX.OpenXLSX.XLUnsupportedElement.__CreateInstance(___ret);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetExtLst(__Instance, __arg0);
                }
            }

            /// <summary>Return a string summary of the cell format properties</summary>
            /// <returns>string with info about the cell format object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of the XLSX cell style formats</summary>
        public unsafe partial class XLCellFormats : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_cellFormatsNode;
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_OpenXLSX_S_XLCellFormat___N_std_S_allocator__S0_ m_cellFormats;
                internal byte m_permitXfId;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellFormats@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellFormats@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node, bool permitXfId);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellFormats@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellFormats@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellFormatByIndex@XLCellFormats@OpenXLSX@@QEBA?AVXLCellFormat@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CellFormatByIndex(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLCellFormats@OpenXLSX@@QEAA_KVXLCellFormat@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Create(__IntPtr __instance, __IntPtr copyFrom, __IntPtr styleEntriesPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??AXLCellFormats@OpenXLSX@@QEBA?AVXLCellFormat@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorSubscript(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?count@XLCellFormats@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Count(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellFormats> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellFormats>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellFormats managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellFormats managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellFormats __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellFormats(native.ToPointer(), skipVTables);
            }

            internal static XLCellFormats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellFormats)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellFormats __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellFormats(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellFormats.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellFormats(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellFormats(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLCellFormats()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellFormats.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the cell formats (cellXfs or cellStyleXfs) item. If no input is provided, a null node is used.</param>
            /// <param name="permitXfId">Pass-through to XLCellFormat constructor: true (XLPermitXfID) -&gt; setter setXfId is enabled, otherwise throws</param>
            public XLCellFormats(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node, bool permitXfId)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellFormats.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0, permitXfId);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLCellFormats(global::OpenXLSX.OpenXLSX.XLCellFormats other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellFormats.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the cell style format description identified by index</summary>
            /// <param name="index">The index within the XML sequence</param>
            /// <returns>An XLCellFormat object</returns>
            public global::OpenXLSX.OpenXLSX.XLCellFormat CellFormatByIndex(ulong index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellFormat.__Internal();
                __Internal.CellFormatByIndex(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellFormat.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellFormat.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>
            /// <para>Append a new XLCellFormat, based on copyFrom, and return its index</para>
            /// <para>in cellXfs (for XLStyles::cellFormats) or cellStyleXfs (for XLStyles::cellStyleFormats)</para>
            /// </summary>
            /// <param name="copyFrom">Can provide an XLCellFormat to use as template for the new style</param>
            /// <param name="styleEntriesPrefix">Prefix the newly created cell style XMLNode with this pugi::node_pcdata text</param>
            /// <remarks>The index of the new style as used by operator[]</remarks>
            public ulong Create(global::OpenXLSX.OpenXLSX.XLCellFormat copyFrom, string styleEntriesPrefix)
            {
                if (ReferenceEquals(copyFrom, null))
                    throw new global::System.ArgumentNullException("copyFrom", "Cannot be null because it is passed by value.");
                var __arg0 = copyFrom.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, styleEntriesPrefix);
                var __arg1 = __basicString1.__Instance;
                var ___ret = __Internal.Create(__Instance, __arg0, __arg1);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.XLCellFormat this[ulong index]
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLCellFormat.__Internal();
                    __Internal.OperatorSubscript(__Instance, new IntPtr(&___ret), index);
                    var _____ret = global::OpenXLSX.OpenXLSX.XLCellFormat.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLCellFormat.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the count of cell style format descriptions</summary>
            /// <returns>The amount of cell style format description entries</returns>
            public ulong Count
            {
                get
                {
                    var ___ret = __Internal.Count(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>An encapsulation of a cell style item</summary>
        public unsafe partial class XLCellStyle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_cellStyleNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellStyle@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellStyle@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellStyle@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellStyle@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setName@XLCellStyle@OpenXLSX@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetName(__IntPtr __instance, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setXfId@XLCellStyle@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetXfId(__IntPtr __instance, ulong newXfId);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setBuiltinId@XLCellStyle@OpenXLSX@@QEAA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetBuiltinId(__IntPtr __instance, uint newBuiltinId);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setOutlineStyle@XLCellStyle@OpenXLSX@@QEAA_NI@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetOutlineStyle(__IntPtr __instance, uint newOutlineStyle);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHidden@XLCellStyle@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetHidden(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setCustomBuiltin@XLCellStyle@OpenXLSX@@QEAA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetCustomBuiltin(__IntPtr __instance, bool set);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setExtLst@XLCellStyle@OpenXLSX@@QEAA_NAEBVXLUnsupportedElement@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetExtLst(__IntPtr __instance, __IntPtr newExtLst);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?empty@XLCellStyle@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Empty(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name@XLCellStyle@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Name(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?xfId@XLCellStyle@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong XfId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?builtinId@XLCellStyle@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint BuiltinId(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?outlineStyle@XLCellStyle@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint OutlineStyle(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hidden@XLCellStyle@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Hidden(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?customBuiltin@XLCellStyle@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool CustomBuiltin(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?extLst@XLCellStyle@OpenXLSX@@QEBA?AVXLUnsupportedElement@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ExtLst(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?summary@XLCellStyle@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Summary(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellStyle> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellStyle>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellStyle managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellStyle managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellStyle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellStyle(native.ToPointer(), skipVTables);
            }

            internal static XLCellStyle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellStyle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellStyle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellStyle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellStyle.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellStyle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellStyle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLCellStyle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellStyle.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the cellStyle item. If no input is provided, a null node is used.</param>
            public XLCellStyle(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellStyle.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLCellStyle(global::OpenXLSX.OpenXLSX.XLCellStyle other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellStyle.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Setter functions for style parameters</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>true for success, false for failure</returns>
            public bool SetName(string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, newName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SetName(__Instance, __arg0);
                __basicString0.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public bool SetXfId(ulong newXfId)
            {
                var ___ret = __Internal.SetXfId(__Instance, newXfId);
                return ___ret;
            }

            public bool SetBuiltinId(uint newBuiltinId)
            {
                var ___ret = __Internal.SetBuiltinId(__Instance, newBuiltinId);
                return ___ret;
            }

            public bool SetOutlineStyle(uint newOutlineStyle)
            {
                var ___ret = __Internal.SetOutlineStyle(__Instance, newOutlineStyle);
                return ___ret;
            }

            public bool SetHidden(bool set)
            {
                var ___ret = __Internal.SetHidden(__Instance, set);
                return ___ret;
            }

            public bool SetCustomBuiltin(bool set)
            {
                var ___ret = __Internal.SetCustomBuiltin(__Instance, set);
                return ___ret;
            }

            /// <summary>Unsupported setter</summary>
            public bool SetExtLst(global::OpenXLSX.OpenXLSX.XLUnsupportedElement newExtLst)
            {
                if (ReferenceEquals(newExtLst, null))
                    throw new global::System.ArgumentNullException("newExtLst", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = newExtLst.__Instance;
                var ___ret = __Internal.SetExtLst(__Instance, __arg0);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLCellStyle(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLCellStyle(node);
            }

            /// <summary>Test if this is an empty node</summary>
            /// <returns>true if underlying XMLNode is empty</returns>
            public bool Empty
            {
                get
                {
                    var ___ret = __Internal.Empty(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the name of the cell style</summary>
            /// <param name="value">that shall be set</param>
            /// <returns>
            /// <para>The name for this cell style entry</para>
            /// <para>Setter functions for style parameters</para>
            /// </returns>
            /// <returns>true for success, false for failure</returns>
            public string Name
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Name(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetName(__Instance, __arg0);
                    __basicString0.Dispose(disposing: true, callNativeDtor:false);
                }
            }

            /// <summary>Get the id of the cell style format</summary>
            /// <returns>The id referring to an index in cell style formats (cellStyleXfs) - TBD to be confirmed</returns>
            public ulong XfId
            {
                get
                {
                    var ___ret = __Internal.XfId(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetXfId(__Instance, value);
                }
            }

            /// <summary>Get the built-in id of the cell style</summary>
            /// <returns>The built-in id of the cell style</returns>
            /// <remarks>need to find a use case for this</remarks>
            public uint BuiltinId
            {
                get
                {
                    var ___ret = __Internal.BuiltinId(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBuiltinId(__Instance, value);
                }
            }

            /// <summary>Get the outline style id (attribute iLevel) of the cell style</summary>
            /// <returns>The outline style id of the cell style</returns>
            /// <remarks>need to find a use case for this</remarks>
            public uint OutlineStyle
            {
                get
                {
                    var ___ret = __Internal.OutlineStyle(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetOutlineStyle(__Instance, value);
                }
            }

            /// <summary>Get the hidden flag of the cell style</summary>
            /// <returns>The hidden flag status (true: applications should not show this style)</returns>
            public bool Hidden
            {
                get
                {
                    var ___ret = __Internal.Hidden(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHidden(__Instance, value);
                }
            }

            /// <summary>Get the custom buildin flag</summary>
            /// <returns>true if this cell style shall customize a built-in style</returns>
            public bool CustomBuiltin
            {
                get
                {
                    var ___ret = __Internal.CustomBuiltin(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetCustomBuiltin(__Instance, value);
                }
            }

            /// <summary>Unsupported getter</summary>
            /// <remarks>Unsupported setter</remarks>
            public global::OpenXLSX.OpenXLSX.XLUnsupportedElement ExtLst
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLUnsupportedElement.__Internal();
                    __Internal.ExtLst(__Instance, new IntPtr(&___ret));
                    return global::OpenXLSX.OpenXLSX.XLUnsupportedElement.__CreateInstance(___ret);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetExtLst(__Instance, __arg0);
                }
            }

            /// <summary>Return a string summary of the cell style properties</summary>
            /// <returns>string with info about the cell style object</returns>
            public string Summary
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Summary(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of the XLSX cell styles</summary>
        public unsafe partial class XLCellStyles : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_cellStylesNode;
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_OpenXLSX_S_XLCellStyle___N_std_S_allocator__S0_ m_cellStyles;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellStyles@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellStyles@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellStyles@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellStyles@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellStyleByIndex@XLCellStyles@OpenXLSX@@QEBA?AVXLCellStyle@2@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CellStyleByIndex(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLCellStyles@OpenXLSX@@QEAA_KVXLCellStyle@2@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Create(__IntPtr __instance, __IntPtr copyFrom, __IntPtr styleEntriesPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??AXLCellStyles@OpenXLSX@@QEBA?AVXLCellStyle@1@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorSubscript(__IntPtr __instance, __IntPtr @return, ulong index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?count@XLCellStyles@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Count(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellStyles> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellStyles>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellStyles managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellStyles managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellStyles __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellStyles(native.ToPointer(), skipVTables);
            }

            internal static XLCellStyles __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellStyles)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellStyles __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellStyles(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellStyles.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellStyles(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellStyles(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLCellStyles()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellStyles.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLStyles object.</summary>
            /// <param name="node">An XMLNode object with the cellStyles item. If no input is provided, a null node is used.</param>
            public XLCellStyles(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellStyles.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLCellStyles(global::OpenXLSX.OpenXLSX.XLCellStyles other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellStyles.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the cell style identified by index</summary>
            /// <returns>An XLCellStyle object</returns>
            public global::OpenXLSX.OpenXLSX.XLCellStyle CellStyleByIndex(ulong index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellStyle.__Internal();
                __Internal.CellStyleByIndex(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellStyle.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellStyle.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Append a new XLCellStyle, based on copyFrom, and return its index in cellStyles node</summary>
            /// <param name="copyFrom">Can provide an XLCellStyle to use as template for the new style</param>
            /// <param name="styleEntriesPrefix">Prefix the newly created cell style XMLNode with this pugi::node_pcdata text</param>
            /// <remarks>The index of the new style as used by operator[]</remarks>
            public ulong Create(global::OpenXLSX.OpenXLSX.XLCellStyle copyFrom, string styleEntriesPrefix)
            {
                if (ReferenceEquals(copyFrom, null))
                    throw new global::System.ArgumentNullException("copyFrom", "Cannot be null because it is passed by value.");
                var __arg0 = copyFrom.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, styleEntriesPrefix);
                var __arg1 = __basicString1.__Instance;
                var ___ret = __Internal.Create(__Instance, __arg0, __arg1);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLCellStyles(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLCellStyles(node);
            }

            public global::OpenXLSX.OpenXLSX.XLCellStyle this[ulong index]
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLCellStyle.__Internal();
                    __Internal.OperatorSubscript(__Instance, new IntPtr(&___ret), index);
                    var _____ret = global::OpenXLSX.OpenXLSX.XLCellStyle.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLCellStyle.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the count of cell styles</summary>
            /// <returns>The amount of entries in the cell styles</returns>
            public ulong Count
            {
                get
                {
                    var ___ret = __Internal.Count(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>An encapsulation of the styles file (xl/styles.xml) in an Excel document package.</summary>
        public unsafe partial class XLStyles : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;
                internal byte m_suppressWarnings;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLNumberFormats___N_std_S_default_delete__S0_ m_numberFormats;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLFonts___N_std_S_default_delete__S0_ m_fonts;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLFills___N_std_S_default_delete__S0_ m_fills;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLBorders___N_std_S_default_delete__S0_ m_borders;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLCellFormats___N_std_S_default_delete__S0_ m_cellStyleFormats;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLCellFormats___N_std_S_default_delete__S0_ m_cellFormats;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLCellStyles___N_std_S_default_delete__S0_ m_cellStyles;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLStyles@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLStyles@OpenXLSX@@QEAA@PEAVXLXmlData@1@_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData, bool suppressWarnings, __IntPtr stylesPrefix);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLStyles@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numberFormats@XLStyles@OpenXLSX@@QEBAAEAVXLNumberFormats@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr NumberFormats(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fonts@XLStyles@OpenXLSX@@QEBAAEAVXLFonts@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Fonts(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fills@XLStyles@OpenXLSX@@QEBAAEAVXLFills@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Fills(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?borders@XLStyles@OpenXLSX@@QEBAAEAVXLBorders@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Borders(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellStyleFormats@XLStyles@OpenXLSX@@QEBAAEAVXLCellFormats@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr CellStyleFormats(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellFormats@XLStyles@OpenXLSX@@QEBAAEAVXLCellFormats@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr CellFormats(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellStyles@XLStyles@OpenXLSX@@QEBAAEAVXLCellStyles@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr CellStyles(__IntPtr __instance);
            }

            internal static new XLStyles __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLStyles(native.ToPointer(), skipVTables);
            }

            internal static new XLStyles __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLStyles)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLStyles __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLStyles(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLStyles(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLStyles(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLStyles()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLStyles.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <param name="suppressWarnings">if true (SUPRESS_WARNINGS), messages such as &quot;XLStyles: Ignoring currently unsupported &lt;dxfs&gt; node&quot; will be silenced</param>
            /// <param name="stylesPrefix">Prefix any newly created root style nodes with this text as pugi::node_pcdata</param>
            public XLStyles(global::OpenXLSX.OpenXLSX.XLXmlData xmlData, bool suppressWarnings, string stylesPrefix)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLStyles.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString2, stylesPrefix);
                var __arg2 = __basicString2.__Instance;
                __Internal.ctor(__Instance, __arg0, suppressWarnings, __arg2);
                __basicString2.Dispose(disposing: true, callNativeDtor:false);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the number formats object</summary>
            /// <returns>An XLNumberFormats object</returns>
            public global::OpenXLSX.OpenXLSX.XLNumberFormats NumberFormats
            {
                get
                {
                    var ___ret = __Internal.NumberFormats(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLNumberFormats.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the fonts object</summary>
            /// <returns>An XLFonts object</returns>
            public global::OpenXLSX.OpenXLSX.XLFonts Fonts
            {
                get
                {
                    var ___ret = __Internal.Fonts(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLFonts.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the fills object</summary>
            /// <returns>An XLFills object</returns>
            public global::OpenXLSX.OpenXLSX.XLFills Fills
            {
                get
                {
                    var ___ret = __Internal.Fills(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLFills.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the borders object</summary>
            /// <returns>An XLBorders object</returns>
            public global::OpenXLSX.OpenXLSX.XLBorders Borders
            {
                get
                {
                    var ___ret = __Internal.Borders(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLBorders.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the cell style formats object</summary>
            /// <returns>An XLCellFormats object</returns>
            public global::OpenXLSX.OpenXLSX.XLCellFormats CellStyleFormats
            {
                get
                {
                    var ___ret = __Internal.CellStyleFormats(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellFormats.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the cell formats object</summary>
            /// <returns>An XLCellFormats object</returns>
            public global::OpenXLSX.OpenXLSX.XLCellFormats CellFormats
            {
                get
                {
                    var ___ret = __Internal.CellFormats(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellFormats.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the cell styles object</summary>
            /// <returns>An XLCellStyles object</returns>
            public global::OpenXLSX.OpenXLSX.XLCellStyles CellStyles
            {
                get
                {
                    var ___ret = __Internal.CellStyles(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellStyles.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class XLStyles
        {
            public partial struct __Internal
            {
            }

            public const string XLDefaultStyleEntriesPrefix = "\n\t\t";
            public const string XLDefaultStylesPrefix = "\n\t";
            public const uint XLInvalidUInt16 = 65535;
            public const uint XLInvalidUInt32 = 4294967295;
            public const bool XLPermitXfID = true;
            public const bool XLCreateIfMissing = true;
            public const bool XLDoNotCreate = false;
            public const bool XLForceFillType = true;
            public const ulong XLDefaultCellFormat = 0;
            public const ulong XLInvalidStyleIndex = XLInvalidUInt32;
            public const uint XLDefaultFontSize = 12;
            public const string XLDefaultFontColor = "ff000000";
            public const string XLDefaultFontColorTheme = "";
            public const string XLDefaultFontName = "Arial";
            public const uint XLDefaultFontFamily = 0;
            public const uint XLDefaultFontCharset = 1;
            public const string XLDefaultLineStyle = "";
            public static global::OpenXLSX.OpenXLSX.XLFillType XLDefaultFillType { get; } = (global::OpenXLSX.OpenXLSX.XLFillType) 1;

            public static global::OpenXLSX.OpenXLSX.XLPatternType XLDefaultPatternType { get; } = (global::OpenXLSX.OpenXLSX.XLPatternType) 0;

            public const string XLDefaultPatternFgColor = "ffffffff";
            public const string XLDefaultPatternBgColor = "ff000000";        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLColor : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 4)]
            public partial struct __Internal
            {
                internal byte m_alpha;
                internal byte m_red;
                internal byte m_green;
                internal byte m_blue;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@EEEE@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, byte alpha, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@EEE@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr hexCode);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLColor@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set@XLColor@OpenXLSX@@QEAAXEEEE@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Set(__IntPtr __instance, byte alpha, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set@XLColor@OpenXLSX@@QEAAXEEE@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Set(__IntPtr __instance, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set@XLColor@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Set(__IntPtr __instance, __IntPtr hexCode);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLColor@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLColor@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?alpha@XLColor@OpenXLSX@@QEBAEXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte Alpha(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?red@XLColor@OpenXLSX@@QEBAEXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte Red(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?green@XLColor@OpenXLSX@@QEBAEXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte Green(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?blue@XLColor@OpenXLSX@@QEBAEXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte Blue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hex@XLColor@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Hex(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLColor> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLColor>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLColor managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLColor managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLColor __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLColor(native.ToPointer(), skipVTables);
            }

            internal static XLColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLColor)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLColor __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLColor(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLColor.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLColor(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLColor(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLColor()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLColor(byte alpha, byte red, byte green, byte blue)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, alpha, red, green, blue);
            }

            public XLColor(byte red, byte green, byte blue)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, red, green, blue);
            }

            public XLColor(string hexCode)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, hexCode);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public XLColor(global::OpenXLSX.OpenXLSX.XLColor other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Set(byte alpha, byte red, byte green, byte blue)
            {
                __Internal.Set(__Instance, alpha, red, green, blue);
            }

            public void Set(byte red, byte green, byte blue)
            {
                __Internal.Set(__Instance, red, green, blue);
            }

            public void Set(string hexCode)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, hexCode);
                var __arg0 = __basicString0.__Instance;
                __Internal.Set(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLColor(string hexCode)
            {
                return new global::OpenXLSX.OpenXLSX.XLColor(hexCode);
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLColor lhs, global::OpenXLSX.OpenXLSX.XLColor rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLColor;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLColor.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLColor lhs, global::OpenXLSX.OpenXLSX.XLColor rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public byte Alpha
            {
                get
                {
                    var ___ret = __Internal.Alpha(__Instance);
                    return ___ret;
                }
            }

            public byte Red
            {
                get
                {
                    var ___ret = __Internal.Red(__Instance);
                    return ___ret;
                }
            }

            public byte Green
            {
                get
                {
                    var ___ret = __Internal.Green(__Instance);
                    return ___ret;
                }
            }

            public byte Blue
            {
                get
                {
                    var ___ret = __Internal.Blue(__Instance);
                    return ___ret;
                }
            }

            public string Hex
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Hex(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>This class encapsulates the concept of a cell range, i.e. a square area</para>
        /// <para>(or subset) of cells in a spreadsheet.</para>
        /// </summary>
        public unsafe partial class XLCellRange : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 128)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_dataNode;
                internal global::OpenXLSX.OpenXLSX.XLCellReference.__Internal m_topLeft;
                internal global::OpenXLSX.OpenXLSX.XLCellReference.__Internal m_bottomRight;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal global::Std.Vector.__Internalc__N_std_S_vector__k___N_std_S_allocator__k m_columnStyles;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellRange@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellRange@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@AEBVXLCellReference@1@1AEBVXLSharedStrings@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr dataNode, __IntPtr topLeft, __IntPtr bottomRight, __IntPtr sharedStrings);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellRange@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellRange@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?fetchColumnStyles@XLCellRange@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FetchColumnStyles(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?begin@XLCellRange@OpenXLSX@@QEBA?AVXLCellIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Begin(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?end@XLCellRange@OpenXLSX@@QEBA?AVXLCellIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLCellRange@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFormat@XLCellRange@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFormat(__IntPtr __instance, ulong cellFormatIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?topLeft@XLCellRange@OpenXLSX@@QEBA?BVXLCellReference@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TopLeft(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?bottomRight@XLCellRange@OpenXLSX@@QEBA?BVXLCellReference@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void BottomRight(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?address@XLCellRange@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Address(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numRows@XLCellRange@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint NumRows(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numColumns@XLCellRange@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort NumColumns(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellRange> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellRange>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellRange managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellRange managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellRange __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellRange(native.ToPointer(), skipVTables);
            }

            internal static XLCellRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellRange)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellRange __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellRange(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellRange.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellRange(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellRange(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor for variable declaration</summary>
            public XLCellRange()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLCellRange(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node dataNode, global::OpenXLSX.OpenXLSX.XLCellReference topLeft, global::OpenXLSX.OpenXLSX.XLCellReference bottomRight, global::OpenXLSX.OpenXLSX.XLSharedStrings sharedStrings)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(dataNode, null))
                    throw new global::System.ArgumentNullException("dataNode", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = dataNode.__Instance;
                if (ReferenceEquals(topLeft, null))
                    throw new global::System.ArgumentNullException("topLeft", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = topLeft.__Instance;
                if (ReferenceEquals(bottomRight, null))
                    throw new global::System.ArgumentNullException("bottomRight", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = bottomRight.__Instance;
                if (ReferenceEquals(sharedStrings, null))
                    throw new global::System.ArgumentNullException("sharedStrings", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = sharedStrings.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, __arg2, __arg3);
            }

            /// <summary>Copy constructor</summary>
            /// <param name="other">The range object to be copied.</param>
            /// <remarks>This implements the default copy constructor, i.e. memberwise copying.</remarks>
            public XLCellRange(global::OpenXLSX.OpenXLSX.XLCellRange other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>populate the m_columnStyles</summary>
            /// <returns>a const XLCellReference</returns>
            public void FetchColumnStyles()
            {
                __Internal.FetchColumnStyles(__Instance);
            }

            public global::OpenXLSX.OpenXLSX.XLCellIterator Begin()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal();
                __Internal.Begin(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLCellIterator End()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal();
                __Internal.End(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public void Clear()
            {
                __Internal.Clear(__Instance);
            }

            /// <summary>Set cell format for a range of cells</summary>
            /// <param name="cellFormatIndex">The style to set, corresponding to the nidex of XLStyles::cellStyles()</param>
            /// <remarks>true on success, false on failure</remarks>
            public bool SetFormat(ulong cellFormatIndex)
            {
                var ___ret = __Internal.SetFormat(__Instance, cellFormatIndex);
                return ___ret;
            }

            /// <summary>get the top left cell</summary>
            /// <returns>a const XLCellReference</returns>
            public global::OpenXLSX.OpenXLSX.XLCellReference TopLeft
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLCellReference.__Internal();
                    __Internal.TopLeft(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLCellReference.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLCellReference.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>get the bottom right cell</summary>
            /// <returns>a const XLCellReference</returns>
            public global::OpenXLSX.OpenXLSX.XLCellReference BottomRight
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLCellReference.__Internal();
                    __Internal.BottomRight(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLCellReference.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLCellReference.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>get the string reference that corresponds to the represented cell range</summary>
            /// <returns>a std::string range reference, e.g. &quot;A2:Z5&quot;</returns>
            public string Address
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Address(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Get the number of rows in the range.</summary>
            /// <returns>The number of rows.</returns>
            public uint NumRows
            {
                get
                {
                    var ___ret = __Internal.NumRows(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the number of columns in the range.</summary>
            /// <returns>The number of columns.</returns>
            public ushort NumColumns
            {
                get
                {
                    var ___ret = __Internal.NumColumns(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLCellIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 224)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_dataNode;
                internal global::OpenXLSX.OpenXLSX.XLCellReference.__Internal m_topLeft;
                internal global::OpenXLSX.OpenXLSX.XLCellReference.__Internal m_bottomRight;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal byte m_endReached;
                internal global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__Internal m_hintNode;
                internal uint m_hintRow;
                internal global::OpenXLSX.OpenXLSX.XLCell.__Internal m_currentCell;
                internal int m_currentCellStatus;
                internal uint m_currentRow;
                internal ushort m_currentColumn;
                internal __IntPtr m_colStyles;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellIterator@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellIterator@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??EXLCellIterator@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorPlusPlus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8XLCellIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9XLCellIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?endReached@XLCellIterator@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool EndReached(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?distance@XLCellIterator@OpenXLSX@@QEAA_KAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Distance(__IntPtr __instance, __IntPtr last);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellExists@XLCellIterator@OpenXLSX@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool CellExists(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?address@XLCellIterator@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Address(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellIterator(native.ToPointer(), skipVTables);
            }

            internal static XLCellIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLCellIterator(global::OpenXLSX.OpenXLSX.XLCellIterator other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::OpenXLSX.OpenXLSX.XLCellIterator operator ++(global::OpenXLSX.OpenXLSX.XLCellIterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorPlusPlus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellIterator.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLCellIterator __op, global::OpenXLSX.OpenXLSX.XLCellIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return __opNull && rhsNull;
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLCellIterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLCellIterator __op, global::OpenXLSX.OpenXLSX.XLCellIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return !(__opNull && rhsNull);
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>determine whether iterator is at 1 beyond the last cell in range</summary>
            /// <remarks>28-07-2024: Removed const from return type (Troldal)</remarks>
            public bool EndReached()
            {
                var ___ret = __Internal.EndReached(__Instance);
                return ___ret;
            }

            public ulong Distance(global::OpenXLSX.OpenXLSX.XLCellIterator last)
            {
                if (ReferenceEquals(last, null))
                    throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = last.__Instance;
                var ___ret = __Internal.Distance(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>determine whether the cell that the iterator points to exists (cell at m_currentRow, m_currentColumn)</summary>
            /// <returns>true if XML already has an entry for that cell, otherwise false</returns>
            public bool CellExists
            {
                get
                {
                    var ___ret = __Internal.CellExists(__Instance);
                    return ___ret;
                }
            }

            /// <summary>get the XLCellReference::address corresponding to the current iterator position</summary>
            /// <returns>an XLCellReference::address, with m_bottomRight.col() + 1 for the beyond-the-end iterator</returns>
            /// <remarks>28-07-2024: Removed const from return type (Troldal)</remarks>
            public string Address
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Address(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLColumn : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_columnNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColumn@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr columnNode);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColumn@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLColumn@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFormat@XLColumn@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFormat(__IntPtr __instance, ulong cellFormatIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?width@XLColumn@OpenXLSX@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float Width(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setWidth@XLColumn@OpenXLSX@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWidth(__IntPtr __instance, float width);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isHidden@XLColumn@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsHidden(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHidden@XLColumn@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHidden(__IntPtr __instance, bool state);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?columnNode@XLColumn@OpenXLSX@@QEBAAEAVOpenXLSX_xml_node@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ColumnNode(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?format@XLColumn@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Format(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLColumn> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLColumn>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLColumn managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLColumn managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLColumn __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLColumn(native.ToPointer(), skipVTables);
            }

            internal static XLColumn __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLColumn)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLColumn __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLColumn(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLColumn.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLColumn(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLColumn(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor</summary>
            /// <param name="columnNode">A pointer to the XMLNode for the column.</param>
            public XLColumn(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node columnNode)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColumn.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(columnNode, null))
                    throw new global::System.ArgumentNullException("columnNode", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = columnNode.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor [deleted]</summary>
            public XLColumn(global::OpenXLSX.OpenXLSX.XLColumn other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColumn.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set the column style as a reference to the array index of xl/styles.xml:&gt;:&gt;</summary>
            /// <param name="cellFormatIndex">The style to set, corresponding to the index of XLStyles::cellStyles()</param>
            /// <remarks>true on success, false on failure</remarks>
            public bool SetFormat(ulong cellFormatIndex)
            {
                var ___ret = __Internal.SetFormat(__Instance, cellFormatIndex);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLColumn(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node columnNode)
            {
                return new global::OpenXLSX.OpenXLSX.XLColumn(columnNode);
            }

            /// <summary>Get the width of the column.</summary>
            /// <param name="width">The width of the column</param>
            /// <returns>
            /// <para>The width of the column.</para>
            /// <para>Set the width of the column</para>
            /// </returns>
            public float Width
            {
                get
                {
                    var ___ret = __Internal.Width(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWidth(__Instance, value);
                }
            }

            /// <summary>Is the column hidden?</summary>
            /// <param name="state">The state of the column.</param>
            /// <returns>
            /// <para>The state of the column.</para>
            /// <para>Set the column to be shown or hidden.</para>
            /// </returns>
            public bool Hidden
            {
                get
                {
                    var ___ret = __Internal.IsHidden(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHidden(__Instance, value);
                }
            }

            /// <summary>Get the XMLNode object for the column.</summary>
            /// <returns>The XMLNode for the column</returns>
            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node ColumnNode
            {
                get
                {
                    var ___ret = __Internal.ColumnNode(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>Get the array index of xl/styles.xml:&gt;:&gt; for the style assigned to the column.</para>
            /// <para>This value is stored in the col attributes like so: style=&quot;2&quot;</para>
            /// </summary>
            /// <param name="cellFormatIndex">The style to set, corresponding to the index of XLStyles::cellStyles()</param>
            /// <remarks>
            /// <para>The index of the applicable format style</para>
            /// <para>Set the column style as a reference to the array index of xl/styles.xml:&gt;:&gt;</para>
            /// <para>true on success, false on failure</para>
            /// </remarks>
            public ulong Format
            {
                get
                {
                    var ___ret = __Internal.Format(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFormat(__Instance, value);
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLDocumentProperties class is an enumeration of the possible properties (metadata) that can be set</para>
        /// <para>for a XLDocument object (and .xlsx file)</para>
        /// </summary>
        public enum XLProperty
        {
            Title = 0,
            Subject = 1,
            Creator = 2,
            Keywords = 3,
            Description = 4,
            LastModifiedBy = 5,
            LastPrinted = 6,
            CreationDate = 7,
            ModificationDate = 8,
            Category = 9,
            Application = 10,
            DocSecurity = 11,
            ScaleCrop = 12,
            Manager = 13,
            Company = 14,
            LinksUpToDate = 15,
            SharedDoc = 16,
            HyperlinkBase = 17,
            HyperlinksChanged = 18,
            AppVersion = 19
        }

        /// <summary>
        /// <para>This class encapsulates the concept of an excel file. It is different from the XLWorkbook, in that an</para>
        /// <para>XLDocument holds an XLWorkbook together with its metadata, as well as methods for opening,</para>
        /// <para>closing and saving the document.The XLDocument is the entrypoint for clients</para>
        /// <para>using the RapidXLSX library.</para>
        /// </summary>
        public unsafe partial class XLDocument : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 408)]
            public partial struct __Internal
            {
                internal byte m_suppressWarnings;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filePath;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_realPath;
                internal global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration.__Internal m_xmlSavingDeclaration;
                internal global::Std.List.__Internalc__N_std_S_list____N_OpenXLSX_S_XLXmlData___N_std_S_allocator__S0_ m_data;
                internal global::Std.Deque.__Internalc__N_std_S_deque____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_sharedStringCache;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal global::OpenXLSX.OpenXLSX.XLRelationships.__Internal m_docRelationships;
                internal global::OpenXLSX.OpenXLSX.XLRelationships.__Internal m_wbkRelationships;
                internal global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal m_contentTypes;
                internal global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal m_appProperties;
                internal global::OpenXLSX.OpenXLSX.XLProperties.__Internal m_coreProperties;
                internal global::OpenXLSX.OpenXLSX.XLStyles.__Internal m_styles;
                internal global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal m_workbook;
                internal global::OpenXLSX.OpenXLSX.IZipArchive.__Internal m_archive;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDocument@OpenXLSX@@QEAA@AEBVIZipArchive@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr zipArchive);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDocument@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVIZipArchive@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr docPath, __IntPtr zipArchive);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLDocument@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?showWarnings@XLDocument@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ShowWarnings(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?suppressWarnings@XLDocument@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SuppressWarnings(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?open@XLDocument@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Open(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLDocument@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Create(__IntPtr __instance, __IntPtr fileName, bool forceOverwrite);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLDocument@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Create(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?close@XLDocument@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Close(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?save@XLDocument@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Save(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?saveAs@XLDocument@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SaveAs(__IntPtr __instance, __IntPtr fileName, bool forceOverwrite);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?saveAs@XLDocument@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SaveAs(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?property@XLDocument@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4XLProperty@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Property(__IntPtr __instance, __IntPtr @return, global::OpenXLSX.OpenXLSX.XLProperty prop);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLDocument@OpenXLSX@@QEAAXW4XLProperty@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLProperty prop, __IntPtr value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteProperty@XLDocument@OpenXLSX@@QEAAXW4XLProperty@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteProperty(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLProperty theProperty);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLDocument@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?execCommand@XLDocument@OpenXLSX@@QEAA_NAEBVXLCommand@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ExecCommand(__IntPtr __instance, __IntPtr command);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?execQuery@XLDocument@OpenXLSX@@QEAA?AVXLQuery@2@AEBV32@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ExecQuery(__IntPtr __instance, __IntPtr @return, __IntPtr query);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSavingDeclaration@XLDocument@OpenXLSX@@QEAAXAEBVXLXmlSavingDeclaration@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSavingDeclaration(__IntPtr __instance, __IntPtr savingDeclaration);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?extractXmlFromArchive@XLDocument@OpenXLSX@@IEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ExtractXmlFromArchive(__IntPtr __instance, __IntPtr @return, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlData@XLDocument@OpenXLSX@@IEAAPEAVXLXmlData@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetXmlData(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasXmlData@XLDocument@OpenXLSX@@IEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasXmlData(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name@XLDocument@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Name(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?path@XLDocument@OpenXLSX@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Path(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?workbook@XLDocument@OpenXLSX@@QEBA?AVXLWorkbook@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Workbook(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isOpen@XLDocument@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsOpen(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?styles@XLDocument@OpenXLSX@@QEAAAEAVXLStyles@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Styles(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDocument> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDocument>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLDocument managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLDocument managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLDocument __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLDocument(native.ToPointer(), skipVTables);
            }

            internal static XLDocument __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLDocument)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLDocument __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLDocument(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLDocument(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLDocument(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor. The default constructor with no arguments.</summary>
            public XLDocument(global::OpenXLSX.OpenXLSX.IZipArchive zipArchive)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDocument.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(zipArchive, null))
                    throw new global::System.ArgumentNullException("zipArchive", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = zipArchive.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Constructor. An alternative constructor, taking the path to the .xlsx file as an argument.</summary>
            /// <param name="docPath">A std::string with the path to the .xlsx file.</param>
            public XLDocument(string docPath, global::OpenXLSX.OpenXLSX.IZipArchive zipArchive)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDocument.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, docPath);
                var __arg0 = __basicString0.__Instance;
                if (ReferenceEquals(zipArchive, null))
                    throw new global::System.ArgumentNullException("zipArchive", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = zipArchive.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>ensure that warnings are shown (default setting)</summary>
            public void ShowWarnings()
            {
                __Internal.ShowWarnings(__Instance);
            }

            /// <summary>ensure that warnings are suppressed where this parameter is supported (currently only XLStyles)</summary>
            public void SuppressWarnings()
            {
                __Internal.SuppressWarnings(__Instance);
            }

            /// <summary>Open the .xlsx file with the given path</summary>
            /// <param name="fileName">The path of the .xlsx file to open</param>
            public void Open(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Open(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Create a new .xlsx file with the given name.</summary>
            /// <param name="fileName">The path of the new .xlsx file.</param>
            /// <param name="forceOverwrite">If not true (XLForceOverwrite) and fileName exists, create will throw an exception</param>
            /// <remarks>
            /// <para>XLException (OpenXLSX failed checks)</para>
            /// <para>ZipRuntimeError (zippy failed archive / file access)</para>
            /// </remarks>
            public void Create(string fileName, bool forceOverwrite)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Create(__Instance, __arg0, forceOverwrite);
                __basicString0.Dispose();
            }

            /// <summary>Create a new .xlsx file with the given name. Legacy interface, invokes create( fileName, XLForceOverwrite )</summary>
            /// <param name="fileName">The path of the new .xlsx file.</param>
            /// <remarks>
            /// <para>use instead void create(const std::string&amp;fileName, bool forceOverwrite)</para>
            /// <para>Overwriting an existing file is retained as legacy behavior, but can lead to data loss!</para>
            /// </remarks>
            public void Create(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Create(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Close the current document</summary>
            public void Close()
            {
                __Internal.Close(__Instance);
            }

            /// <summary>Save the current document using the current filename, overwriting the existing file.</summary>
            /// <remarks>
            /// <para>XLException (OpenXLSX failed checks)</para>
            /// <para>ZipRuntimeError (zippy failed archive / file access)</para>
            /// </remarks>
            public void Save()
            {
                __Internal.Save(__Instance);
            }

            /// <summary>Save the document with a new name. If a file exists with that name, it will be overwritten.</summary>
            /// <param name="fileName">The path of the file</param>
            /// <param name="forceOverwrite">If not true (XLForceOverwrite) and fileName exists, saveAs will throw an exception</param>
            /// <remarks>
            /// <para>XLException (OpenXLSX failed checks)</para>
            /// <para>ZipRuntimeError (zippy failed archive / file access)</para>
            /// </remarks>
            public void SaveAs(string fileName, bool forceOverwrite)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.SaveAs(__Instance, __arg0, forceOverwrite);
                __basicString0.Dispose();
            }

            /// <summary>Save the document with a new name. Legacy interface, invokes saveAs( fileName, XLForceOverwrite )</summary>
            /// <param name="fileName">The path of the file</param>
            /// <remarks>
            /// <para>use instead void saveAs(const std::string&amp;fileName, bool forceOverwrite)</para>
            /// <para>Overwriting an existing file is retained as legacy behavior, but can lead to data loss!</para>
            /// </remarks>
            public void SaveAs(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.SaveAs(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Get the requested document property.</summary>
            /// <param name="prop">The name of the property to get.</param>
            /// <returns>The property as a string</returns>
            public string Property(global::OpenXLSX.OpenXLSX.XLProperty prop)
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Property(__Instance, new IntPtr(&___ret), prop);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Set a property</summary>
            /// <param name="prop">The property to set.</param>
            /// <param name="value">The getValue of the property, as a string</param>
            public void SetProperty(global::OpenXLSX.OpenXLSX.XLProperty prop, string value)
            {
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, value);
                var __arg1 = __basicString1.__Instance;
                __Internal.SetProperty(__Instance, prop, __arg1);
                __basicString1.Dispose();
            }

            /// <summary>Delete the property from the document</summary>
            /// <param name="theProperty">The property to delete from the document</param>
            public void DeleteProperty(global::OpenXLSX.OpenXLSX.XLProperty theProperty)
            {
                __Internal.DeleteProperty(__Instance, theProperty);
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLDocument __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            /// <returns>for XLCommandType::SetSheetActive: execution success, otherwise always true</returns>
            public bool ExecCommand(global::OpenXLSX.OpenXLSX.XLCommand command)
            {
                if (ReferenceEquals(command, null))
                    throw new global::System.ArgumentNullException("command", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = command.__Instance;
                var ___ret = __Internal.ExecCommand(__Instance, __arg0);
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.XLQuery ExecQuery(global::OpenXLSX.OpenXLSX.XLQuery query)
            {
                if (ReferenceEquals(query, null))
                    throw new global::System.ArgumentNullException("query", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = query.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLQuery.__Internal();
                __Internal.ExecQuery(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::OpenXLSX.OpenXLSX.XLQuery.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLQuery.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>configure an alternative XML saving declaration to be used with pugixml</summary>
            /// <param name="savingDeclaration">An XLXmlSavingDeclaration object with the configuration to use</param>
            public void SetSavingDeclaration(global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration savingDeclaration)
            {
                if (ReferenceEquals(savingDeclaration, null))
                    throw new global::System.ArgumentNullException("savingDeclaration", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = savingDeclaration.__Instance;
                __Internal.SetSavingDeclaration(__Instance, __arg0);
            }

            /// <summary>Get an XML file from the .xlsx archive.</summary>
            /// <param name="path">The relative path of the file.</param>
            /// <returns>A std::string with the content of the file</returns>
            protected string ExtractXmlFromArchive(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.ExtractXmlFromArchive(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            protected global::OpenXLSX.OpenXLSX.XLXmlData GetXmlData(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.GetXmlData(__Instance, __arg0);
                __basicString0.Dispose();
                var __result0 = global::OpenXLSX.OpenXLSX.XLXmlData.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            protected bool HasXmlData(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.HasXmlData(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLDocument(global::OpenXLSX.OpenXLSX.IZipArchive zipArchive)
            {
                return new global::OpenXLSX.OpenXLSX.XLDocument(zipArchive);
            }

            /// <summary>Get the filename of the current document, e.g. &quot;spreadsheet.xlsx&quot;.</summary>
            /// <returns>A std::string with the filename.</returns>
            /// <remarks>
            /// <para>2024-06-03: function can't return as reference to const because filename as a substr of m_filePath can be a temporary</para>
            /// <para>2024-07-28: Removed const from return type</para>
            /// </remarks>
            public string Name
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Name(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Get the full path of the current document, e.g. &quot;drive/blah/spreadsheet.xlsx&quot;</summary>
            /// <returns>A std::string with the path.</returns>
            public string Path
            {
                get
                {
                    var ___ret = __Internal.Path(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }
            }

            /// <summary>Get the underlying workbook object, as a const object.</summary>
            /// <returns>A const pointer to the XLWorkbook object.</returns>
            public global::OpenXLSX.OpenXLSX.XLWorkbook Workbook
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal();
                    __Internal.Workbook(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLWorkbook.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public bool IsOpen
            {
                get
                {
                    var ___ret = __Internal.IsOpen(__Instance);
                    return ___ret;
                }
            }

            /// <summary>return a handle on the workbook's styles</summary>
            /// <returns>a reference to m_styles</returns>
            public global::OpenXLSX.OpenXLSX.XLStyles Styles
            {
                get
                {
                    var ___ret = __Internal.Styles(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLStyles.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class XLDocument
        {
            public partial struct __Internal
            {
            }

            public const uint PugiParseSettings = 124;
            public const bool XLForceOverwrite = true;
            public const bool XLDoNotOverwrite = false;        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>This class functions as a wrapper around any class that provides the necessary functionality for</para>
        /// <para>a zip archive.</para>
        /// </summary>
        /// <remarks>
        /// <para>This class works by applying 'type erasure'. This enables the use of objects of any class, the only</para>
        /// <para>requirement being that it provides the right interface. No inheritance from a base class is needed.</para>
        /// </remarks>
        public unsafe partial class IZipArchive : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_IZipArchive_S_Concept___N_std_S_default_delete__S0_ m_zipArchive;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0IZipArchive@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0IZipArchive@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1IZipArchive@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BIZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?open@IZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Open(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?close@IZipArchive@OpenXLSX@@QEBAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Close(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?save@IZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Save(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addEntry@IZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddEntry(__IntPtr __instance, __IntPtr name, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteEntry@IZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteEntry(__IntPtr __instance, __IntPtr entryName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getEntry@IZipArchive@OpenXLSX@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetEntry(__IntPtr __instance, __IntPtr @return, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasEntry@IZipArchive@OpenXLSX@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasEntry(__IntPtr __instance, __IntPtr entryName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isValid@IZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isOpen@IZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsOpen(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.IZipArchive> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.IZipArchive>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.IZipArchive managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.IZipArchive managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static IZipArchive __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IZipArchive(native.ToPointer(), skipVTables);
            }

            internal static IZipArchive __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IZipArchive)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static IZipArchive __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IZipArchive(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.IZipArchive.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private IZipArchive(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IZipArchive(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor</summary>
            public IZipArchive()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.IZipArchive.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy constructor</summary>
            public IZipArchive(global::OpenXLSX.OpenXLSX.IZipArchive other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.IZipArchive.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.IZipArchive __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            public void Open(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Open(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void Close()
            {
                __Internal.Close(__Instance);
            }

            public void Save(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                __Internal.Save(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void AddEntry(string name, string data)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, data);
                var __arg1 = __basicString1.__Instance;
                __Internal.AddEntry(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void DeleteEntry(string entryName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, entryName);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteEntry(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public string GetEntry(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetEntry(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public bool HasEntry(string entryName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, entryName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.HasEntry(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool IsValid
            {
                get
                {
                    var ___ret = __Internal.IsValid(__Instance);
                    return ___ret;
                }
            }

            public bool IsOpen
            {
                get
                {
                    var ___ret = __Internal.IsOpen(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public enum XLCommandType : byte
        {
            SetSheetName = 0,
            SetSheetColor = 1,
            SetSheetVisibility = 2,
            SetSheetIndex = 3,
            SetSheetActive = 4,
            ResetCalcChain = 5,
            CheckAndFixCoreProperties = 6,
            CheckAndFixExtendedProperties = 7,
            AddSharedStrings = 8,
            AddWorksheet = 9,
            AddChartsheet = 10,
            DeleteSheet = 11,
            CloneSheet = 12,
            AddStyles = 13
        }

        public enum XLQueryType : byte
        {
            QuerySheetName = 0,
            QuerySheetIndex = 1,
            QuerySheetVisibility = 2,
            QuerySheetIsActive = 3,
            QuerySheetType = 4,
            QuerySheetID = 5,
            QuerySheetRelsID = 6,
            QuerySheetRelsTarget = 7,
            QuerySharedStrings = 8,
            QueryXmlData = 9
        }

        public unsafe partial class XLCommand : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal global::OpenXLSX.OpenXLSX.XLCommandType m_type;
                internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_any___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_params;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCommand@OpenXLSX@@QEAA@W4XLCommandType@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLCommandType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCommand@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCommand@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLCommand@OpenXLSX@@QEBA?AW4XLCommandType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLCommandType Type(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCommand> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCommand>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCommand managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCommand managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCommand __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCommand(native.ToPointer(), skipVTables);
            }

            internal static XLCommand __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCommand)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCommand __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCommand(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCommand.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCommand(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCommand(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLCommand(global::OpenXLSX.OpenXLSX.XLCommandType type)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCommand.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, type);
            }

            public XLCommand(global::OpenXLSX.OpenXLSX.XLCommand _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCommand.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLCommand(global::OpenXLSX.OpenXLSX.XLCommandType type)
            {
                return new global::OpenXLSX.OpenXLSX.XLCommand(type);
            }

            public global::OpenXLSX.OpenXLSX.XLCommandType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class XLQuery : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public partial struct __Internal
            {
                internal global::OpenXLSX.OpenXLSX.XLQueryType m_type;
                internal global::Std.Any.__Internal m_result;
                internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_any___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_params;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLQuery@OpenXLSX@@QEAA@W4XLQueryType@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLQueryType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLQuery@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLQuery@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLQuery@OpenXLSX@@QEBA?AW4XLQueryType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLQueryType Type(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLQuery> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLQuery>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLQuery managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLQuery managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLQuery __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLQuery(native.ToPointer(), skipVTables);
            }

            internal static XLQuery __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLQuery)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLQuery __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLQuery(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLQuery.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLQuery(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLQuery(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLQuery(global::OpenXLSX.OpenXLSX.XLQueryType type)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLQuery.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, type);
            }

            public XLQuery(global::OpenXLSX.OpenXLSX.XLQuery _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLQuery.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLQuery(global::OpenXLSX.OpenXLSX.XLQueryType type)
            {
                return new global::OpenXLSX.OpenXLSX.XLQuery(type);
            }

            public global::OpenXLSX.OpenXLSX.XLQueryType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public enum XLContentType : byte
        {
            Workbook = 0,
            WorkbookMacroEnabled = 1,
            Worksheet = 2,
            Chartsheet = 3,
            ExternalLink = 4,
            Theme = 5,
            Styles = 6,
            SharedStrings = 7,
            Drawing = 8,
            Chart = 9,
            ChartStyle = 10,
            ChartColorStyle = 11,
            ControlProperties = 12,
            CalculationChain = 13,
            VBAProject = 14,
            CoreProperties = 15,
            ExtendedProperties = 16,
            CustomProperties = 17,
            Comments = 18,
            Table = 19,
            VMLDrawing = 20,
            Unknown = 21
        }

        public unsafe partial class XLContentItem : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_contentNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentItem@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentItem@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentItem@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLContentItem@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLContentItem@OpenXLSX@@QEBA?AW4XLContentType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLContentType Type(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?path@XLContentItem@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Path(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLContentItem> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLContentItem>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLContentItem managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLContentItem managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLContentItem __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLContentItem(native.ToPointer(), skipVTables);
            }

            internal static XLContentItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLContentItem)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLContentItem __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLContentItem(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLContentItem.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLContentItem(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLContentItem(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLContentItem()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLContentItem(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLContentItem(global::OpenXLSX.OpenXLSX.XLContentItem other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLContentItem(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLContentItem(node);
            }

            public global::OpenXLSX.OpenXLSX.XLContentType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }

            public string Path
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Path(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>The purpose of this class is to load, store add and save item in the [Content_Types].xml file.</summary>
        public unsafe partial class XLContentTypes : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentTypes@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentTypes@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentTypes@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLContentTypes@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addOverride@XLContentTypes@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4XLContentType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddOverride(__IntPtr __instance, __IntPtr path, global::OpenXLSX.OpenXLSX.XLContentType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteOverride@XLContentTypes@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteOverride(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteOverride@XLContentTypes@OpenXLSX@@QEAAXAEBVXLContentItem@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteOverride_1(__IntPtr __instance, __IntPtr item);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?contentItem@XLContentTypes@OpenXLSX@@QEAA?AVXLContentItem@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ContentItem(__IntPtr __instance, __IntPtr @return, __IntPtr path);
            }

            internal static new XLContentTypes __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLContentTypes(native.ToPointer(), skipVTables);
            }

            internal static new XLContentTypes __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLContentTypes)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLContentTypes __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLContentTypes(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLContentTypes(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLContentTypes(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLContentTypes()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLContentTypes(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLContentTypes(global::OpenXLSX.OpenXLSX.XLContentTypes other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Add a new override key/getValue pair to the data store.</summary>
            /// <param name="path">The key</param>
            /// <param name="type">The getValue</param>
            public void AddOverride(string path, global::OpenXLSX.OpenXLSX.XLContentType type)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                __Internal.AddOverride(__Instance, __arg0, type);
                __basicString0.Dispose();
            }

            public void DeleteOverride(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteOverride(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void DeleteOverride(global::OpenXLSX.OpenXLSX.XLContentItem item)
            {
                if (ReferenceEquals(item, null))
                    throw new global::System.ArgumentNullException("item", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = item.__Instance;
                __Internal.DeleteOverride_1(__Instance, __arg0);
            }

            public global::OpenXLSX.OpenXLSX.XLContentItem ContentItem(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLContentItem.__Internal();
                __Internal.ContentItem(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLContentItem.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLContentItem.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLContentTypes(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLContentTypes(xmlData);
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLProperties : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLProperties@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLProperties@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLProperties@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLProperties@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty(__IntPtr __instance, __IntPtr name, __IntPtr value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty(__IntPtr __instance, __IntPtr name, int value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty_1(__IntPtr __instance, __IntPtr name, double value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?property@XLProperties@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Property(__IntPtr __instance, __IntPtr @return, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteProperty@XLProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteProperty(__IntPtr __instance, __IntPtr name);
            }

            internal static new XLProperties __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLProperties(native.ToPointer(), skipVTables);
            }

            internal static new XLProperties __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLProperties)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLProperties __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLProperties(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLProperties(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLProperties(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLProperties()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLProperties(global::OpenXLSX.OpenXLSX.XLProperties other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLProperties.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLProperties.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetProperty(string name, string value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, value);
                var __arg1 = __basicString1.__Instance;
                __Internal.SetProperty(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void SetProperty(string name, int value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetProperty(__Instance, __arg0, value);
                __basicString0.Dispose();
            }

            public void SetProperty(string name, double value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetProperty_1(__Instance, __arg0, value);
                __basicString0.Dispose();
            }

            public string Property(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Property(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public void DeleteProperty(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteProperty(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLProperties(xmlData);
            }
        }

        /// <summary>
        /// <para>This class is a specialization of the XLAbstractXMLFile, with the purpose of the representing the</para>
        /// <para>document app properties in the app.xml file (docProps folder) in the .xlsx package.</para>
        /// </summary>
        public unsafe partial class XLAppProperties : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAppProperties@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAppProperties@OpenXLSX@@QEAA@PEAVXLXmlData@1@AEBVOpenXLSX_xml_document@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData, __IntPtr workbookXml);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAppProperties@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAppProperties@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLAppProperties@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?incrementSheetCount@XLAppProperties@OpenXLSX@@QEAAXF@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void IncrementSheetCount(__IntPtr __instance, short increment);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddSheetName(__IntPtr __instance, __IntPtr title);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteSheetName(__IntPtr __instance, __IntPtr title);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSheetName(__IntPtr __instance, __IntPtr oldTitle, __IntPtr newTitle);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addHeadingPair@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddHeadingPair(__IntPtr __instance, __IntPtr name, int value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteHeadingPair@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteHeadingPair(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHeadingPair@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeadingPair(__IntPtr __instance, __IntPtr name, int newValue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty(__IntPtr __instance, __IntPtr name, __IntPtr value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?property@XLAppProperties@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Property(__IntPtr __instance, __IntPtr @return, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteProperty@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteProperty(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?appendSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AppendSheetName(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?prependSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PrependSheetName(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?insertSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void InsertSheetName(__IntPtr __instance, __IntPtr sheetName, uint index);
            }

            internal static new XLAppProperties __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLAppProperties(native.ToPointer(), skipVTables);
            }

            internal static new XLAppProperties __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLAppProperties)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLAppProperties __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLAppProperties(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLAppProperties(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLAppProperties(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLAppProperties()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>enable XLAppProperties to re-create a worksheet list in docProps/app.xml&gt; element from workbookXml</summary>
            public XLAppProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData, global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document workbookXml)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                if (ReferenceEquals(workbookXml, null))
                    throw new global::System.ArgumentNullException("workbookXml", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = workbookXml.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
            }

            public XLAppProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLAppProperties(global::OpenXLSX.OpenXLSX.XLAppProperties other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>update the &quot;HeadingPairs&quot; entry for &quot;Worksheets&quot; *and* the &quot;TitlesOfParts&quot; vector size</summary>
            /// <param name="increment">change the sheet count by this (negative = decrement)</param>
            /// <remarks>XLInternalError when sheet count would become&lt;1</remarks>
            public void IncrementSheetCount(short increment)
            {
                __Internal.IncrementSheetCount(__Instance, increment);
            }

            public void AddSheetName(string title)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, title);
                var __arg0 = __basicString0.__Instance;
                __Internal.AddSheetName(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void DeleteSheetName(string title)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, title);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteSheetName(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void SetSheetName(string oldTitle, string newTitle)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, oldTitle);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, newTitle);
                var __arg1 = __basicString1.__Instance;
                __Internal.SetSheetName(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void AddHeadingPair(string name, int value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.AddHeadingPair(__Instance, __arg0, value);
                __basicString0.Dispose();
            }

            public void DeleteHeadingPair(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteHeadingPair(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void SetHeadingPair(string name, int newValue)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetHeadingPair(__Instance, __arg0, newValue);
                __basicString0.Dispose();
            }

            public void SetProperty(string name, string value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, value);
                var __arg1 = __basicString1.__Instance;
                __Internal.SetProperty(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public string Property(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Property(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public void DeleteProperty(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteProperty(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void AppendSheetName(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.AppendSheetName(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void PrependSheetName(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.PrependSheetName(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void InsertSheetName(string sheetName, uint index)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.InsertSheetName(__Instance, __arg0, index);
                __basicString0.Dispose();
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLAppProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLAppProperties(xmlData);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>An enum of the possible relationship (or XML document) types used in relationship (.rels) XML files.</summary>
        public enum XLRelationshipType
        {
            CoreProperties = 0,
            ExtendedProperties = 1,
            CustomProperties = 2,
            Workbook = 3,
            Worksheet = 4,
            Chartsheet = 5,
            Dialogsheet = 6,
            Macrosheet = 7,
            CalculationChain = 8,
            ExternalLink = 9,
            ExternalLinkPath = 10,
            Theme = 11,
            Styles = 12,
            Chart = 13,
            ChartStyle = 14,
            ChartColorStyle = 15,
            Image = 16,
            Drawing = 17,
            VMLDrawing = 18,
            SharedStrings = 19,
            PrinterSettings = 20,
            VBAProject = 21,
            ControlProperties = 22,
            Comments = 23,
            Unknown = 24
        }

        /// <summary>An encapsulation of a relationship item, i.e. an XML file in the document, its type and an ID number.</summary>
        public unsafe partial class XLRelationshipItem : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_relationshipNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationshipItem@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationshipItem@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationshipItem@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRelationshipItem@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLRelationshipItem@OpenXLSX@@QEBA?AW4XLRelationshipType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLRelationshipType Type(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?target@XLRelationshipItem@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Target(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?id@XLRelationshipItem@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Id(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?empty@XLRelationshipItem@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Empty(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRelationshipItem> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRelationshipItem>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRelationshipItem managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRelationshipItem managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRelationshipItem __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRelationshipItem(native.ToPointer(), skipVTables);
            }

            internal static XLRelationshipItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRelationshipItem)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRelationshipItem __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRelationshipItem(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRelationshipItem(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRelationshipItem(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLRelationshipItem()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. New items should only be created through an XLRelationship object.</summary>
            /// <param name="node">An XMLNode object with the relationship item. If no input is provided, a null node is used.</param>
            public XLRelationshipItem(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLRelationshipItem(global::OpenXLSX.OpenXLSX.XLRelationshipItem other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLRelationshipItem(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLRelationshipItem(node);
            }

            /// <summary>Get the type of the current relationship item.</summary>
            /// <returns>An XLRelationshipType enum object, corresponding to the type.</returns>
            public global::OpenXLSX.OpenXLSX.XLRelationshipType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the target, i.e. the path to the XML file the relationship item refers to.</summary>
            /// <returns>An XMLAttribute object containing the Target getValue.</returns>
            public string Target
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Target(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Get the id of the relationship item.</summary>
            /// <returns>An XMLAttribute object containing the Id getValue.</returns>
            public string Id
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Id(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Test if relationship item is empty (== m_relationshipNode-&gt;empty())</summary>
            /// <returns>true if this is an empty relationship item</returns>
            public bool Empty
            {
                get
                {
                    var ___ret = __Internal.Empty(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>An encapsulation of relationship files (.rels files) in an Excel document package.</summary>
        public unsafe partial class XLRelationships : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_path;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationships@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationships@OpenXLSX@@QEAA@PEAVXLXmlData@1@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData, __IntPtr pathTo);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationships@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRelationships@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?relationshipById@XLRelationships@OpenXLSX@@QEBA?AVXLRelationshipItem@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RelationshipById(__IntPtr __instance, __IntPtr @return, __IntPtr id);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?relationshipByTarget@XLRelationships@OpenXLSX@@QEBA?AVXLRelationshipItem@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RelationshipByTarget(__IntPtr __instance, __IntPtr @return, __IntPtr target, bool throwIfNotFound);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteRelationship@XLRelationships@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteRelationship(__IntPtr __instance, __IntPtr relID);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteRelationship@XLRelationships@OpenXLSX@@QEAAXAEBVXLRelationshipItem@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteRelationship_1(__IntPtr __instance, __IntPtr item);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addRelationship@XLRelationships@OpenXLSX@@QEAA?AVXLRelationshipItem@2@W4XLRelationshipType@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddRelationship(__IntPtr __instance, __IntPtr @return, global::OpenXLSX.OpenXLSX.XLRelationshipType type, __IntPtr target);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?targetExists@XLRelationships@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TargetExists(__IntPtr __instance, __IntPtr target);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?idExists@XLRelationships@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IdExists(__IntPtr __instance, __IntPtr id);
            }

            internal static new XLRelationships __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRelationships(native.ToPointer(), skipVTables);
            }

            internal static new XLRelationships __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRelationships)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRelationships __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRelationships(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRelationships.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRelationships(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRelationships(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLRelationships()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationships.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <param name="pathTo">Initialize m_path from this: the path to the relationships file origin of xmlData</param>
            /// <remarks>m_path is used to resolve relative relationship target paths to an absolute</remarks>
            public XLRelationships(global::OpenXLSX.OpenXLSX.XLXmlData xmlData, string pathTo)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationships.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, pathTo);
                var __arg1 = __basicString1.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
            }

            public XLRelationships(global::OpenXLSX.OpenXLSX.XLRelationships other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationships.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Look up a relationship item by ID.</summary>
            /// <param name="id">The ID string of the relationship item to retrieve.</param>
            /// <returns>An XLRelationshipItem object.</returns>
            public global::OpenXLSX.OpenXLSX.XLRelationshipItem RelationshipById(string id)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, id);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal();
                __Internal.RelationshipById(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLRelationshipItem.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Look up a relationship item by Target.</summary>
            /// <param name="target">The Target string of the relationship item to retrieve.</param>
            /// <param name="throwIfNotFound">
            /// <para>Throw an XLException when target is not found, default: true</para>
            /// <para>when false, XLRelationshipItem::empty() can be tested on the return value</para>
            /// </param>
            /// <returns>An XLRelationshipItem object.</returns>
            public global::OpenXLSX.OpenXLSX.XLRelationshipItem RelationshipByTarget(string target, bool throwIfNotFound)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, target);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal();
                __Internal.RelationshipByTarget(__Instance, new IntPtr(&___ret), __arg0, throwIfNotFound);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLRelationshipItem.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public void DeleteRelationship(string relID)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, relID);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteRelationship(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Delete an item from the Relationships register</summary>
            /// <param name="item">The XLRelationshipItem object to delete.</param>
            public void DeleteRelationship(global::OpenXLSX.OpenXLSX.XLRelationshipItem item)
            {
                if (ReferenceEquals(item, null))
                    throw new global::System.ArgumentNullException("item", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = item.__Instance;
                __Internal.DeleteRelationship_1(__Instance, __arg0);
            }

            /// <summary>Add a new relationship item to the XLRelationships object.</summary>
            /// <param name="type">The type of the new relationship item.</param>
            /// <param name="target">The target (or path) of the XML file for the relationship item.</param>
            public global::OpenXLSX.OpenXLSX.XLRelationshipItem AddRelationship(global::OpenXLSX.OpenXLSX.XLRelationshipType type, string target)
            {
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, target);
                var __arg1 = __basicString1.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal();
                __Internal.AddRelationship(__Instance, new IntPtr(&___ret), type, __arg1);
                __basicString1.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLRelationshipItem.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Check if a XLRelationshipItem with the given Target string exists.</summary>
            /// <param name="target">The Target string to look up.</param>
            /// <returns>true if the XLRelationshipItem exists; otherwise false.</returns>
            public bool TargetExists(string target)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, target);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.TargetExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Check if a XLRelationshipItem with the given Id string exists.</summary>
            /// <param name="id">The Id string to look up.</param>
            /// <returns>true if the XLRelationshipItem exists; otherwise false.</returns>
            public bool IdExists(string id)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, id);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.IdExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }
        }

        public unsafe partial class XLRelationships
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?UseRandomIDs@OpenXLSX@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UseRandomIDs();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?UseSequentialIDs@OpenXLSX@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UseSequentialIDs();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?Rand64@OpenXLSX@@YA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Rand64();

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?InitRandom@OpenXLSX@@YAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void InitRandom(bool pseudoRandom);
            }

            /// <summary>Enable use of random (relationship) IDs</summary>
            public static void UseRandomIDs()
            {
                __Internal.UseRandomIDs();
            }

            /// <summary>Disable use of random (relationship) IDs (default behavior)</summary>
            public static void UseSequentialIDs()
            {
                __Internal.UseSequentialIDs();
            }

            /// <summary>Return a 64 bit random value (by invoking Rand32 twice)</summary>
            /// <returns>A 64 bit random value</returns>
            public static ulong Rand64()
            {
                var ___ret = __Internal.Rand64();
                return ___ret;
            }

            /// <summary>Initialize XLRand32 data source</summary>
            /// <param name="pseudoRandom">If true, sequence will be reproducible with a constant seed</param>
            public static void InitRandom(bool pseudoRandom)
            {
                __Internal.InitRandom(pseudoRandom);
            }
        }
    }

    namespace OpenXLSX_XLRelationships
    {
        public unsafe partial class XLRelationships
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?GetStringFromType@OpenXLSX_XLRelationships@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4XLRelationshipType@OpenXLSX@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetStringFromType(__IntPtr @return, global::OpenXLSX.OpenXLSX.XLRelationshipType type);
            }

            /// <summary>helper function, used only within module and from XLProperties.cpp / XLAppProperties::createFromTemplate</summary>
            /// <param name="type">the XLRelationshipType for which to return the correct XML string</param>
            public static string GetStringFromType(global::OpenXLSX.OpenXLSX.XLRelationshipType type)
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetStringFromType(new IntPtr(&___ret), type);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLSheetType class is an enumeration of the available sheet types, e.g. Worksheet (ordinary</para>
        /// <para>spreadsheets), and Chartsheet (sheets with only a chart).</para>
        /// </summary>
        public enum XLSheetType
        {
            Worksheet = 0,
            Chartsheet = 1,
            Dialogsheet = 2,
            Macrosheet = 3
        }

        /// <summary>
        /// <para>This class encapsulates the concept of a Workbook. It provides access to the individual sheets</para>
        /// <para>(worksheets or chartsheets), as well as functionality for adding, deleting, moving and renaming sheets.</para>
        /// </summary>
        public unsafe partial class XLWorkbook : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorkbook@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorkbook@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorkbook@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLWorkbook@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sheet@XLWorkbook@OpenXLSX@@QEAA?AVXLSheet@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sheet(__IntPtr __instance, __IntPtr @return, ushort index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sheet@XLWorkbook@OpenXLSX@@QEAA?AVXLSheet@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sheet(__IntPtr __instance, __IntPtr @return, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?worksheet@XLWorkbook@OpenXLSX@@QEAA?AVXLWorksheet@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Worksheet(__IntPtr __instance, __IntPtr @return, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?worksheet@XLWorkbook@OpenXLSX@@QEAA?AVXLWorksheet@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Worksheet(__IntPtr __instance, __IntPtr @return, ushort index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?chartsheet@XLWorkbook@OpenXLSX@@QEAA?AVXLChartsheet@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Chartsheet(__IntPtr __instance, __IntPtr @return, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?chartsheet@XLWorkbook@OpenXLSX@@QEAA?AVXLChartsheet@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Chartsheet(__IntPtr __instance, __IntPtr @return, ushort index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteSheet@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteSheet(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addWorksheet@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddWorksheet(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cloneSheet@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CloneSheet(__IntPtr __instance, __IntPtr existingName, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSheetIndex@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSheetIndex(__IntPtr __instance, __IntPtr sheetName, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?indexOfSheet@XLWorkbook@OpenXLSX@@QEBAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint IndexOfSheet(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?typeOfSheet@XLWorkbook@OpenXLSX@@QEBA?AW4XLSheetType@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLSheetType TypeOfSheet(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?typeOfSheet@XLWorkbook@OpenXLSX@@QEBA?AW4XLSheetType@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLSheetType TypeOfSheet(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sheetExists@XLWorkbook@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SheetExists(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?worksheetExists@XLWorkbook@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool WorksheetExists(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?chartsheetExists@XLWorkbook@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ChartsheetExists(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?updateSheetReferences@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateSheetReferences(__IntPtr __instance, __IntPtr oldName, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteNamedRanges@XLWorkbook@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteNamedRanges(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFullCalculationOnLoad@XLWorkbook@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFullCalculationOnLoad(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sheetCount@XLWorkbook@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint SheetCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?worksheetCount@XLWorkbook@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint WorksheetCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?chartsheetCount@XLWorkbook@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint ChartsheetCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sharedStrings@XLWorkbook@OpenXLSX@@QEAA?AVXLSharedStrings@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SharedStrings(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasSharedStrings@XLWorkbook@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasSharedStrings(__IntPtr __instance);
            }

            internal static new XLWorkbook __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLWorkbook(native.ToPointer(), skipVTables);
            }

            internal static new XLWorkbook __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLWorkbook)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLWorkbook __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLWorkbook(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLWorkbook(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLWorkbook(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Default constructor. Creates an empty ('null') XLWorkbook object.</summary>
            public XLWorkbook()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. Takes a pointer to an XLXmlData object (stored in the parent XLDocument object).</summary>
            /// <param name="xmlData">A pointer to the underlying XLXmlData object, which holds the XML data.</param>
            /// <remarks>Do not create an XLWorkbook object directly. Get access through the an XLDocument object.</remarks>
            public XLWorkbook(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">The XLWorkbook object to be copied.</param>
            /// <remarks>The copy constructor has been explicitly defaulted.</remarks>
            public XLWorkbook(global::OpenXLSX.OpenXLSX.XLWorkbook other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the sheet (worksheet or chartsheet) at the given index.</summary>
            /// <param name="index">The index at which the desired sheet is located.</param>
            /// <returns>A pointer to an XLAbstractSheet with the sheet at the index.</returns>
            /// <remarks>The index must be 1-based (rather than 0-based) as this is the default for Excel spreadsheets.</remarks>
            public global::OpenXLSX.OpenXLSX.XLSheet Sheet(ushort index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLSheet.__Internal();
                __Internal.Sheet(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLSheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLSheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the sheet (worksheet or chartsheet) with the given name.</summary>
            /// <param name="sheetName">The name of the desired sheet.</param>
            /// <returns>A pointer to an XLAbstractSheet with the sheet at the index.</returns>
            public global::OpenXLSX.OpenXLSX.XLSheet Sheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLSheet.__Internal();
                __Internal.Sheet(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLSheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLSheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the worksheet with the given name.</summary>
            /// <param name="sheetName">The name of the desired worksheet.</param>
            public global::OpenXLSX.OpenXLSX.XLWorksheet Worksheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal();
                __Internal.Worksheet(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLWorksheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the worksheet at the given index.</summary>
            /// <param name="index">The index at which the desired sheet is located.</param>
            public global::OpenXLSX.OpenXLSX.XLWorksheet Worksheet(ushort index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal();
                __Internal.Worksheet(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLWorksheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the chartsheet with the given name.</summary>
            /// <param name="sheetName">The name of the desired chartsheet.</param>
            public global::OpenXLSX.OpenXLSX.XLChartsheet Chartsheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal();
                __Internal.Chartsheet(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLChartsheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the chartsheet at the given index.</summary>
            /// <param name="index">The index at which the desired sheet is located.</param>
            public global::OpenXLSX.OpenXLSX.XLChartsheet Chartsheet(ushort index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal();
                __Internal.Chartsheet(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLChartsheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Delete sheet (worksheet or chartsheet) from the workbook.</summary>
            /// <param name="sheetName">Name of the sheet to delete.</param>
            /// <remarks>
            /// <para>XLException An exception will be thrown if trying to delete the last worksheet in the workbook</para>
            /// <para>A workbook must contain at least one worksheet. Trying to delete the last worksheet from the</para>
            /// <para>workbook will trow an exception.</para>
            /// </remarks>
            public void DeleteSheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteSheet(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void AddWorksheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.AddWorksheet(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void CloneSheet(string existingName, string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, existingName);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, newName);
                var __arg1 = __basicString1.__Instance;
                __Internal.CloneSheet(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void SetSheetIndex(string sheetName, uint index)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetSheetIndex(__Instance, __arg0, index);
                __basicString0.Dispose();
            }

            public uint IndexOfSheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.IndexOfSheet(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.XLSheetType TypeOfSheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.TypeOfSheet(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.XLSheetType TypeOfSheet(uint index)
            {
                var ___ret = __Internal.TypeOfSheet(__Instance, index);
                return ___ret;
            }

            public bool SheetExists(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SheetExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool WorksheetExists(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.WorksheetExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool ChartsheetExists(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.ChartsheetExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public void UpdateSheetReferences(string oldName, string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, oldName);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, newName);
                var __arg1 = __basicString1.__Instance;
                __Internal.UpdateSheetReferences(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void DeleteNamedRanges()
            {
                __Internal.DeleteNamedRanges(__Instance);
            }

            /// <summary>set a flag to force full calculation upon loading the file in Excel</summary>
            public void SetFullCalculationOnLoad()
            {
                __Internal.SetFullCalculationOnLoad(__Instance);
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLWorkbook(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLWorkbook(xmlData);
            }

            public uint SheetCount
            {
                get
                {
                    var ___ret = __Internal.SheetCount(__Instance);
                    return ___ret;
                }
            }

            public uint WorksheetCount
            {
                get
                {
                    var ___ret = __Internal.WorksheetCount(__Instance);
                    return ___ret;
                }
            }

            public uint ChartsheetCount
            {
                get
                {
                    var ___ret = __Internal.ChartsheetCount(__Instance);
                    return ___ret;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLSharedStrings SharedStrings
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal();
                    __Internal.SharedStrings(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLSharedStrings.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public bool HasSharedStrings
            {
                get
                {
                    var ___ret = __Internal.HasSharedStrings(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLXmlSavingDeclaration class encapsulates the properties of an XML saving declaration,</para>
        /// <para>that can be used in calls to XLXmlData::getRawData to enforce specific settings</para>
        /// </summary>
        public unsafe partial class XLXmlSavingDeclaration : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public partial struct __Internal
            {
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_version;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_encoding;
                internal byte m_standalone;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlSavingDeclaration@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlSavingDeclaration@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlSavingDeclaration@OpenXLSX@@QEAA@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr version, __IntPtr encoding, bool standalone);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLXmlSavingDeclaration@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?version@XLXmlSavingDeclaration@OpenXLSX@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Version(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?encoding@XLXmlSavingDeclaration@OpenXLSX@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Encoding(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?standalone_as_bool@XLXmlSavingDeclaration@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool StandaloneAsBool(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?standalone@XLXmlSavingDeclaration@OpenXLSX@@QEBA?BV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Standalone(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLXmlSavingDeclaration __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLXmlSavingDeclaration(native.ToPointer(), skipVTables);
            }

            internal static XLXmlSavingDeclaration __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLXmlSavingDeclaration)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLXmlSavingDeclaration __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLXmlSavingDeclaration(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLXmlSavingDeclaration(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLXmlSavingDeclaration(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLXmlSavingDeclaration()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLXmlSavingDeclaration(global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public XLXmlSavingDeclaration(string version, string encoding, bool standalone)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, version);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, encoding);
                var __arg1 = __basicString1.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, standalone);
                __basicString0.Dispose(disposing: true, callNativeDtor:false);
                __basicString1.Dispose(disposing: true, callNativeDtor:false);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>: getter functions: version, encoding, standalone</summary>
            public string Version
            {
                get
                {
                    var ___ret = __Internal.Version(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }
            }

            public string Encoding
            {
                get
                {
                    var ___ret = __Internal.Encoding(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }
            }

            public bool StandaloneAsBool
            {
                get
                {
                    var ___ret = __Internal.StandaloneAsBool(__Instance);
                    return ___ret;
                }
            }

            public string Standalone
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Standalone(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>
        /// <para>The XLXmlData class encapsulates the properties and behaviour of the .xml files in an .xlsx file zip</para>
        /// <para>package. Objects of the XLXmlData type are intended to be stored centrally in an XLDocument object, from where</para>
        /// <para>they can be retrieved by other objects that encapsulates the behaviour of Excel elements, such as XLWorkbook</para>
        /// <para>and XLWorksheet.</para>
        /// </summary>
        public unsafe partial class XLXmlData : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public partial struct __Internal
            {
                internal __IntPtr m_parentDoc;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_xmlPath;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_xmlID;
                internal global::OpenXLSX.OpenXLSX.XLContentType m_xmlType;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_document___N_std_S_default_delete__S0_ m_xmlDoc;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlData@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlData@OpenXLSX@@QEAA@PEAVXLDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1W4XLContentType@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr parentDoc, __IntPtr xmlPath, __IntPtr xmlId, global::OpenXLSX.OpenXLSX.XLContentType xmlType);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLXmlData@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRawData@XLXmlData@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRawData(__IntPtr __instance, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getRawData@XLXmlData@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@VXLXmlSavingDeclaration@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetRawData(__IntPtr __instance, __IntPtr @return, __IntPtr savingDeclaration);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getParentDoc@XLXmlData@OpenXLSX@@QEAAPEAVXLDocument@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParentDoc(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlPath@XLXmlData@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetXmlPath(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlID@XLXmlData@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetXmlID(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlType@XLXmlData@OpenXLSX@@QEBA?AW4XLContentType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLContentType GetXmlType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlDocument@XLXmlData@OpenXLSX@@QEAAPEAVOpenXLSX_xml_document@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetXmlDocument(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlData> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlData>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLXmlData managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLXmlData managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLXmlData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLXmlData(native.ToPointer(), skipVTables);
            }

            internal static XLXmlData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLXmlData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLXmlData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLXmlData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLXmlData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLXmlData(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>
            /// <para>Default constructor. All member variables are default constructed. Except for</para>
            /// <para>the raw XML data, none of the member variables can be modified after construction. Hence, objects created</para>
            /// <para>using the default constructor can only serve as null objects and targets for the move assignemnt operator.</para>
            /// </summary>
            public XLXmlData()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>
            /// <para>Constructor. This constructor creates objects with the given parameters. the xmlId and the xmlType</para>
            /// <para>parameters have default values. These are only useful for relationship (.rels) files and the</para>
            /// <para>[Content_Types].xml file located in the root directory of the zip package.</para>
            /// </summary>
            /// <param name="parentDoc">A pointer to the parent XLDocument object.</param>
            /// <param name="xmlPath">A std::string with the file path in zip package.</param>
            /// <param name="xmlId">A std::string with the relationship ID of the file (used in the XLRelationships class)</param>
            /// <param name="xmlType">The type of object the XML file represents, e.g. XLWorkbook or XLWorksheet.</param>
            public XLXmlData(global::OpenXLSX.OpenXLSX.XLDocument parentDoc, string xmlPath, string xmlId, global::OpenXLSX.OpenXLSX.XLContentType xmlType)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = parentDoc is null ? __IntPtr.Zero : parentDoc.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, xmlPath);
                var __arg1 = __basicString1.__Instance;
                var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString2, xmlId);
                var __arg2 = __basicString2.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, __arg2, xmlType);
                __basicString1.Dispose();
                __basicString2.Dispose();
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Set the raw data for the underlying XML document. Being able to set the XML data directly is useful</para>
            /// <para>when creating a new file using a XML file template. E.g., when creating a new worksheet, the XML code for</para>
            /// <para>a minimum viable XLWorksheet object can be added using this function.</para>
            /// </summary>
            /// <param name="data">A std::string with the raw XML text.</param>
            public void SetRawData(string data)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, data);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetRawData(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>
            /// <para>Get the raw data for the underlying XML document. This function will retrieve the raw XML text data</para>
            /// <para>from the underlying XMLDocument object. This will mainly be used when saving data to the .xlsx package</para>
            /// <para>using the save function in the XLDocument class.</para>
            /// </summary>
            /// <param name="savingDeclaration">specify an XML saving declaration to use</param>
            /// <returns>A std::string with the raw XML text data.</returns>
            public string GetRawData(global::OpenXLSX.OpenXLSX.XLXmlSavingDeclaration savingDeclaration)
            {
                if (ReferenceEquals(savingDeclaration, null))
                    throw new global::System.ArgumentNullException("savingDeclaration", "Cannot be null because it is passed by value.");
                var __arg0 = savingDeclaration.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetRawData(__Instance, new IntPtr(&___ret), __arg0);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Access the parent XLDocument object.</summary>
            /// <returns>A pointer to the parent XLDocument object.</returns>
            public global::OpenXLSX.OpenXLSX.XLDocument ParentDoc
            {
                get
                {
                    var ___ret = __Internal.GetParentDoc(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLDocument.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Retrieve the path of the XML data in the .xlsx zip archive.</summary>
            /// <returns>A std::string with the path.</returns>
            public string XmlPath
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetXmlPath(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Retrieve the relationship ID of the XML file.</summary>
            /// <returns>A std::string with the relationship ID.</returns>
            public string XmlID
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetXmlID(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Retrieve the type represented by the XML data.</summary>
            /// <returns>A XLContentType getValue representing the type.</returns>
            public global::OpenXLSX.OpenXLSX.XLContentType XmlType
            {
                get
                {
                    var ___ret = __Internal.GetXmlType(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Access the underlying XMLDocument object.</summary>
            /// <returns>A pointer to the XMLDocument object.</returns>
            public global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document XmlDocument
            {
                get
                {
                    var ___ret = __Internal.GetXmlDocument(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.OpenXLSX_xml_document.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class XLXmlData
        {
            public partial struct __Internal
            {
            }

            public const bool XLXmlNotStandalone = false;
            public const string XLXmlDefaultVersion = "1.0";
            public const string XLXmlDefaultEncoding = "UTF-8";
            public const bool XLXmlStandalone = true;        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLZipArchive : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal global::Std.SharedPtr.__Internal m_archive;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLZipArchive@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLZipArchive@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLZipArchive@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?open@XLZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Open(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?close@XLZipArchive@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Close(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?save@XLZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Save(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addEntry@XLZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddEntry(__IntPtr __instance, __IntPtr name, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteEntry@XLZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteEntry(__IntPtr __instance, __IntPtr entryName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getEntry@XLZipArchive@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetEntry(__IntPtr __instance, __IntPtr @return, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasEntry@XLZipArchive@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasEntry(__IntPtr __instance, __IntPtr entryName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isValid@XLZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isOpen@XLZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsOpen(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLZipArchive> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLZipArchive>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLZipArchive managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLZipArchive managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLZipArchive __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLZipArchive(native.ToPointer(), skipVTables);
            }

            internal static XLZipArchive __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLZipArchive)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLZipArchive __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLZipArchive(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLZipArchive.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLZipArchive(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLZipArchive(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLZipArchive()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLZipArchive.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLZipArchive(global::OpenXLSX.OpenXLSX.XLZipArchive other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLZipArchive.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLZipArchive __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            public void Open(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Open(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void Close()
            {
                __Internal.Close(__Instance);
            }

            public void Save(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                __Internal.Save(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void AddEntry(string name, string data)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, data);
                var __arg1 = __basicString1.__Instance;
                __Internal.AddEntry(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void DeleteEntry(string entryName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, entryName);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteEntry(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public string GetEntry(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetEntry(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public bool HasEntry(string entryName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, entryName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.HasEntry(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool IsValid
            {
                get
                {
                    var ___ret = __Internal.IsValid(__Instance);
                    return ___ret;
                }
            }

            public bool IsOpen
            {
                get
                {
                    var ___ret = __Internal.IsOpen(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace Zippy
    {
        public unsafe partial class ZipArchive
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Zippy.ZipArchive> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Zippy.ZipArchive>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.Zippy.ZipArchive managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.Zippy.ZipArchive managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ZipArchive __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ZipArchive(native.ToPointer(), skipVTables);
            }

            internal static ZipArchive __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ZipArchive)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ZipArchive __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ZipArchive(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZipArchive(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ZipArchive(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLRow class represent a row in an Excel spreadsheet. Using XLRow objects, various row formatting</para>
        /// <para>options can be set and modified.</para>
        /// </summary>
        public unsafe partial class XLRow : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_rowNode;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal global::OpenXLSX.OpenXLSX.XLRowDataProxy.__Internal m_rowDataProxy;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRow@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRow@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@AEBVXLSharedStrings@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr rowNode, __IntPtr sharedStrings);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRow@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRow@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHeight@XLRow@OpenXLSX@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeight(__IntPtr __instance, float height);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cells@XLRow@OpenXLSX@@QEBA?AVXLRowDataRange@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cells(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cells@XLRow@OpenXLSX@@QEBA?AVXLRowDataRange@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cells(__IntPtr __instance, __IntPtr @return, ushort cellCount);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cells@XLRow@OpenXLSX@@QEBA?AVXLRowDataRange@2@GG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cells(__IntPtr __instance, __IntPtr @return, ushort firstCell, ushort lastCell);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?findCell@XLRow@OpenXLSX@@QEBA?AVXLCell@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void FindCell(__IntPtr __instance, __IntPtr @return, ushort columNumber);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFormat@XLRow@OpenXLSX@@QEAA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetFormat(__IntPtr __instance, ulong cellFormatIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??MOpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLess(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??OOpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreater(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??NOpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??POpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?height@XLRow@OpenXLSX@@QEBANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Height(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?descent@XLRow@OpenXLSX@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float Descent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setDescent@XLRow@OpenXLSX@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDescent(__IntPtr __instance, float descent);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isHidden@XLRow@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsHidden(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHidden@XLRow@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHidden(__IntPtr __instance, bool state);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowNumber@XLRow@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint RowNumber(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellCount@XLRow@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort CellCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?values@XLRow@OpenXLSX@@QEAAAEAVXLRowDataProxy@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Values(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?format@XLRow@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Format(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRow> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRow>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRow managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRow managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRow __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRow(native.ToPointer(), skipVTables);
            }

            internal static XLRow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRow)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRow __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRow(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRow.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRow(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRow(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor</summary>
            public XLRow()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRow.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLRow(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node rowNode, global::OpenXLSX.OpenXLSX.XLSharedStrings sharedStrings)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRow.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(rowNode, null))
                    throw new global::System.ArgumentNullException("rowNode", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rowNode.__Instance;
                if (ReferenceEquals(sharedStrings, null))
                    throw new global::System.ArgumentNullException("sharedStrings", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = sharedStrings.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
            }

            /// <summary>Copy Constructor</summary>
            /// <remarks>The copy constructor is explicitly deleted</remarks>
            public XLRow(global::OpenXLSX.OpenXLSX.XLRow other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRow.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set the height of the row.</summary>
            /// <param name="height">The height of the row.</param>
            public void SetHeight(float height)
            {
                __Internal.SetHeight(__Instance, height);
            }

            public global::OpenXLSX.OpenXLSX.XLRowDataRange Cells()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal();
                __Internal.Cells(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowDataRange Cells(ushort cellCount)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal();
                __Internal.Cells(__Instance, new IntPtr(&___ret), cellCount);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowDataRange Cells(ushort firstCell, ushort lastCell)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal();
                __Internal.Cells(__Instance, new IntPtr(&___ret), firstCell, lastCell);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Find a cell at columNumber, or return an empty cell</summary>
            /// <param name="columNumber">The column at which to check for an existing cell</param>
            /// <returns>An XLCell object (that bool-evaluates to false if cell was not found)</returns>
            public global::OpenXLSX.OpenXLSX.XLCell FindCell(ushort columNumber)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCell.__Internal();
                __Internal.FindCell(__Instance, new IntPtr(&___ret), columNumber);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCell.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::OpenXLSX.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Set the row style as a reference to the array index of xl/styles.xml:&gt;:&gt;</summary>
            /// <param name="cellFormatIndex">The style to set, corresponding to the index of XLStyles::cellStyles()</param>
            /// <remarks>true on success, false on failure</remarks>
            public bool SetFormat(ulong cellFormatIndex)
            {
                var ___ret = __Internal.SetFormat(__Instance, cellFormatIndex);
                return ___ret;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLRow;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLRow.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator <(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLess(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator >(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreater(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator <=(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLessEqual(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator >=(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Get the height of the row.</summary>
            /// <returns>the row height.</returns>
            public double Height
            {
                get
                {
                    var ___ret = __Internal.Height(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Get the descent of the row, which is the vertical distance in pixels from the bottom of the cells</para>
            /// <para>in the current row to the typographical baseline of the cell content.</para>
            /// </summary>
            /// <param name="descent">The row descent.</param>
            /// <returns>
            /// <para>The row descent.</para>
            /// <para>Set the descent of the row, which is he vertical distance in pixels from the bottom of the cells</para>
            /// <para>in the current row to the typographical baseline of the cell content.</para>
            /// </returns>
            public float Descent
            {
                get
                {
                    var ___ret = __Internal.Descent(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDescent(__Instance, value);
                }
            }

            /// <summary>Is the row hidden?</summary>
            /// <param name="state">The state of the row.</param>
            /// <returns>
            /// <para>The state of the row.</para>
            /// <para>Set the row to be hidden or visible.</para>
            /// </returns>
            public bool Hidden
            {
                get
                {
                    var ___ret = __Internal.IsHidden(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHidden(__Instance, value);
                }
            }

            public uint RowNumber
            {
                get
                {
                    var ___ret = __Internal.RowNumber(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the number of cells in the row.</summary>
            /// <returns>The number of cells in the row.</returns>
            public ushort CellCount
            {
                get
                {
                    var ___ret = __Internal.CellCount(__Instance);
                    return ___ret;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLRowDataProxy Values
            {
                get
                {
                    var ___ret = __Internal.Values(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLRowDataProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>Get the array index of xl/styles.xml:&gt;:&gt; for the style assigned to the row.</para>
            /// <para>This value is stored in the row attributes like so: s=&quot;2&quot;</para>
            /// </summary>
            /// <param name="cellFormatIndex">The style to set, corresponding to the index of XLStyles::cellStyles()</param>
            /// <remarks>
            /// <para>The index of the applicable format style</para>
            /// <para>Set the row style as a reference to the array index of xl/styles.xml:&gt;:&gt;</para>
            /// <para>true on success, false on failure</para>
            /// </remarks>
            public ulong Format
            {
                get
                {
                    var ___ret = __Internal.Format(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFormat(__Instance, value);
                }
            }
        }

        public unsafe partial class XLRowIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_dataNode;
                internal uint m_firstRow;
                internal uint m_lastRow;
                internal global::OpenXLSX.OpenXLSX.XLRow.__Internal m_currentRow;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowIterator@OpenXLSX@@QEAA@AEBVXLRowRange@1@W4XLIteratorLocation@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr rowRange, global::OpenXLSX.OpenXLSX.XLIteratorLocation loc);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowIterator@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowIterator@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??EXLRowIterator@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorPlusPlus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8XLRowIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9XLRowIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLRowIterator@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowIterator(native.ToPointer(), skipVTables);
            }

            internal static XLRowIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRowIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLRowIterator(global::OpenXLSX.OpenXLSX.XLRowRange rowRange, global::OpenXLSX.OpenXLSX.XLIteratorLocation loc)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(rowRange, null))
                    throw new global::System.ArgumentNullException("rowRange", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rowRange.__Instance;
                __Internal.ctor(__Instance, __arg0, loc);
            }

            public XLRowIterator(global::OpenXLSX.OpenXLSX.XLRowIterator other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::OpenXLSX.OpenXLSX.XLRowIterator operator ++(global::OpenXLSX.OpenXLSX.XLRowIterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorPlusPlus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLRowIterator.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLRowIterator __op, global::OpenXLSX.OpenXLSX.XLRowIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return __opNull && rhsNull;
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLRowIterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLRowIterator __op, global::OpenXLSX.OpenXLSX.XLRowIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return !(__opNull && rhsNull);
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLRowIterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }
        }

        public unsafe partial class XLRowRange : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_dataNode;
                internal uint m_firstRow;
                internal uint m_lastRow;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowRange@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@IIAEBVXLSharedStrings@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr dataNode, uint first, uint last, __IntPtr sharedStrings);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowRange@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowRange@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?begin@XLRowRange@OpenXLSX@@QEAA?AVXLRowIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Begin(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?end@XLRowRange@OpenXLSX@@QEAA?AVXLRowIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowCount@XLRowRange@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint RowCount(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowRange> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowRange>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowRange managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowRange managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowRange __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowRange(native.ToPointer(), skipVTables);
            }

            internal static XLRowRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowRange)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowRange __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowRange(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRowRange.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRowRange(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowRange(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLRowRange(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node dataNode, uint first, uint last, global::OpenXLSX.OpenXLSX.XLSharedStrings sharedStrings)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(dataNode, null))
                    throw new global::System.ArgumentNullException("dataNode", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = dataNode.__Instance;
                if (ReferenceEquals(sharedStrings, null))
                    throw new global::System.ArgumentNullException("sharedStrings", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = sharedStrings.__Instance;
                __Internal.ctor(__Instance, __arg0, first, last, __arg3);
            }

            public XLRowRange(global::OpenXLSX.OpenXLSX.XLRowRange other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::OpenXLSX.OpenXLSX.XLRowIterator Begin()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal();
                __Internal.Begin(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowIterator End()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal();
                __Internal.End(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public uint RowCount
            {
                get
                {
                    var ___ret = __Internal.RowCount(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>This class encapsulates a (non-const) iterator, for iterating over the cells in a row.</summary>
        /// <remarks>Consider implementing a const iterator also</remarks>
        public unsafe partial class XLRowDataIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLRowDataRange___N_std_S_default_delete__S0_ m_dataRange;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_cellNode;
                internal global::OpenXLSX.OpenXLSX.XLCell.__Internal m_currentCell;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowDataIterator@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowDataIterator@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??EXLRowDataIterator@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorPlusPlus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8XLRowDataIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9XLRowDataIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr __instance, __IntPtr rhs);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowDataIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowDataIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowDataIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowDataIterator(native.ToPointer(), skipVTables);
            }

            internal static XLRowDataIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowDataIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowDataIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowDataIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRowDataIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowDataIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLRowDataIterator(global::OpenXLSX.OpenXLSX.XLRowDataIterator other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Pre-increment of the iterator.</summary>
            /// <returns>Reference to the iterator object.</returns>
            public static global::OpenXLSX.OpenXLSX.XLRowDataIterator operator ++(global::OpenXLSX.OpenXLSX.XLRowDataIterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorPlusPlus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLRowDataIterator.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Equality operator.</summary>
            /// <param name="rhs">XLRowDataIterator to compare to.</param>
            /// <returns>true if equal, otherwise false.</returns>
            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLRowDataIterator __op, global::OpenXLSX.OpenXLSX.XLRowDataIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return __opNull && rhsNull;
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLRowDataIterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal*) __Instance).GetHashCode();
            }

            /// <summary>Non-equality operator.</summary>
            /// <param name="rhs">XLRowDataIterator to compare to.</param>
            /// <returns>false if equal, otherwise true.</returns>
            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLRowDataIterator __op, global::OpenXLSX.OpenXLSX.XLRowDataIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return !(__opNull && rhsNull);
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>This class encapsulates the concept of a contiguous range of cells in a row.</summary>
        public unsafe partial class XLRowDataRange : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_rowNode;
                internal ushort m_firstCol;
                internal ushort m_lastCol;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowDataRange@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowDataRange@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?begin@XLRowDataRange@OpenXLSX@@QEAA?AVXLRowDataIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Begin(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?end@XLRowDataRange@OpenXLSX@@QEAA?AVXLRowDataIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?size@XLRowDataRange@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort Size(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataRange> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataRange>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowDataRange managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowDataRange managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowDataRange __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowDataRange(native.ToPointer(), skipVTables);
            }

            internal static XLRowDataRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowDataRange)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowDataRange __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowDataRange(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRowDataRange(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowDataRange(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLRowDataRange(global::OpenXLSX.OpenXLSX.XLRowDataRange other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get an iterator to the first element.</summary>
            /// <returns>An XLRowDataIterator pointing to the first element.</returns>
            public global::OpenXLSX.OpenXLSX.XLRowDataIterator Begin()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal();
                __Internal.Begin(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get an iterator to (one-past) the last element.</summary>
            /// <returns>An XLRowDataIterator pointing to (one past) the last element.</returns>
            public global::OpenXLSX.OpenXLSX.XLRowDataIterator End()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal();
                __Internal.End(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the size (length) of the range.</summary>
            /// <returns>The size of the range.</returns>
            public ushort Size
            {
                get
                {
                    var ___ret = __Internal.Size(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>The XLRowDataProxy is used as a proxy object when getting or setting row data. The class facilitates easy conversion</para>
        /// <para>to/from containers.</para>
        /// </summary>
        public unsafe partial class XLRowDataProxy : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr m_row;
                internal __IntPtr m_rowNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowDataProxy@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLRowDataProxy@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataProxy> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataProxy>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowDataProxy managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowDataProxy managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowDataProxy __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowDataProxy(native.ToPointer(), skipVTables);
            }

            internal static XLRowDataProxy __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowDataProxy)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowDataProxy __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowDataProxy(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLRowDataProxy(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowDataProxy(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Clears all values for the current row.</summary>
            public void Clear()
            {
                __Internal.Clear(__Instance);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>The XLSheetState is an enumeration of the possible (visibility) states, e.g. Visible or Hidden.</summary>
        public enum XLSheetState : byte
        {
            Visible = 0,
            Hidden = 1,
            VeryHidden = 2
        }

        namespace XLSheetBase
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public unsafe partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setActive@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetActivec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clone@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clonec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?visibility@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEBA?AW4XLSheetState@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLSheetState Visibilityc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setVisibility@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAAXW4XLSheetState@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVisibilityc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLSheetState state);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?color@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEBA?AVXLColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Colorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColor@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAAXAEBVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, __IntPtr color);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?index@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort Indexc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setIndex@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, ushort index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Namec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setName@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNamec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isSelected@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSelectedc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSelected@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSelectedc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance, bool selected);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isActive@?$XLSheetBase@VXLWorksheet@OpenXLSX@@X@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsActivec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clone@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clonec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?visibility@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEBA?AW4XLSheetState@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLSheetState Visibilityc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setVisibility@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAAXW4XLSheetState@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVisibilityc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLSheetState state);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?color@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEBA?AVXLColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Colorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColor@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAAXAEBVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, __IntPtr color);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?index@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort Indexc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setIndex@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, ushort index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Namec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setName@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNamec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isSelected@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSelectedc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSelected@?$XLSheetBase@VXLChartsheet@OpenXLSX@@X@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSelectedc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__IntPtr __instance, bool selected);
            }
        }

        /// <summary>
        /// <para>The XLSheetBase class is the base class for the XLWorksheet and XLChartsheet classes. However,</para>
        /// <para>it is not a base class in the traditional sense. Rather, it provides common functionality that is</para>
        /// <para>inherited via the CRTP (Curiously Recurring Template Pattern) pattern.</para>
        /// </summary>
        public unsafe partial class XLSheetBase<T, > : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            internal static new XLSheetBase<T, > __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLSheetBase<T, >(native.ToPointer(), skipVTables);
            }

            internal static new XLSheetBase<T, > __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLSheetBase<T, >)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLSheetBase<T, > __CreateInstance(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal native, bool skipVTables = false)
            {
                return new XLSheetBase<T, >(native, skipVTables);
            }

            private static void* __CopyValue(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal));
                *(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLSheetBase(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLSheetBase(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Constructor</summary>
            public XLSheetBase()
                : this((void*) null)
            {
                var __T = typeof(T);
                var __ = typeof();
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.ctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.ctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance);
                    return;
                }
                throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
            }

            /// <summary>
            /// <para>The constructor. There are no default constructor, so all parameters must be provided for</para>
            /// <para>constructing an XLAbstractSheet object. Since this is a pure abstract class, instantiation is only</para>
            /// <para>possible via one of the derived classes.</para>
            /// </summary>
            public XLSheetBase(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                var __T = typeof(T);
                var __ = typeof();
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                    global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.ctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, __arg0);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                    global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.ctorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, __arg0);
                    return;
                }
                throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
            }

            /// <summary>The copy constructor.</summary>
            /// <param name="other">The object to be copied.</param>
            /// <remarks>The default copy constructor is used, i.e. only shallow copying of pointer data members.</remarks>
            public XLSheetBase(global::OpenXLSX.OpenXLSX.XLSheetBase<T, > other)
                : this((void*) null)
            {
                var __T = typeof(T);
                var __ = typeof();
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal*) other.__Instance);
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal*) other.__Instance);
                    return;
                }
                throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.dtorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.dtorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance);
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public bool SetActive()
            {
                var __T = typeof(T);
                var __ = typeof();
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    var ___ret = global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetActivec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance);
                    return ___ret;
                }
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    throw new MissingMethodException("Method SetActive ignored in specialization global::OpenXLSX.OpenXLSX.XLSheetBase<global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }
                throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
            }

            /// <summary>Method for cloning the sheet.</summary>
            /// <param name="newName">A std::string with the name of the clone</param>
            /// <returns>A pointer to the cloned object.</returns>
            /// <remarks>This is a pure abstract method. I.e. it is implemented in subclasses.</remarks>
            public void Clone(string newName)
            {
                var __T = typeof(T);
                var __ = typeof();
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, newName);
                    var __arg0 = __basicString0.__Instance;
                    global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Clonec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, __arg0);
                    __basicString0.Dispose();
                    return;
                }
                if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, newName);
                    var __arg0 = __basicString0.__Instance;
                    global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Clonec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, __arg0);
                    __basicString0.Dispose();
                    return;
                }
                throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLSheetBase<T, >(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLSheetBase<T, >(xmlData);
            }

            public global::OpenXLSX.OpenXLSX.XLSheetState Visibility
            {
                get
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Visibilityc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Visibilityc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance);
                        return ___ret;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }

                set
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetVisibilityc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, value);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetVisibilityc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, value);
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }
            }

            /// <remarks>To be implemented.</remarks>
            public global::OpenXLSX.OpenXLSX.XLColor Color
            {
                get
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = new global::OpenXLSX.OpenXLSX.XLColor.__Internal();
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Colorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, new IntPtr(&___ret));
                        var _____ret = global::OpenXLSX.OpenXLSX.XLColor.__CreateInstance(___ret);
                        global::OpenXLSX.OpenXLSX.XLColor.__Internal.dtor(new __IntPtr(&___ret));
                        return _____ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = new global::OpenXLSX.OpenXLSX.XLColor.__Internal();
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Colorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, new IntPtr(&___ret));
                        var _____ret = global::OpenXLSX.OpenXLSX.XLColor.__CreateInstance(___ret);
                        global::OpenXLSX.OpenXLSX.XLColor.__Internal.dtor(new __IntPtr(&___ret));
                        return _____ret;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }

                set
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = value.__Instance;
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetColorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, __arg0);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = value.__Instance;
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetColorc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, __arg0);
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }
            }

            public ushort Index
            {
                get
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Indexc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Indexc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance);
                        return ___ret;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }

                set
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetIndexc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, value);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetIndexc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, value);
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }
            }

            /// <summary>Method to retrieve the name of the sheet.</summary>
            /// <param name="sheetName">A std::string with the new name.</param>
            /// <returns>
            /// <para>A std::string with the sheet name.</para>
            /// <para>Method for renaming the sheet.</para>
            /// </returns>
            public string Name
            {
                get
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Namec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, new IntPtr(&___ret));
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                        var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                        __basicStringRet0.Dispose();
                        return __retString0;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.Namec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, new IntPtr(&___ret));
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                        var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                        __basicStringRet0.Dispose();
                        return __retString0;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }

                set
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                        global::Std.BasicStringExtensions.Assign(__basicString0, value);
                        var __arg0 = __basicString0.__Instance;
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetNamec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, __arg0);
                        __basicString0.Dispose();
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                        global::Std.BasicStringExtensions.Assign(__basicString0, value);
                        var __arg0 = __basicString0.__Instance;
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetNamec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, __arg0);
                        __basicString0.Dispose();
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }
            }

            public bool Selected
            {
                get
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.IsSelectedc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.IsSelectedc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance);
                        return ___ret;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }

                set
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetSelectedc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance, value);
                        return;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.SetSelectedc__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLChartsheet_v(__Instance, value);
                        return;
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }
            }

            public bool IsActive
            {
                get
                {
                    var __T = typeof(T);
                    var __ = typeof();
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLWorksheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        var ___ret = global::OpenXLSX.OpenXLSX.XLSheetBase.__Internal.IsActivec__N_OpenXLSX_S_XLSheetBase____N_OpenXLSX_S_XLWorksheet_v(__Instance);
                        return ___ret;
                    }
                    if (__T.IsAssignableFrom(typeof(global::OpenXLSX.OpenXLSX.XLChartsheet)) && __.IsAssignableFrom(typeof(void)))
                    {
                        throw new MissingMethodException("Method IsActive missing from explicit specialization global::OpenXLSX.OpenXLSX.XLSheetBase<global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                    }
                    throw new ArgumentOutOfRangeException("T, ", string.Join(", ", new[] { typeof(T).FullName, typeof().FullName }), "global::OpenXLSX.OpenXLSX.XLSheetBase<T, > maps a C++ template class and therefore it only supports a limited set of types and their subclasses: <global::OpenXLSX.OpenXLSX.XLWorksheet, object>, <global::OpenXLSX.OpenXLSX.XLChartsheet, object>.");
                }
            }
        }

        /// <summary>A class encapsulating an Excel worksheet. Access to XLWorksheet objects should be via the workbook object.</summary>
        public unsafe partial class XLWorksheet : global::OpenXLSX.OpenXLSX.XLSheetBase<global::OpenXLSX.OpenXLSX.XLWorksheet, object>, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public partial struct __Internal
            {
                internal __IntPtr m_xmlData;
                internal global::OpenXLSX.OpenXLSX.XLMergeCells.__Internal m_merges;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorksheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorksheet@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorksheet@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLWorksheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cell@XLWorksheet@OpenXLSX@@QEBA?AVXLCellAssignable@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cell(__IntPtr __instance, __IntPtr @return, __IntPtr @ref);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cell@XLWorksheet@OpenXLSX@@QEBA?AVXLCellAssignable@2@AEBVXLCellReference@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cell_1(__IntPtr __instance, __IntPtr @return, __IntPtr @ref);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cell@XLWorksheet@OpenXLSX@@QEBA?AVXLCellAssignable@2@IG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cell(__IntPtr __instance, __IntPtr @return, uint rowNumber, ushort columnNumber);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?range@XLWorksheet@OpenXLSX@@QEBA?AVXLCellRange@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Range(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?range@XLWorksheet@OpenXLSX@@QEBA?AVXLCellRange@2@AEBVXLCellReference@2@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Range(__IntPtr __instance, __IntPtr @return, __IntPtr topLeft, __IntPtr bottomRight);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?range@XLWorksheet@OpenXLSX@@QEBA?AVXLCellRange@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Range_1(__IntPtr __instance, __IntPtr @return, __IntPtr topLeft, __IntPtr bottomRight);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?range@XLWorksheet@OpenXLSX@@QEBA?AVXLCellRange@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Range(__IntPtr __instance, __IntPtr @return, __IntPtr rangeReference);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rows@XLWorksheet@OpenXLSX@@QEBA?AVXLRowRange@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rows(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rows@XLWorksheet@OpenXLSX@@QEBA?AVXLRowRange@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rows(__IntPtr __instance, __IntPtr @return, uint rowCount);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rows@XLWorksheet@OpenXLSX@@QEBA?AVXLRowRange@2@II@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rows(__IntPtr __instance, __IntPtr @return, uint firstRow, uint lastRow);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?row@XLWorksheet@OpenXLSX@@QEBA?AVXLRow@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Row(__IntPtr __instance, __IntPtr @return, uint rowNumber);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?column@XLWorksheet@OpenXLSX@@QEBA?AVXLColumn@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Column(__IntPtr __instance, __IntPtr @return, ushort columnNumber);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?column@XLWorksheet@OpenXLSX@@QEBA?AVXLColumn@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Column(__IntPtr __instance, __IntPtr @return, __IntPtr columnRef);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?updateSheetName@XLWorksheet@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateSheetName(__IntPtr __instance, __IntPtr oldName, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?mergeCells@XLWorksheet@OpenXLSX@@QEAAXAEBVXLCellRange@2@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void MergeCells(__IntPtr __instance, __IntPtr rangeToMerge, bool emptyHiddenCells);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?mergeCells@XLWorksheet@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void MergeCells_1(__IntPtr __instance, __IntPtr rangeReference, bool emptyHiddenCells);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?unmergeCells@XLWorksheet@OpenXLSX@@QEAAXAEBVXLCellRange@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UnmergeCells(__IntPtr __instance, __IntPtr rangeToUnmerge);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?unmergeCells@XLWorksheet@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UnmergeCells_1(__IntPtr __instance, __IntPtr rangeReference);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getColumnFormat@XLWorksheet@OpenXLSX@@QEBA_KG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetColumnFormat(__IntPtr __instance, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getColumnFormat@XLWorksheet@OpenXLSX@@QEBA_KAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetColumnFormat(__IntPtr __instance, __IntPtr column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColumnFormat@XLWorksheet@OpenXLSX@@QEAA_NG_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetColumnFormat(__IntPtr __instance, ushort column, ulong cellFormatIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColumnFormat@XLWorksheet@OpenXLSX@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetColumnFormat(__IntPtr __instance, __IntPtr column, ulong cellFormatIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getRowFormat@XLWorksheet@OpenXLSX@@QEBA_KG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong GetRowFormat(__IntPtr __instance, ushort row);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRowFormat@XLWorksheet@OpenXLSX@@QEAA_NI_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetRowFormat(__IntPtr __instance, uint row, ulong cellFormatIndex);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?lastCell@XLWorksheet@OpenXLSX@@QEBA?AVXLCellReference@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LastCell(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?columnCount@XLWorksheet@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort ColumnCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowCount@XLWorksheet@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint RowCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?merges@XLWorksheet@OpenXLSX@@QEAAAEAVXLMergeCells@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Merges(__IntPtr __instance);
            }

            internal static new XLWorksheet __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLWorksheet(native.ToPointer(), skipVTables);
            }

            internal static new XLWorksheet __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLWorksheet)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLWorksheet __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLWorksheet(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLWorksheet(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLWorksheet(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Default constructor</summary>
            public XLWorksheet()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLWorksheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            public XLWorksheet(global::OpenXLSX.OpenXLSX.XLWorksheet other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::OpenXLSX.OpenXLSX.XLCellAssignable Cell(string @ref)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, @ref);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellAssignable.__Internal();
                __Internal.Cell(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellAssignable.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::OpenXLSX.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Get an XLCell object for the given cell reference.</summary>
            /// <param name="ref">An XLCellReference object with the address of the cell to get.</param>
            /// <returns>A reference to the requested XLCell object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellAssignable Cell(global::OpenXLSX.OpenXLSX.XLCellReference @ref)
            {
                if (ReferenceEquals(@ref, null))
                    throw new global::System.ArgumentNullException("@ref", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @ref.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellAssignable.__Internal();
                __Internal.Cell_1(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellAssignable.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::OpenXLSX.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Get the cell at the given coordinates.</summary>
            /// <param name="rowNumber">The row number (index base 1).</param>
            /// <param name="columnNumber">The column number (index base 1).</param>
            /// <returns>A reference to the XLCell object at the given coordinates.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellAssignable Cell(uint rowNumber, ushort columnNumber)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellAssignable.__Internal();
                __Internal.Cell(__Instance, new IntPtr(&___ret), rowNumber, columnNumber);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellAssignable.__CreateInstance(___ret);
                var __vtables = new IntPtr[] { *(__IntPtr*) (new __IntPtr(&___ret) + 0) };
                var __slot = *(__IntPtr*) (__vtables[0] + 0 * sizeof(__IntPtr));
                Marshal.GetDelegateForFunctionPointer<global::OpenXLSX.Delegates.Action___IntPtr_int>(__slot)(new __IntPtr(&___ret), 0);
                return _____ret;
            }

            /// <summary>Get a range for the area currently in use (i.e. from cell A1 to the last cell being in use).</summary>
            /// <returns>An XLCellRange object with the entire range.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellRange Range()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellRange.__Internal();
                __Internal.Range(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get a range with the given coordinates.</summary>
            /// <param name="topLeft">An XLCellReference object with the coordinates to the top left cell.</param>
            /// <param name="bottomRight">An XLCellReference object with the coordinates to the bottom right cell.</param>
            /// <returns>An XLCellRange object with the requested range.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellRange Range(global::OpenXLSX.OpenXLSX.XLCellReference topLeft, global::OpenXLSX.OpenXLSX.XLCellReference bottomRight)
            {
                if (ReferenceEquals(topLeft, null))
                    throw new global::System.ArgumentNullException("topLeft", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = topLeft.__Instance;
                if (ReferenceEquals(bottomRight, null))
                    throw new global::System.ArgumentNullException("bottomRight", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = bottomRight.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellRange.__Internal();
                __Internal.Range(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get a range with the given coordinates.</summary>
            /// <param name="topLeft">A std::string that is convertible to an XLCellReference to the top left cell</param>
            /// <param name="bottomRight">A std::string that is convertible to an XLCellReference to the bottom right cell.</param>
            /// <returns>An XLCellRange object with the requested range.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellRange Range(string topLeft, string bottomRight)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, topLeft);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, bottomRight);
                var __arg1 = __basicString1.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellRange.__Internal();
                __Internal.Range_1(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get a range with the given coordinates.</summary>
            /// <param name="rangeReference">
            /// <para>A std::string that contains two XLCellReferences separated by a delimiter ':'</para>
            /// <para>Example &quot;A2:B5&quot;</para>
            /// </param>
            /// <returns>An XLCellRange object with the requested range.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellRange Range(string rangeReference)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, rangeReference);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellRange.__Internal();
                __Internal.Range(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowRange Rows()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowRange.__Internal();
                __Internal.Rows(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowRange Rows(uint rowCount)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowRange.__Internal();
                __Internal.Rows(__Instance, new IntPtr(&___ret), rowCount);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowRange Rows(uint firstRow, uint lastRow)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowRange.__Internal();
                __Internal.Rows(__Instance, new IntPtr(&___ret), firstRow, lastRow);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the row with the given row number.</summary>
            /// <param name="rowNumber">The number of the row to retrieve.</param>
            /// <returns>A reference to the XLRow object.</returns>
            public global::OpenXLSX.OpenXLSX.XLRow Row(uint rowNumber)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRow.__Internal();
                __Internal.Row(__Instance, new IntPtr(&___ret), rowNumber);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRow.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRow.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the column with the given column number.</summary>
            /// <param name="columnNumber">The number of the column to retrieve.</param>
            /// <returns>A reference to the XLColumn object.</returns>
            public global::OpenXLSX.OpenXLSX.XLColumn Column(ushort columnNumber)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLColumn.__Internal();
                __Internal.Column(__Instance, new IntPtr(&___ret), columnNumber);
                var _____ret = global::OpenXLSX.OpenXLSX.XLColumn.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLColumn.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the column with the given column reference</summary>
            /// <param name="columnRef">The letters referencing the given column</param>
            /// <returns>A reference to the XLColumn object.</returns>
            public global::OpenXLSX.OpenXLSX.XLColumn Column(string columnRef)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, columnRef);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLColumn.__Internal();
                __Internal.Column(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLColumn.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLColumn.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public void UpdateSheetName(string oldName, string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, oldName);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, newName);
                var __arg1 = __basicString1.__Instance;
                __Internal.UpdateSheetName(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            /// <summary>merge the cells indicated by range</summary>
            /// <param name="rangeToMerge">the XLCellRange to merge, can be obtained from XLWorksheet::range functions</param>
            /// <param name="emptyHiddenCells">
            /// <para>if true (XLEmptyHiddenCells), the values of hidden cells will be deleted</para>
            /// <para>(only from the cells, not from the shared strings table, if used)</para>
            /// </param>
            /// <remarks>XLInputException if range comprises&lt;2 cells or any cell within rangeToMerge is already part of an existing range</remarks>
            public void MergeCells(global::OpenXLSX.OpenXLSX.XLCellRange rangeToMerge, bool emptyHiddenCells)
            {
                if (ReferenceEquals(rangeToMerge, null))
                    throw new global::System.ArgumentNullException("rangeToMerge", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rangeToMerge.__Instance;
                __Internal.MergeCells(__Instance, __arg0, emptyHiddenCells);
            }

            /// <summary>Convenience wrapper for mergeCells with a std::string range reference</summary>
            /// <param name="rangeReference">A range reference string for the cells to merge</param>
            /// <param name="emptyHiddenCells">as above</param>
            public void MergeCells(string rangeReference, bool emptyHiddenCells)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, rangeReference);
                var __arg0 = __basicString0.__Instance;
                __Internal.MergeCells_1(__Instance, __arg0, emptyHiddenCells);
                __basicString0.Dispose();
            }

            /// <summary>remove the merge setting for the indicated range</summary>
            /// <param name="rangeToUnmerge">the XLCellRange to unmerge, can be obtained from XLWorksheet::range functions</param>
            /// <remarks>XLInputException if no merged range exists that matches rangeToMerge precisely</remarks>
            public void UnmergeCells(global::OpenXLSX.OpenXLSX.XLCellRange rangeToUnmerge)
            {
                if (ReferenceEquals(rangeToUnmerge, null))
                    throw new global::System.ArgumentNullException("rangeToUnmerge", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rangeToUnmerge.__Instance;
                __Internal.UnmergeCells(__Instance, __arg0);
            }

            /// <summary>Convenience wrapper for unmergeCells with a std::string range reference</summary>
            /// <param name="rangeReference">A range reference string for the cells to unmerge</param>
            public void UnmergeCells(string rangeReference)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, rangeReference);
                var __arg0 = __basicString0.__Instance;
                __Internal.UnmergeCells_1(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>
            /// <para>Get the array index of xl/styles.xml:&gt;:&gt; for the style assigned to a column.</para>
            /// <para>This value is stored in the col attributes like so: style=&quot;2&quot;</para>
            /// </summary>
            /// <param name="column">The column letter(s) or index (1-based)</param>
            /// <remarks>The index of the applicable format style</remarks>
            public ulong GetColumnFormat(ushort column)
            {
                var ___ret = __Internal.GetColumnFormat(__Instance, column);
                return ___ret;
            }

            public ulong GetColumnFormat(string column)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, column);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.GetColumnFormat(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>
            /// <para>set the column style as a reference to the array index of xl/styles.xml:&gt;:&gt;</para>
            /// <para>Subsequently, set the same style for all existing(!) cells in that column</para>
            /// </summary>
            /// <param name="column">the column letter(s) or index (1-based)</param>
            /// <param name="cellFormatIndex">the style to set, corresponding to the index of XLStyles::cellStyles()</param>
            /// <remarks>true on success, false on failure</remarks>
            public bool SetColumnFormat(ushort column, ulong cellFormatIndex)
            {
                var ___ret = __Internal.SetColumnFormat(__Instance, column, cellFormatIndex);
                return ___ret;
            }

            public bool SetColumnFormat(string column, ulong cellFormatIndex)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, column);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SetColumnFormat(__Instance, __arg0, cellFormatIndex);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>
            /// <para>get the array index of xl/styles.xml:&gt;:&gt; for the style assigned to a row</para>
            /// <para>this value is stored in the row attributes like so: s=&quot;2&quot;</para>
            /// </summary>
            /// <param name="row">the row index (1-based)</param>
            /// <remarks>the index of the applicable format style</remarks>
            public ulong GetRowFormat(ushort row)
            {
                var ___ret = __Internal.GetRowFormat(__Instance, row);
                return ___ret;
            }

            /// <summary>
            /// <para>set the row style as a reference to the array index of xl/styles.xml:&gt;:&gt;</para>
            /// <para>Subsequently, set the same style for all existing(!) cells in that row</para>
            /// </summary>
            /// <param name="row">the row index (1-based)</param>
            /// <param name="cellFormatIndex">the style to set, corresponding to the index of XLStyles::cellStyles()</param>
            /// <remarks>true on success, false on failure</remarks>
            public bool SetRowFormat(uint row, ulong cellFormatIndex)
            {
                var ___ret = __Internal.SetRowFormat(__Instance, row, cellFormatIndex);
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLWorksheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLWorksheet(xmlData);
            }

            /// <summary>Get an XLCellReference to the last (bottom right) cell in the worksheet.</summary>
            /// <returns>An XLCellReference for the last cell.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellReference LastCell
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLCellReference.__Internal();
                    __Internal.LastCell(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLCellReference.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLCellReference.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the number of columns in the worksheet.</summary>
            /// <returns>The number of columns.</returns>
            public ushort ColumnCount
            {
                get
                {
                    var ___ret = __Internal.ColumnCount(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the number of rows in the worksheet.</summary>
            /// <returns>The number of rows.</returns>
            public uint RowCount
            {
                get
                {
                    var ___ret = __Internal.RowCount(__Instance);
                    return ___ret;
                }
            }

            /// <summary>get an XLMergeCells object to directly access the member functions</summary>
            /// <remarks>an XLMergeCells object for this worksheet</remarks>
            public global::OpenXLSX.OpenXLSX.XLMergeCells Merges
            {
                get
                {
                    var ___ret = __Internal.Merges(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLMergeCells.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        /// <summary>Class representing the an Excel chartsheet.</summary>
        /// <remarks>This class is largely unimplemented and works just as a placeholder.</remarks>
        public unsafe partial class XLChartsheet : global::OpenXLSX.OpenXLSX.XLSheetBase<global::OpenXLSX.OpenXLSX.XLChartsheet, object>, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLChartsheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLChartsheet@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLChartsheet@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLChartsheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            internal static new XLChartsheet __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLChartsheet(native.ToPointer(), skipVTables);
            }

            internal static new XLChartsheet __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLChartsheet)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLChartsheet __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLChartsheet(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLChartsheet(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLChartsheet(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Default constructor</summary>
            public XLChartsheet()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLChartsheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLChartsheet(global::OpenXLSX.OpenXLSX.XLChartsheet other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLChartsheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLChartsheet(xmlData);
            }
        }

        /// <summary>
        /// <para>The XLAbstractSheet is a generalized sheet class, which functions as superclass for specialized classes,</para>
        /// <para>such as XLWorksheet. It implements functionality common to all sheet types. This is a pure abstract class,</para>
        /// <para>so it cannot be instantiated.</para>
        /// </summary>
        public unsafe partial class XLSheet : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;
                internal global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal m_sheet_XL;
                internal global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal m_sheet_Chart;
                internal global::OpenXLSX.OpenXLSX.XLSheetType m_sheetType;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSheet@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSheet@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLSheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clone@XLSheet@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clone(__IntPtr __instance, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLSheet@OpenXLSX@@QEBA?AVXLWorksheet@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLSheet@OpenXLSX@@QEBA?AVXLChartsheet@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion_1(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?visibility@XLSheet@OpenXLSX@@QEBA?AW4XLSheetState@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLSheetState Visibility(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setVisibility@XLSheet@OpenXLSX@@QEAAXW4XLSheetState@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVisibility(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLSheetState state);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?color@XLSheet@OpenXLSX@@QEBA?AVXLColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Color(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColor@XLSheet@OpenXLSX@@QEAAXAEBVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColor(__IntPtr __instance, __IntPtr color);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?index@XLSheet@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort Index(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setIndex@XLSheet@OpenXLSX@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndex(__IntPtr __instance, ushort index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name@XLSheet@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Name(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setName@XLSheet@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isSelected@XLSheet@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsSelected(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSelected@XLSheet@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSelected(__IntPtr __instance, bool selected);
            }

            internal static new XLSheet __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLSheet(native.ToPointer(), skipVTables);
            }

            internal static new XLSheet __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLSheet)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLSheet __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLSheet(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLSheet.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLSheet(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLSheet(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>
            /// <para>The constructor. There are no default constructor, so all parameters must be provided for</para>
            /// <para>constructing an XLAbstractSheet object. Since this is a pure abstract class, instantiation is only</para>
            /// <para>possible via one of the derived classes.</para>
            /// </summary>
            public XLSheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>The copy constructor.</summary>
            /// <param name="other">The object to be copied.</param>
            /// <remarks>The default copy constructor is used, i.e. only shallow copying of pointer data members.</remarks>
            public XLSheet(global::OpenXLSX.OpenXLSX.XLSheet other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Method for cloning the sheet.</summary>
            /// <param name="newName">A std::string with the name of the clone</param>
            /// <returns>A pointer to the cloned object.</returns>
            /// <remarks>This is a pure abstract method. I.e. it is implemented in subclasses.</remarks>
            public void Clone(string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, newName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Clone(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public static implicit operator global::OpenXLSX.OpenXLSX.XLWorksheet(global::OpenXLSX.OpenXLSX.XLSheet __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal();
                __Internal.OperatorConversion(__arg0, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLWorksheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static implicit operator global::OpenXLSX.OpenXLSX.XLChartsheet(global::OpenXLSX.OpenXLSX.XLSheet __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal();
                __Internal.OperatorConversion_1(__arg0, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLChartsheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLSheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLSheet(xmlData);
            }

            public global::OpenXLSX.OpenXLSX.XLWorksheet MSheetXL
            {
                get
                {
                    return global::OpenXLSX.OpenXLSX.XLWorksheet.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_sheet_XL));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_sheet_XL = *(global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal*) value.__Instance;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLChartsheet MSheetChart
            {
                get
                {
                    return global::OpenXLSX.OpenXLSX.XLChartsheet.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->m_sheet_Chart));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->m_sheet_Chart = *(global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal*) value.__Instance;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLSheetType MSheetType
            {
                get
                {
                    return ((__Internal*)__Instance)->m_sheetType;
                }

                set
                {
                    ((__Internal*)__Instance)->m_sheetType = value;
                }
            }

            /// <summary>Method for getting the current visibility state of the sheet.</summary>
            /// <param name="state">An XLSheetState enum object with the new state.</param>
            /// <returns>
            /// <para>An XLSheetState enum object, with the current sheet state.</para>
            /// <para>Method for setting the state of the sheet.</para>
            /// </returns>
            /// <remarks>
            /// <para>For some reason, this method doesn't work. The data is written correctly to the xml file, but the sheet</para>
            /// <para>is not hidden when opening the file in Excel.</para>
            /// </remarks>
            public global::OpenXLSX.OpenXLSX.XLSheetState Visibility
            {
                get
                {
                    var ___ret = __Internal.Visibility(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetVisibility(__Instance, value);
                }
            }

            public global::OpenXLSX.OpenXLSX.XLColor Color
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLColor.__Internal();
                    __Internal.Color(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLColor.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLColor.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetColor(__Instance, __arg0);
                }
            }

            /// <summary>Method for getting the index of the sheet.</summary>
            /// <returns>
            /// <para>An int with the index of the sheet.</para>
            /// <para>Method for setting the index of the sheet. This effectively moves the sheet to a different position.</para>
            /// </returns>
            public ushort Index
            {
                get
                {
                    var ___ret = __Internal.Index(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIndex(__Instance, value);
                }
            }

            /// <summary>Method to retrieve the name of the sheet.</summary>
            /// <param name="name">A std::string with the new name.</param>
            /// <returns>
            /// <para>A std::string with the sheet name.</para>
            /// <para>Method for renaming the sheet.</para>
            /// </returns>
            public string Name
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Name(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetName(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>Determine whether the sheet is selected</summary>
            public bool Selected
            {
                get
                {
                    var ___ret = __Internal.IsSelected(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetSelected(__Instance, value);
                }
            }
        }

        public unsafe partial class XLSheet
        {
            public partial struct __Internal
            {
            }

            public const bool XLEmptyHiddenCells = true;        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>This class encapsulate the Excel concept of&gt;. Each worksheet that has merged cells has a list of</para>
        /// <para>(empty)&gt; elements within that array, with a sole attribute ref=&quot;...&quot; with ... being a range reference, e.g. A1:B5</para>
        /// </summary>
        public unsafe partial class XLMergeCells : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_ m_mergeCellsNode;
                internal global::Std.Deque.__Internalc__N_std_S_deque____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_referenceCache;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLMergeCells@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLMergeCells@OpenXLSX@@QEAA@AEBVOpenXLSX_xml_node@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr node);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLMergeCells@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLMergeCells@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?findMerge@XLMergeCells@OpenXLSX@@QEBAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int FindMerge(__IntPtr __instance, __IntPtr reference);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?mergeExists@XLMergeCells@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool MergeExists(__IntPtr __instance, __IntPtr reference);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?findMergeByCell@XLMergeCells@OpenXLSX@@QEBAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int FindMergeByCell(__IntPtr __instance, __IntPtr cellRef);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?findMergeByCell@XLMergeCells@OpenXLSX@@QEBAHVXLCellReference@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int FindMergeByCell_1(__IntPtr __instance, __IntPtr cellRef);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?merge@XLMergeCells@OpenXLSX@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Merge(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?appendMerge@XLMergeCells@OpenXLSX@@QEAAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int AppendMerge(__IntPtr __instance, __IntPtr reference);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteMerge@XLMergeCells@OpenXLSX@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteMerge(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??AXLMergeCells@OpenXLSX@@QEBAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorSubscript(__IntPtr __instance, int index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?uninitialized@XLMergeCells@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Uninitialized(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?count@XLMergeCells@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Count(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLMergeCells> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLMergeCells>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLMergeCells managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLMergeCells managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLMergeCells __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLMergeCells(native.ToPointer(), skipVTables);
            }

            internal static XLMergeCells __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLMergeCells)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLMergeCells __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLMergeCells(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLMergeCells.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLMergeCells(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLMergeCells(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLMergeCells()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLMergeCells.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <param name="node">The&gt; node of the worksheet document - must not be an empty node</param>
            public XLMergeCells(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLMergeCells.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(node, null))
                    throw new global::System.ArgumentNullException("node", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = node.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLMergeCells(global::OpenXLSX.OpenXLSX.XLMergeCells other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLMergeCells.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>get the index of a&gt; entry by its reference</summary>
            /// <param name="reference">the reference to search for</param>
            /// <returns>-1 if no such reference exists, 0-based index otherwise</returns>
            public int FindMerge(string reference)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, reference);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.FindMerge(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>test if a mergeCell with reference exists, equivalent to findMerge(reference) &gt;= 0</summary>
            /// <param name="reference">the reference to find</param>
            /// <returns>true if reference exists, false otherwise</returns>
            public bool MergeExists(string reference)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, reference);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.MergeExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>get the index of a&gt; entry of which cellReference is a part</summary>
            /// <param name="cellRef">the cell reference (string or XLCellReference) to search for in the merged ranges</param>
            /// <returns>-1 if no such reference exists, 0-based index otherwise</returns>
            public int FindMergeByCell(string cellRef)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, cellRef);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.FindMergeByCell(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public int FindMergeByCell(global::OpenXLSX.OpenXLSX.XLCellReference cellRef)
            {
                if (ReferenceEquals(cellRef, null))
                    throw new global::System.ArgumentNullException("cellRef", "Cannot be null because it is passed by value.");
                var __arg0 = cellRef.__Instance;
                var ___ret = __Internal.FindMergeByCell_1(__Instance, __arg0);
                return ___ret;
            }

            /// <summary>return the cell reference string for the given index</summary>
            public string Merge(int index)
            {
                var ___ret = __Internal.Merge(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Append a new merge to the list of merges</summary>
            /// <param name="reference">The reference to append.</param>
            /// <returns>An int32_t with the index of the appended string</returns>
            /// <remarks>XLInputException if the reference would overlap with an existing reference</remarks>
            public int AppendMerge(string reference)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, reference);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.AppendMerge(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Delete the merge at the given index.</summary>
            /// <param name="index">The index to delete</param>
            /// <remarks>
            /// <para>Previously obtained merge indexes will be invalidated when calling deleteMerge</para>
            /// <para>XLInputException if the index does not exist</para>
            /// </remarks>
            public void DeleteMerge(int index)
            {
                __Internal.DeleteMerge(__Instance, index);
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLMergeCells(global::OpenXLSX.OpenXLSX.OpenXLSX_xml_node node)
            {
                return new global::OpenXLSX.OpenXLSX.XLMergeCells(node);
            }

            public string this[int index]
            {
                get
                {
                    var ___ret = __Internal.OperatorSubscript(__Instance, index);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
                }
            }

            public bool Uninitialized
            {
                get
                {
                    var ___ret = __Internal.Uninitialized(__Instance);
                    return ___ret;
                }
            }

            /// <summary>get the amount of entries in&gt;</summary>
            /// <returns>the count of defined cell merges</returns>
            public ulong Count
            {
                get
                {
                    var ___ret = __Internal.Count(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class XLMergeCells
        {
            public partial struct __Internal
            {
            }

            public const ulong XLMaxMergeCells = 2147483647;        }
    }

    namespace OpenXLSX
    {
        public enum XLIteratorLocation
        {
            Begin = 0,
            End = 1
        }

        public enum XLIteratorDirection
        {
            Forward = 0,
            Reverse = 1
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLConstants
        {
            public partial struct __Internal
            {
            }

            public const ushort MAX_COLS = 16384;
            public const uint MAX_ROWS = 1048576;        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);
    }
}

namespace OpenXLSX.__Symbols
{
    internal class OpenXLSX
    {
        public static IntPtr _NO_XML_NS_OpenXLSX__3_NA { get; }
        static OpenXLSX()
        {
            var path = "OpenXLSX";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _NO_XML_NS_OpenXLSX__3_NA = CppSharp.SymbolResolver.ResolveSymbol(image, "?NO_XML_NS@OpenXLSX@@3_NA");
        }
    }
}

namespace Std
{
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_OpenXLSX_xml_document__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_IZipArchive_S_Concept__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLRowDataRange__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLCellStyles__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLCellStyle___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLCellFormats__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLCellFormat___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLBorders__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLBorder___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLFills__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLFill___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLGradientStop___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLFonts__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLFont___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLNumberFormats__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLNumberFormat___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1
        {
            internal global::Std.VectorVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_node____N_OpenXLSX_S_XLXmlData__v___N_std_S__List_val____N_std_S__List_simple_types__S2__Vb1
        {
            internal global::Std.ListVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_OpenXLSX_xml_node__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }
    }

}
namespace Std
{
    namespace UniquePtr
    {
        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_document___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_OpenXLSX_xml_document__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_IZipArchive_S_Concept___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_IZipArchive_S_Concept__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLRowDataRange___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLRowDataRange__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLCellStyles___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLCellStyles__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLCellFormats___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLCellFormats__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLBorders___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLBorders__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLFills___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLFills__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLFonts___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLFonts__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLNumberFormats___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLNumberFormats__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_OpenXLSX_xml_node___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_OpenXLSX_xml_node__S1__Vb1 _Mypair;
        }
    }

}
namespace Std
{
    namespace Vector
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_OpenXLSX_S_XLCellStyle___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLCellStyle___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_OpenXLSX_S_XLCellFormat___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLCellFormat___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_OpenXLSX_S_XLBorder___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLBorder___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_OpenXLSX_S_XLGradientStop___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLGradientStop___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_OpenXLSX_S_XLFill___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLFill___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_OpenXLSX_S_XLFont___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLFont___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_vector____N_OpenXLSX_S_XLNumberFormat___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_OpenXLSX_S_XLNumberFormat___N_std_S__Vector_val____N_std_S__Simple_types__S1__Vb1 _Mypair;
        }
    }

}
namespace Std
{
    namespace List
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_list____N_OpenXLSX_S_XLXmlData___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_node____N_OpenXLSX_S_XLXmlData__v___N_std_S__List_val____N_std_S__List_simple_types__S2__Vb1 _Mypair;
        }
    }
}
