// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace OpenXLSX
{
    namespace OpenXLSX
    {
        public unsafe partial class XLCellReference : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal uint m_row;
                internal ushort m_column;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_cellAddress;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellReference@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr cellAddress);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellReference@OpenXLSX@@QEAA@IG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, uint row, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellReference@OpenXLSX@@QEAA@IAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, uint row, __IntPtr column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellReference@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellReference@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??EXLCellReference@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorPlusPlus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??FXLCellReference@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorMinusMinus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRowAndColumn@XLCellReference@OpenXLSX@@QEAAXIG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRowAndColumn(__IntPtr __instance, uint row, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowAsString@XLCellReference@OpenXLSX@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RowAsString(__IntPtr @return, uint row);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowAsNumber@XLCellReference@OpenXLSX@@SAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint RowAsNumber(__IntPtr row);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?columnAsString@XLCellReference@OpenXLSX@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ColumnAsString(__IntPtr @return, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?columnAsNumber@XLCellReference@OpenXLSX@@SAGAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort ColumnAsNumber(__IntPtr column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??MOpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLess(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??OOpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreater(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??NOpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??POpenXLSX@@YA_NAEBVXLCellReference@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?row@XLCellReference@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint Row(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRow@XLCellReference@OpenXLSX@@QEAAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRow(__IntPtr __instance, uint row);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?column@XLCellReference@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort Column(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColumn@XLCellReference@OpenXLSX@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColumn(__IntPtr __instance, ushort column);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?address@XLCellReference@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Address(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setAddress@XLCellReference@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAddress(__IntPtr __instance, __IntPtr address);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellReference> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellReference>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellReference managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellReference managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellReference __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellReference(native.ToPointer(), skipVTables);
            }

            internal static XLCellReference __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellReference)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellReference __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellReference(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellReference.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellReference(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellReference(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor taking a cell address as argument.</summary>
            /// <param name="cellAddress">The address of the cell, e.g. 'A1'.</param>
            /// <remarks>
            /// <para>The constructor creates a new XLCellReference from a string, e.g. 'A1'. If there's no input,</para>
            /// <para>the default reference will be cell A1.</para>
            /// </remarks>
            public XLCellReference(string cellAddress)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, cellAddress);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Constructor taking the cell coordinates as arguments.</summary>
            /// <param name="row">The row number of the cell.</param>
            /// <param name="column">The column number of the cell.</param>
            public XLCellReference(uint row, ushort column)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, row, column);
            }

            /// <summary>Constructor taking the row number and the column letter as arguments.</summary>
            /// <param name="row">The row number of the cell.</param>
            /// <param name="column">The column letter of the cell.</param>
            public XLCellReference(uint row, string column)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, column);
                var __arg1 = __basicString1.__Instance;
                __Internal.ctor(__Instance, row, __arg1);
                __basicString1.Dispose();
            }

            /// <summary>Copy constructor</summary>
            /// <param name="other">The object to be copied.</param>
            public XLCellReference(global::OpenXLSX.OpenXLSX.XLCellReference other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::OpenXLSX.OpenXLSX.XLCellReference operator ++(global::OpenXLSX.OpenXLSX.XLCellReference __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorPlusPlus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellReference.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static global::OpenXLSX.OpenXLSX.XLCellReference operator --(global::OpenXLSX.OpenXLSX.XLCellReference __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorMinusMinus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellReference.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Set both row and column number of the XLCellReference.</summary>
            /// <param name="row">The row number.</param>
            /// <param name="column">The column number.</param>
            public void SetRowAndColumn(uint row, ushort column)
            {
                __Internal.SetRowAndColumn(__Instance, row, column);
            }

            public static implicit operator global::OpenXLSX.OpenXLSX.XLCellReference(string cellAddress)
            {
                return new global::OpenXLSX.OpenXLSX.XLCellReference(cellAddress);
            }

            public static string RowAsString(uint row)
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.RowAsString(new IntPtr(&___ret), row);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public static uint RowAsNumber(string row)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, row);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.RowAsNumber(__arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Static helper function to convert column number to column letter (e.g. column 1 becomes 'A')</summary>
            /// <param name="column">The column number.</param>
            /// <returns>The column letter</returns>
            public static string ColumnAsString(ushort column)
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.ColumnAsString(new IntPtr(&___ret), column);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Static helper function to convert column letter to column number (e.g. column 'A' becomes 1)</summary>
            /// <param name="column">The column letter, e.g. 'A'</param>
            /// <returns>The column number.</returns>
            public static ushort ColumnAsNumber(string column)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, column);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.ColumnAsNumber(__arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Helper function to check equality between two XLCellReferences.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if equal; otherwise false.</returns>
            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLCellReference;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLCellReference.__Internal*) __Instance).GetHashCode();
            }

            /// <summary>Helper function to check for in-equality between two XLCellReferences</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>false if equal; otherwise true.</returns>
            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Helper function to check if one XLCellReference is smaller than another.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if lhs&lt;rhs; otherwise false.</returns>
            public static bool operator <(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLess(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Helper function to check if one XLCellReference is larger than another.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if lhs &gt; rhs; otherwise false.</returns>
            public static bool operator >(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreater(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Helper function to check if one XLCellReference is smaller than or equal to another.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if lhs&lt;= rhs; otherwise false</returns>
            public static bool operator <=(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLessEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Helper function to check if one XLCellReference is larger than or equal to another.</summary>
            /// <param name="lhs">The first XLCellReference</param>
            /// <param name="rhs">The second XLCellReference</param>
            /// <returns>true if lhs &gt;= rhs; otherwise false.</returns>
            public static bool operator >=(global::OpenXLSX.OpenXLSX.XLCellReference lhs, global::OpenXLSX.OpenXLSX.XLCellReference rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Get the row number of the XLCellReference.</summary>
            /// <param name="row">The row number.</param>
            /// <returns>
            /// <para>The row.</para>
            /// <para>Set the row number for the XLCellReference.</para>
            /// </returns>
            public uint Row
            {
                get
                {
                    var ___ret = __Internal.Row(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetRow(__Instance, value);
                }
            }

            /// <summary>Get the column number of the XLCellReference.</summary>
            /// <param name="column">The column number.</param>
            /// <returns>
            /// <para>The column number.</para>
            /// <para>Set the column number of the XLCellReference.</para>
            /// </returns>
            public ushort Column
            {
                get
                {
                    var ___ret = __Internal.Column(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetColumn(__Instance, value);
                }
            }

            /// <summary>Get the address of the XLCellReference</summary>
            /// <param name="address">The address, e.g. 'A1'</param>
            /// <returns>
            /// <para>The address, e.g. 'A1'</para>
            /// <para>Set the address of the XLCellReference</para>
            /// </returns>
            /// <remarks>The address input string must be a valid Excel cell reference. Otherwise the behaviour is undefined.</remarks>
            public string Address
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Address(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetAddress(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLException : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLException@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLException> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLException>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLException managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLException managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLException __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLException(native.ToPointer(), skipVTables);
            }

            internal static XLException __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLException)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLException __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLException)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLException __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLException(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLException(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLException(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLException(string err)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLException.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLException");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLException(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLException(err);
            }

            #region Virtual table interop

            // XLException
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLException.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLOverflowError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLOverflowError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLOverflowError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLOverflowError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLOverflowError(native.ToPointer(), skipVTables);
            }

            internal static new XLOverflowError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLOverflowError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLOverflowError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLOverflowError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLOverflowError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLOverflowError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLOverflowError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLOverflowError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLOverflowError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLOverflowError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLOverflowError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLOverflowError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLOverflowError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLOverflowError(err);
            }

            #region Virtual table interop

            // XLOverflowError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLOverflowError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLValueTypeError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLValueTypeError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLValueTypeError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLValueTypeError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLValueTypeError(native.ToPointer(), skipVTables);
            }

            internal static new XLValueTypeError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLValueTypeError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLValueTypeError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLValueTypeError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLValueTypeError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLValueTypeError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLValueTypeError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLValueTypeError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLValueTypeError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLValueTypeError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLValueTypeError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLValueTypeError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLValueTypeError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLValueTypeError(err);
            }

            #region Virtual table interop

            // XLValueTypeError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLValueTypeError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLCellAddressError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellAddressError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellAddressError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLCellAddressError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellAddressError(native.ToPointer(), skipVTables);
            }

            internal static new XLCellAddressError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellAddressError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLCellAddressError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLCellAddressError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLCellAddressError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellAddressError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellAddressError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellAddressError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellAddressError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLCellAddressError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellAddressError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLCellAddressError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLCellAddressError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLCellAddressError(err);
            }

            #region Virtual table interop

            // XLCellAddressError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLCellAddressError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLInputError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLInputError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLInputError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLInputError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLInputError(native.ToPointer(), skipVTables);
            }

            internal static new XLInputError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLInputError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLInputError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLInputError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLInputError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLInputError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLInputError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLInputError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLInputError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLInputError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLInputError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLInputError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLInputError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLInputError(err);
            }

            #region Virtual table interop

            // XLInputError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLInputError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLInternalError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLInternalError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLInternalError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLInternalError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLInternalError(native.ToPointer(), skipVTables);
            }

            internal static new XLInternalError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLInternalError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLInternalError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLInternalError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLInternalError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLInternalError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLInternalError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLInternalError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLInternalError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLInternalError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLInternalError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLInternalError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLInternalError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLInternalError(err);
            }

            #region Virtual table interop

            // XLInternalError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLInternalError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLPropertyError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLPropertyError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLPropertyError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLPropertyError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLPropertyError(native.ToPointer(), skipVTables);
            }

            internal static new XLPropertyError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLPropertyError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLPropertyError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLPropertyError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLPropertyError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLPropertyError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLPropertyError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLPropertyError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLPropertyError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLPropertyError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLPropertyError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLPropertyError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLPropertyError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLPropertyError(err);
            }

            #region Virtual table interop

            // XLPropertyError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLPropertyError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLSheetError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSheetError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSheetError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLSheetError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLSheetError(native.ToPointer(), skipVTables);
            }

            internal static new XLSheetError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLSheetError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLSheetError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLSheetError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLSheetError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLSheetError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLSheetError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLSheetError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLSheetError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLSheetError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheetError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLSheetError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLSheetError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLSheetError(err);
            }

            #region Virtual table interop

            // XLSheetError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLSheetError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLDateTimeError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTimeError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTimeError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLDateTimeError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLDateTimeError(native.ToPointer(), skipVTables);
            }

            internal static new XLDateTimeError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLDateTimeError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLDateTimeError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLDateTimeError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLDateTimeError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLDateTimeError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLDateTimeError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLDateTimeError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLDateTimeError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLDateTimeError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTimeError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLDateTimeError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLDateTimeError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLDateTimeError(err);
            }

            #region Virtual table interop

            // XLDateTimeError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLDateTimeError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        public unsafe partial class XLFormulaError : global::OpenXLSX.OpenXLSX.XLException, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public new partial struct __Internal
            {
                internal __IntPtr vfptr_exception;
                internal global::StdExceptionData.__Internal _Data;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFormulaError@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr err);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFormulaError@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);
            }

            internal static new XLFormulaError __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFormulaError(native.ToPointer(), skipVTables);
            }

            internal static new XLFormulaError __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFormulaError)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static new XLFormulaError __GetInstance(__IntPtr native)
            {
                if (!__TryGetNativeToManagedMapping(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (XLFormulaError)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static XLFormulaError __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFormulaError(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLFormulaError.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLFormulaError(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFormulaError(void* native, bool skipVTables = false)
                : base((void*) native)
            {
                if (native == null)
                    return;
                if (!skipVTables)
                    SetupVTables(true);
            }

            public XLFormulaError(string err)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFormulaError.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, err);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
                SetupVTables(GetType().FullName == "OpenXLSX.OpenXLSX.XLFormulaError");
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (callNativeDtor)
                {
                    var ___dtorDelegate = __VTables.GetMethodDelegate<global::OpenXLSX.Delegates.Action___IntPtr_int>(0, 0);
                    ___dtorDelegate(__Instance, 0);
                }
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLFormulaError(string err)
            {
                return new global::OpenXLSX.OpenXLSX.XLFormulaError(err);
            }

            #region Virtual table interop

            // XLFormulaError
            private static global::OpenXLSX.Delegates.Action___IntPtr_int _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance, int delete)
            {
                var __target = global::OpenXLSX.OpenXLSX.XLFormulaError.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            internal static new class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[1];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();
                
                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTablesDtorOnly[0][0] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3, 1);
                                ManagedVTables[0][0] = Thunks[0];
                                VTables.Methods[0] = new Delegate[3];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            internal override CppSharp.Runtime.VTables __VTables
            {
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {
                    __vtables = value;
                }
            }
            internal override void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLDateTime : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal double m_serial;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTime@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTime@OpenXLSX@@QEAA@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, double serial);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTime@OpenXLSX@@QEAA@_J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor_1(__IntPtr __instance, long unixtime);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDateTime@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLDateTime@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?serial@XLDateTime@OpenXLSX@@QEBANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Serial(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDateTime> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDateTime>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLDateTime managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLDateTime managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLDateTime __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLDateTime(native.ToPointer(), skipVTables);
            }

            internal static XLDateTime __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLDateTime)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLDateTime __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLDateTime(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLDateTime.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLDateTime(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLDateTime(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor.</summary>
            public XLDateTime()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTime.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor taking an Excel time point serial number as an argument.</summary>
            /// <param name="serial">Excel time point serial number.</param>
            public XLDateTime(double serial)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTime.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, serial);
            }

            /// <summary>Constructor taking a unixtime format (seconds since 1/1/1970) as an argument.</summary>
            /// <param name="unixtime">A time_t number.</param>
            public XLDateTime(long unixtime)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTime.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor_1(__Instance, unixtime);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLDateTime(global::OpenXLSX.OpenXLSX.XLDateTime other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDateTime.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLDateTime(double serial)
            {
                return new global::OpenXLSX.OpenXLSX.XLDateTime(serial);
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLDateTime(long unixtime)
            {
                return new global::OpenXLSX.OpenXLSX.XLDateTime(unixtime);
            }

            /// <summary>Get the date/time in the form of an Excel date/time serial number.</summary>
            /// <returns>A double with the serial number.</returns>
            public double Serial
            {
                get
                {
                    var ___ret = __Internal.Serial(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>Enum defining the valid value types for a an Excel spreadsheet cell.</summary>
        public enum XLValueType
        {
            Empty = 0,
            Boolean = 1,
            Integer = 2,
            Float = 3,
            Error = 4,
            String = 5
        }

        /// <summary>Class encapsulating a cell value.</summary>
        public unsafe partial class XLCellValue : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 128)]
            public partial struct __Internal
            {
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value_str;
                internal long m_value_int;
                internal double m_value_float;
                internal byte m_value_bool;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value_error;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_value_empty;
                internal global::OpenXLSX.OpenXLSX.XLValueType m_type;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellValue@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellValue@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellValue@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setError@XLCellValue@OpenXLSX@@QEAAAEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetError(__IntPtr __instance, __IntPtr error);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??MOpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLess(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??OOpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreater(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??NOpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??POpenXLSX@@YA_NAEBVXLCellValue@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLCellValue@OpenXLSX@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLCellValue@OpenXLSX@@QEBA?AW4XLValueType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLValueType Type(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?typeAsString@XLCellValue@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TypeAsString(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellValue> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellValue>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellValue managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellValue managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellValue __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellValue(native.ToPointer(), skipVTables);
            }

            internal static XLCellValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellValue)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellValue __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellValue(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellValue.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellValue(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellValue(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor</summary>
            public XLCellValue()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellValue.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">The object to be copied.</param>
            public XLCellValue(global::OpenXLSX.OpenXLSX.XLCellValue other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellValue.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Sets the value type to XLValueType::Error.</summary>
            /// <returns>Returns a reference to the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellValue SetError(string error)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, error);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SetError(__Instance, __arg0);
                __basicString0.Dispose();
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellValue.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLCellValue;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLCellValue.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator <(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLess(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator >(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreater(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator <=(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLessEqual(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator >=(global::OpenXLSX.OpenXLSX.XLCellValue lhs, global::OpenXLSX.OpenXLSX.XLCellValue rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Clears the contents of the XLCellValue object.</summary>
            /// <returns>Returns a reference to the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellValue Clear
            {
                get
                {
                    var ___ret = __Internal.Clear(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellValue.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the value type of the current object.</summary>
            /// <returns>An XLValueType for the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLValueType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the value type of the current object, as a string representation</summary>
            /// <returns>A std::string representation of the value type.</returns>
            public string TypeAsString
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.TypeAsString(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>The XLCellValueProxy class is used for proxy (or placeholder) objects for XLCellValue objects.</summary>
        /// <remarks>
        /// <para>The XLCellValueProxy class is used for proxy (or placeholder) objects for XLCellValue objects.</para>
        /// <para>The purpose is to enable implicit conversion during assignment operations. XLCellValueProxy objects</para>
        /// <para>can not be constructed manually by the user, only through XLCell objects.</para>
        /// </remarks>
        public unsafe partial class XLCellValueProxy : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr m_cell;
                internal __IntPtr m_cellNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellValueProxy@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setError@XLCellValueProxy@OpenXLSX@@QEAAAEAV12@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SetError(__IntPtr __instance, __IntPtr error);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLCellValueProxy@OpenXLSX@@QEAA?AVXLCellValue@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setString@XLCellValueProxy@OpenXLSX@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetString(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string stringValue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLCellValueProxy@OpenXLSX@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLCellValueProxy@OpenXLSX@@QEBA?AW4XLValueType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLValueType Type(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?typeAsString@XLCellValueProxy@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TypeAsString(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getInteger@XLCellValueProxy@OpenXLSX@@QEAA_JXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern long GetInteger(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setInteger@XLCellValueProxy@OpenXLSX@@QEAAX_J@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInteger(__IntPtr __instance, long numberValue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getBoolean@XLCellValueProxy@OpenXLSX@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool GetBoolean(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setBoolean@XLCellValueProxy@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBoolean(__IntPtr __instance, bool numberValue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getFloat@XLCellValueProxy@OpenXLSX@@QEAANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double GetFloat(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFloat@XLCellValueProxy@OpenXLSX@@QEAAXN@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFloat(__IntPtr __instance, double numberValue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getString@XLCellValueProxy@OpenXLSX@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetString(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellValueProxy> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellValueProxy>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellValueProxy managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellValueProxy managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellValueProxy __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellValueProxy(native.ToPointer(), skipVTables);
            }

            internal static XLCellValueProxy __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellValueProxy)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellValueProxy __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellValueProxy(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLCellValueProxy(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellValueProxy(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set the cell value to a error state.</summary>
            /// <returns>A reference to the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellValueProxy SetError(string error)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, error);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SetError(__Instance, __arg0);
                __basicString0.Dispose();
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellValueProxy.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Implicitly convert the XLCellValueProxy object to a XLCellValue object.</summary>
            /// <returns>An XLCellValue object, corresponding to the cell value.</returns>
            public static implicit operator global::OpenXLSX.OpenXLSX.XLCellValue(global::OpenXLSX.OpenXLSX.XLCellValueProxy __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellValue.__Internal();
                __Internal.OperatorConversion(__arg0, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellValue.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellValue.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Set the cell to a string value.</summary>
            /// <param name="stringValue">The value to be set.</param>
            public void SetString(string stringValue)
            {
                __Internal.SetString(__Instance, stringValue);
            }

            /// <summary>Clear the contents of the cell.</summary>
            /// <returns>A reference to the current object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellValueProxy Clear
            {
                get
                {
                    var ___ret = __Internal.Clear(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellValueProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Get the value type for the cell.</summary>
            /// <returns>An XLCellValue corresponding to the cell value.</returns>
            public global::OpenXLSX.OpenXLSX.XLValueType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the value type of the current object, as a string representation</summary>
            /// <returns>A std::string representation of the value type.</returns>
            public string TypeAsString
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.TypeAsString(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            public long Integer
            {
                get
                {
                    var ___ret = __Internal.GetInteger(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetInteger(__Instance, value);
                }
            }

            public bool Boolean
            {
                get
                {
                    var ___ret = __Internal.GetBoolean(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetBoolean(__Instance, value);
                }
            }

            public double Float
            {
                get
                {
                    var ___ret = __Internal.GetFloat(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetFloat(__Instance, value);
                }
            }

            public string String
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetString(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLFormula class encapsulates the concept of an Excel formula. The class is essentially</para>
        /// <para>a wrapper around a std::string.</para>
        /// </summary>
        /// <remarks>
        /// <para>This class currently only supports simple formulas. Array formulas and shared formulas are</para>
        /// <para>not supported. Unfortunately, many spreadsheets have shared formulas, so this class is probably</para>
        /// <para>best used for adding formulas, not reading them from an existing spreadsheet.</para>
        /// <para>Enable handling of shared and array formulas.</para>
        /// </remarks>
        public unsafe partial class XLFormula : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_formulaString;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFormula@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLFormula@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLFormula@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?get@XLFormula@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Get(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLFormula@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLFormula@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLFormula@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLFormula@OpenXLSX@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clear(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFormula> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFormula>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLFormula managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLFormula managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLFormula __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFormula(native.ToPointer(), skipVTables);
            }

            internal static XLFormula __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFormula)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLFormula __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFormula(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLFormula.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLFormula(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFormula(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor</summary>
            public XLFormula()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFormula.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLFormula(global::OpenXLSX.OpenXLSX.XLFormula other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLFormula.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the forumla as a std::string.</summary>
            /// <returns>A std::string with the formula.</returns>
            public string Get()
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Get(__Instance, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Conversion operator, for converting object to a std::string.</summary>
            /// <returns>The formula as a std::string.</returns>
            public static implicit operator string(global::OpenXLSX.OpenXLSX.XLFormula __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.OperatorConversion(__arg0, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLFormula lhs, global::OpenXLSX.OpenXLSX.XLFormula rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLFormula;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLFormula.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLFormula lhs, global::OpenXLSX.OpenXLSX.XLFormula rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Clear the formula.</summary>
            /// <returns>Return a reference to the cleared object.</returns>
            public global::OpenXLSX.OpenXLSX.XLFormula Clear
            {
                get
                {
                    var ___ret = __Internal.Clear(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLFormula.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        /// <summary>
        /// <para>The XLFormulaProxy serves as a placeholder for XLFormula objects. This enable</para>
        /// <para>getting and setting formulas through the same interface.</para>
        /// </summary>
        public unsafe partial class XLFormulaProxy : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr m_cell;
                internal __IntPtr m_cellNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLFormulaProxy@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?get@XLFormulaProxy@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Get(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLFormulaProxy@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLFormulaProxy@OpenXLSX@@QEBA?AVXLFormula@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion_1(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLFormulaProxy@OpenXLSX@@QEAAAEAV12@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Clear(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFormulaProxy> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLFormulaProxy>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLFormulaProxy managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLFormulaProxy managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLFormulaProxy __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLFormulaProxy(native.ToPointer(), skipVTables);
            }

            internal static XLFormulaProxy __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLFormulaProxy)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLFormulaProxy __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLFormulaProxy(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLFormulaProxy(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLFormulaProxy(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the forumla as a std::string.</summary>
            /// <returns>A std::string with the formula.</returns>
            public string Get()
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Get(__Instance, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Conversion operator, for converting the object to a std::string.</summary>
            /// <returns>The formula as a std::string.</returns>
            public static implicit operator string(global::OpenXLSX.OpenXLSX.XLFormulaProxy __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.OperatorConversion(__arg0, new IntPtr(&___ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Implicit conversion to XLFormula object.</summary>
            /// <returns>Returns the corresponding XLFormula object.</returns>
            public static implicit operator global::OpenXLSX.OpenXLSX.XLFormula(global::OpenXLSX.OpenXLSX.XLFormulaProxy __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLFormula.__Internal();
                __Internal.OperatorConversion_1(__arg0, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLFormula.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLFormula.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Clear the formula.</summary>
            /// <returns>Return a reference to the cleared object.</returns>
            public global::OpenXLSX.OpenXLSX.XLFormulaProxy Clear
            {
                get
                {
                    var ___ret = __Internal.Clear(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLFormulaProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLXmlFile class provides an interface for derived classes to use.</para>
        /// <para>It functions as an ancestor to all classes which are represented by an .xml file in an .xlsx package.</para>
        /// </summary>
        /// <remarks>
        /// <para>The XLXmlFile class is not intended to be instantiated on it's own, but to provide an interface for</para>
        /// <para>derived classes. Also, it should not be used polymorphically. For that reason, the destructor is not declared virtual.</para>
        /// </remarks>
        public unsafe partial class XLXmlFile : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlFile@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlFile@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlFile@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLXmlFile@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?xmlData@XLXmlFile@OpenXLSX@@IEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void XmlData(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setXmlData@XLXmlFile@OpenXLSX@@IEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetXmlData(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?relationshipID@XLXmlFile@OpenXLSX@@IEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RelationshipID(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?parentDoc@XLXmlFile@OpenXLSX@@IEAAAEAVXLDocument@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ParentDoc(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlFile> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlFile>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLXmlFile managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLXmlFile managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLXmlFile __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLXmlFile(native.ToPointer(), skipVTables);
            }

            internal static XLXmlFile __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLXmlFile)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLXmlFile __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLXmlFile(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLXmlFile(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLXmlFile(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor.</summary>
            public XLXmlFile()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. Creates an object based on the xmlData input.</summary>
            /// <param name="xmlData">An XLXmlData object with the XML data to be represented by the object.</param>
            public XLXmlFile(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy constructor. Default implementation used.</summary>
            /// <param name="other">The object to copy.</param>
            public XLXmlFile(global::OpenXLSX.OpenXLSX.XLXmlFile other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLXmlFile.__Internal*) other.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLXmlFile(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLXmlFile(xmlData);
            }

            /// <summary>The underlying XML data object.</summary>
            protected global::OpenXLSX.OpenXLSX.XLXmlData MXmlData
            {
                get
                {
                    var __result0 = global::OpenXLSX.OpenXLSX.XLXmlData.__GetOrCreateInstance(((__Internal*)__Instance)->m_xmlData, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->m_xmlData = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            /// <summary>Method for getting the XML data represented by the object.</summary>
            /// <param name="xmlData">A std::string with the XML data.</param>
            /// <returns>
            /// <para>A std::string with the XML data.</para>
            /// <para>Provide the XML data represented by the object.</para>
            /// </returns>
            protected string XmlData
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.XmlData(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetXmlData(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>This function returns the relationship ID (the ID used in the XLRelationships objects) for the object.</summary>
            /// <returns>
            /// <para>A std::string with the ID. Not all spreadsheet objects may have a relationship ID. In those cases an empty string is</para>
            /// <para>returned.</para>
            /// </returns>
            protected string RelationshipID
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.RelationshipID(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>This function provides access to the parent XLDocument object.</summary>
            /// <returns>A reference to the parent XLDocument object.</returns>
            protected global::OpenXLSX.OpenXLSX.XLDocument ParentDoc
            {
                get
                {
                    var ___ret = __Internal.ParentDoc(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLDocument.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>This class encapsulate the Excel concept of Shared Strings. In Excel, instead of havig individual strings</para>
        /// <para>in each cell, cells have a reference to an entry in the SharedStrings register. This results in smalle file</para>
        /// <para>sizes, as repeated strings are referenced easily.</para>
        /// </summary>
        public unsafe partial class XLSharedStrings : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;
                internal __IntPtr m_stringCache;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSharedStrings@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSharedStrings@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLSharedStrings@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getStringIndex@XLSharedStrings@OpenXLSX@@QEBAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetStringIndex(__IntPtr __instance, __IntPtr str);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?stringExists@XLSharedStrings@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool StringExists(__IntPtr __instance, __IntPtr str);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getString@XLSharedStrings@OpenXLSX@@QEBAPEBDI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetString(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?appendString@XLSharedStrings@OpenXLSX@@QEAAHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int AppendString(__IntPtr __instance, __IntPtr str);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clearString@XLSharedStrings@OpenXLSX@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ClearString(__IntPtr __instance, ulong index);
            }

            internal static new XLSharedStrings __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLSharedStrings(native.ToPointer(), skipVTables);
            }

            internal static new XLSharedStrings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLSharedStrings)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLSharedStrings __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLSharedStrings(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLSharedStrings(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLSharedStrings(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLSharedStrings()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLSharedStrings(global::OpenXLSX.OpenXLSX.XLSharedStrings other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int GetStringIndex(string str)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, str);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.GetStringIndex(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool StringExists(string str)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, str);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.StringExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public string GetString(uint index)
            {
                var ___ret = __Internal.GetString(__Instance, index);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
            }

            /// <summary>Append a new string to the list of shared strings.</summary>
            /// <param name="str">The string to append.</param>
            /// <returns>A long int with the index of the appended string</returns>
            public int AppendString(string str)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, str);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.AppendString(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Clear the string at the given index.</summary>
            /// <param name="index">The index to clear.</param>
            /// <remarks>
            /// <para>There is no 'deleteString' member function, as deleting a shared string node will invalidate the</para>
            /// <para>shared string indices for the cells in the spreadsheet. Instead use this member functions, which clears</para>
            /// <para>the contents of the string, but keeps the XMLNode holding the string.</para>
            /// </remarks>
            public void ClearString(ulong index)
            {
                __Internal.ClearString(__Instance, index);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>An implementation class encapsulating the properties and behaviours of a spreadsheet cell.</summary>
        public unsafe partial class XLCell : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 56)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_cellNode;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal global::OpenXLSX.OpenXLSX.XLCellValueProxy.__Internal m_valueProxy;
                internal global::OpenXLSX.OpenXLSX.XLFormulaProxy.__Internal m_formulaProxy;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCell@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCell@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCell@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLCell@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?offset@XLCell@OpenXLSX@@QEBA?AV12@GG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Offset(__IntPtr __instance, __IntPtr @return, ushort rowOffset, ushort colOffset);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLCell@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLCell@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?value@XLCell@OpenXLSX@@QEAAAEAVXLCellValueProxy@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Value(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellReference@XLCell@OpenXLSX@@QEBA?AVXLCellReference@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CellReference(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasFormula@XLCell@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasFormula(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?formula@XLCell@OpenXLSX@@QEAAAEAVXLFormulaProxy@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Formula(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCell> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCell>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCell managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCell managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCell __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCell(native.ToPointer(), skipVTables);
            }

            internal static XLCell __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCell)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCell __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCell(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCell.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCell(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCell(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor. Constructs a null object.</summary>
            public XLCell()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCell.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy constructor</summary>
            /// <param name="other">The XLCell object to be copied.</param>
            /// <remarks>
            /// <para>The copy constructor has been deleted, as it makes no sense to copy a cell. If the objective is to</para>
            /// <para>copy the getValue, create the the target object and then use the copy assignment operator.</para>
            /// </remarks>
            public XLCell(global::OpenXLSX.OpenXLSX.XLCell other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCell.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLCell __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            /// <summary>get the XLCell object from the current cell offset</summary>
            /// <returns>A reference to the XLCell object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCell Offset(ushort rowOffset, ushort colOffset)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCell.__Internal();
                __Internal.Offset(__Instance, new IntPtr(&___ret), rowOffset, colOffset);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCell.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCell.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLCell lhs, global::OpenXLSX.OpenXLSX.XLCell rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLCell;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLCell.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLCell lhs, global::OpenXLSX.OpenXLSX.XLCell rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.XLCellValueProxy Value
            {
                get
                {
                    var ___ret = __Internal.Value(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLCellValueProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>get the XLCellReference object for the cell.</summary>
            /// <returns>A reference to the cells' XLCellReference object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellReference CellReference
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLCellReference.__Internal();
                    __Internal.CellReference(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLCellReference.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLCellReference.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public bool HasFormula
            {
                get
                {
                    var ___ret = __Internal.HasFormula(__Instance);
                    return ___ret;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLFormulaProxy Formula
            {
                get
                {
                    var ___ret = __Internal.Formula(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLFormulaProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLCellIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 168)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_dataNode;
                internal global::OpenXLSX.OpenXLSX.XLCellReference.__Internal m_topLeft;
                internal global::OpenXLSX.OpenXLSX.XLCellReference.__Internal m_bottomRight;
                internal global::OpenXLSX.OpenXLSX.XLCell.__Internal m_currentCell;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal byte m_endReached;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellIterator@OpenXLSX@@QEAA@AEBVXLCellRange@1@W4XLIteratorLocation@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr cellRange, global::OpenXLSX.OpenXLSX.XLIteratorLocation loc);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellIterator@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellIterator@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??EXLCellIterator@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorPlusPlus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8XLCellIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9XLCellIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?distance@XLCellIterator@OpenXLSX@@QEAA_KAEBV12@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong Distance(__IntPtr __instance, __IntPtr last);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellIterator(native.ToPointer(), skipVTables);
            }

            internal static XLCellIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLCellIterator(global::OpenXLSX.OpenXLSX.XLCellRange cellRange, global::OpenXLSX.OpenXLSX.XLIteratorLocation loc)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(cellRange, null))
                    throw new global::System.ArgumentNullException("cellRange", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = cellRange.__Instance;
                __Internal.ctor(__Instance, __arg0, loc);
            }

            public XLCellIterator(global::OpenXLSX.OpenXLSX.XLCellIterator other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::OpenXLSX.OpenXLSX.XLCellIterator operator ++(global::OpenXLSX.OpenXLSX.XLCellIterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorPlusPlus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLCellIterator.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLCellIterator __op, global::OpenXLSX.OpenXLSX.XLCellIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return __opNull && rhsNull;
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLCellIterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLCellIterator __op, global::OpenXLSX.OpenXLSX.XLCellIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return !(__opNull && rhsNull);
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public ulong Distance(global::OpenXLSX.OpenXLSX.XLCellIterator last)
            {
                if (ReferenceEquals(last, null))
                    throw new global::System.ArgumentNullException("last", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = last.__Instance;
                var ___ret = __Internal.Distance(__Instance, __arg0);
                return ___ret;
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>This class encapsulates the concept of a cell range, i.e. a square area</para>
        /// <para>(or subset) of cells in a spreadsheet.</para>
        /// </summary>
        public unsafe partial class XLCellRange : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 104)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_dataNode;
                internal global::OpenXLSX.OpenXLSX.XLCellReference.__Internal m_topLeft;
                internal global::OpenXLSX.OpenXLSX.XLCellReference.__Internal m_bottomRight;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCellRange@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCellRange@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?begin@XLCellRange@OpenXLSX@@QEBA?AVXLCellIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Begin(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?end@XLCellRange@OpenXLSX@@QEBA?AVXLCellIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLCellRange@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numRows@XLCellRange@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint NumRows(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?numColumns@XLCellRange@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort NumColumns(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellRange> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCellRange>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCellRange managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCellRange managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCellRange __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCellRange(native.ToPointer(), skipVTables);
            }

            internal static XLCellRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCellRange)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCellRange __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCellRange(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCellRange.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCellRange(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCellRange(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Copy constructor [default].</summary>
            /// <param name="other">The range object to be copied.</param>
            /// <remarks>This implements the default copy constructor, i.e. memberwise copying.</remarks>
            public XLCellRange(global::OpenXLSX.OpenXLSX.XLCellRange other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCellRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::OpenXLSX.OpenXLSX.XLCellIterator Begin()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal();
                __Internal.Begin(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLCellIterator End()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal();
                __Internal.End(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public void Clear()
            {
                __Internal.Clear(__Instance);
            }

            /// <summary>Get the number of rows in the range.</summary>
            /// <returns>The number of rows.</returns>
            public uint NumRows
            {
                get
                {
                    var ___ret = __Internal.NumRows(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the number of columns in the range.</summary>
            /// <returns>The number of columns.</returns>
            public ushort NumColumns
            {
                get
                {
                    var ___ret = __Internal.NumColumns(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLColumn : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_columnNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColumn@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLColumn@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?width@XLColumn@OpenXLSX@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float Width(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setWidth@XLColumn@OpenXLSX@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWidth(__IntPtr __instance, float width);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isHidden@XLColumn@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsHidden(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHidden@XLColumn@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHidden(__IntPtr __instance, bool state);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLColumn> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLColumn>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLColumn managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLColumn managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLColumn __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLColumn(native.ToPointer(), skipVTables);
            }

            internal static XLColumn __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLColumn)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLColumn __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLColumn(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLColumn.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLColumn(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLColumn(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Copy Constructor [deleted]</summary>
            public XLColumn(global::OpenXLSX.OpenXLSX.XLColumn other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColumn.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the width of the column.</summary>
            /// <param name="width">The width of the column</param>
            /// <returns>
            /// <para>The width of the column.</para>
            /// <para>Set the width of the column</para>
            /// </returns>
            public float Width
            {
                get
                {
                    var ___ret = __Internal.Width(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetWidth(__Instance, value);
                }
            }

            /// <summary>Is the column hidden?</summary>
            /// <param name="state">The state of the column.</param>
            /// <returns>
            /// <para>The state of the column.</para>
            /// <para>Set the column to be shown or hidden.</para>
            /// </returns>
            public bool Hidden
            {
                get
                {
                    var ___ret = __Internal.IsHidden(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHidden(__Instance, value);
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>This class functions as a wrapper around any class that provides the necessary functionality for</para>
        /// <para>a zip archive.</para>
        /// </summary>
        /// <remarks>
        /// <para>This class works by applying 'type erasure'. This enables the use of objects of any class, the only</para>
        /// <para>requirement being that it provides the right interface. No inheritance from a base class is needed.</para>
        /// </remarks>
        public unsafe partial class IZipArchive : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_IZipArchive_S_Concept___N_std_S_default_delete__S0_ m_zipArchive;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0IZipArchive@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0IZipArchive@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1IZipArchive@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BIZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?open@IZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Open(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?close@IZipArchive@OpenXLSX@@QEBAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Close(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?save@IZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Save(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addEntry@IZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddEntry(__IntPtr __instance, __IntPtr name, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteEntry@IZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteEntry(__IntPtr __instance, __IntPtr entryName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getEntry@IZipArchive@OpenXLSX@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetEntry(__IntPtr __instance, __IntPtr @return, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasEntry@IZipArchive@OpenXLSX@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasEntry(__IntPtr __instance, __IntPtr entryName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isValid@IZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isOpen@IZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsOpen(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.IZipArchive> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.IZipArchive>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.IZipArchive managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.IZipArchive managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static IZipArchive __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new IZipArchive(native.ToPointer(), skipVTables);
            }

            internal static IZipArchive __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (IZipArchive)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static IZipArchive __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IZipArchive(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.IZipArchive.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private IZipArchive(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected IZipArchive(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor</summary>
            public IZipArchive()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.IZipArchive.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy constructor</summary>
            public IZipArchive(global::OpenXLSX.OpenXLSX.IZipArchive other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.IZipArchive.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.IZipArchive __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            public void Open(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Open(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void Close()
            {
                __Internal.Close(__Instance);
            }

            public void Save(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                __Internal.Save(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void AddEntry(string name, string data)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, data);
                var __arg1 = __basicString1.__Instance;
                __Internal.AddEntry(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void DeleteEntry(string entryName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, entryName);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteEntry(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public string GetEntry(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetEntry(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public bool HasEntry(string entryName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, entryName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.HasEntry(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool IsValid
            {
                get
                {
                    var ___ret = __Internal.IsValid(__Instance);
                    return ___ret;
                }
            }

            public bool IsOpen
            {
                get
                {
                    var ___ret = __Internal.IsOpen(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public enum XLContentType
        {
            Workbook = 0,
            WorkbookMacroEnabled = 1,
            Worksheet = 2,
            Chartsheet = 3,
            ExternalLink = 4,
            Theme = 5,
            Styles = 6,
            SharedStrings = 7,
            Drawing = 8,
            Chart = 9,
            ChartStyle = 10,
            ChartColorStyle = 11,
            ControlProperties = 12,
            CalculationChain = 13,
            VBAProject = 14,
            CoreProperties = 15,
            ExtendedProperties = 16,
            CustomProperties = 17,
            Comments = 18,
            Table = 19,
            VMLDrawing = 20,
            Unknown = 21
        }

        public unsafe partial class XLContentItem : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_contentNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentItem@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentItem@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLContentItem@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLContentItem@OpenXLSX@@QEBA?AW4XLContentType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLContentType Type(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?path@XLContentItem@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Path(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLContentItem> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLContentItem>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLContentItem managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLContentItem managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLContentItem __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLContentItem(native.ToPointer(), skipVTables);
            }

            internal static XLContentItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLContentItem)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLContentItem __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLContentItem(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLContentItem.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLContentItem(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLContentItem(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLContentItem()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLContentItem(global::OpenXLSX.OpenXLSX.XLContentItem other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::OpenXLSX.OpenXLSX.XLContentType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }

            public string Path
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Path(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>The purpose of this class is to load, store add and save item in the [Content_Types].xml file.</summary>
        public unsafe partial class XLContentTypes : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentTypes@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentTypes@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLContentTypes@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLContentTypes@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addOverride@XLContentTypes@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4XLContentType@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddOverride(__IntPtr __instance, __IntPtr path, global::OpenXLSX.OpenXLSX.XLContentType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteOverride@XLContentTypes@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteOverride(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteOverride@XLContentTypes@OpenXLSX@@QEAAXAEAVXLContentItem@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteOverride_1(__IntPtr __instance, __IntPtr item);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?contentItem@XLContentTypes@OpenXLSX@@QEAA?AVXLContentItem@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ContentItem(__IntPtr __instance, __IntPtr @return, __IntPtr path);
            }

            internal static new XLContentTypes __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLContentTypes(native.ToPointer(), skipVTables);
            }

            internal static new XLContentTypes __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLContentTypes)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLContentTypes __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLContentTypes(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLContentTypes(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLContentTypes(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLContentTypes()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLContentTypes(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLContentTypes(global::OpenXLSX.OpenXLSX.XLContentTypes other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Add a new override key/getValue pair to the data store.</summary>
            /// <param name="path">The key</param>
            /// <param name="type">The getValue</param>
            public void AddOverride(string path, global::OpenXLSX.OpenXLSX.XLContentType type)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                __Internal.AddOverride(__Instance, __arg0, type);
                __basicString0.Dispose();
            }

            public void DeleteOverride(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteOverride(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void DeleteOverride(global::OpenXLSX.OpenXLSX.XLContentItem item)
            {
                if (ReferenceEquals(item, null))
                    throw new global::System.ArgumentNullException("item", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = item.__Instance;
                __Internal.DeleteOverride_1(__Instance, __arg0);
            }

            public global::OpenXLSX.OpenXLSX.XLContentItem ContentItem(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLContentItem.__Internal();
                __Internal.ContentItem(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLContentItem.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLContentItem.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLContentTypes(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLContentTypes(xmlData);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLXmlData class encapsulates the properties and behaviour of the .xml files in an .xlsx file zip</para>
        /// <para>package. Objects of the XLXmlData type are intended to be stored centrally in an XLDocument object, from where</para>
        /// <para>they can be retrieved by other objects that encapsulates the behaviour of Excel elements, such as XLWorkbook</para>
        /// <para>and XLWorksheet.</para>
        /// </summary>
        public unsafe partial class XLXmlData : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public partial struct __Internal
            {
                internal __IntPtr m_parentDoc;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_xmlPath;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_xmlID;
                internal global::OpenXLSX.OpenXLSX.XLContentType m_xmlType;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_document___N_std_S_default_delete__S0_ m_xmlDoc;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlData@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLXmlData@OpenXLSX@@QEAA@PEAVXLDocument@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1W4XLContentType@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr parentDoc, __IntPtr xmlPath, __IntPtr xmlId, global::OpenXLSX.OpenXLSX.XLContentType xmlType);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLXmlData@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getRawData@XLXmlData@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetRawData(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setRawData@XLXmlData@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetRawData(__IntPtr __instance, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getParentDoc@XLXmlData@OpenXLSX@@QEAAPEAVXLDocument@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetParentDoc(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlPath@XLXmlData@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetXmlPath(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlID@XLXmlData@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetXmlID(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlType@XLXmlData@OpenXLSX@@QEBA?AW4XLContentType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLContentType GetXmlType(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlDocument@XLXmlData@OpenXLSX@@QEAAPEAVxml_document@pugi@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetXmlDocument(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlData> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLXmlData>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLXmlData managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLXmlData managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLXmlData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLXmlData(native.ToPointer(), skipVTables);
            }

            internal static XLXmlData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLXmlData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLXmlData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLXmlData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLXmlData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLXmlData(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>
            /// <para>Default constructor. All member variables are default constructed. Except for</para>
            /// <para>the raw XML data, none of the member variables can be modified after construction. Hence, objects created</para>
            /// <para>using the default constructor can only serve as null objects and targets for the move assignemnt operator.</para>
            /// </summary>
            public XLXmlData()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>
            /// <para>Constructor. This constructor creates objects with the given parameters. the xmlId and the xmlType</para>
            /// <para>parameters have default values. These are only useful for relationship (.rels) files and the</para>
            /// <para>[Content_Types].xml file located in the root directory of the zip package.</para>
            /// </summary>
            /// <param name="parentDoc">A pointer to the parent XLDocument object.</param>
            /// <param name="xmlPath">A std::string with the file path in zip package.</param>
            /// <param name="xmlId">A std::string with the relationship ID of the file (used in the XLRelationships class)</param>
            /// <param name="xmlType">The type of object the XML file represents, e.g. XLWorkbook or XLWorksheet.</param>
            public XLXmlData(global::OpenXLSX.OpenXLSX.XLDocument parentDoc, string xmlPath, string xmlId, global::OpenXLSX.OpenXLSX.XLContentType xmlType)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLXmlData.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = parentDoc is null ? __IntPtr.Zero : parentDoc.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, xmlPath);
                var __arg1 = __basicString1.__Instance;
                var __basicString2 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString2, xmlId);
                var __arg2 = __basicString2.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1, __arg2, xmlType);
                __basicString1.Dispose();
                __basicString2.Dispose();
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Get the raw data for the underlying XML document. This function will retrieve the raw XML text data</para>
            /// <para>from the underlying XMLDocument object. This will mainly be used when saving data to the .xlsx package</para>
            /// <para>using the save function in the XLDocument class.</para>
            /// </summary>
            /// <param name="data">A std::string with the raw XML text.</param>
            /// <returns>
            /// <para>A std::string with the raw XML text data.</para>
            /// <para>Set the raw data for the underlying XML document. Being able to set the XML data directly is useful</para>
            /// <para>when creating a new file using a XML file template. E.g., when creating a new worksheet, the XML code for</para>
            /// <para>a minimum viable XLWorksheet object can be added using this function.</para>
            /// </returns>
            public string RawData
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetRawData(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetRawData(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            /// <summary>Access the parent XLDocument object.</summary>
            /// <returns>A pointer to the parent XLDocument object.</returns>
            public global::OpenXLSX.OpenXLSX.XLDocument ParentDoc
            {
                get
                {
                    var ___ret = __Internal.GetParentDoc(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLDocument.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            /// <summary>Retrieve the path of the XML data in the .xlsx zip archive.</summary>
            /// <returns>A std::string with the path.</returns>
            public string XmlPath
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetXmlPath(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Retrieve the relationship ID of the XML file.</summary>
            /// <returns>A std::string with the relationship ID.</returns>
            public string XmlID
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetXmlID(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Retrieve the type represented by the XML data.</summary>
            /// <returns>A XLContentType getValue representing the type.</returns>
            public global::OpenXLSX.OpenXLSX.XLContentType XmlType
            {
                get
                {
                    var ___ret = __Internal.GetXmlType(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Access the underlying XMLDocument object.</summary>
            /// <returns>A pointer to the XMLDocument object.</returns>
            public global::OpenXLSX.Pugi.XmlDocument XmlDocument
            {
                get
                {
                    var ___ret = __Internal.GetXmlDocument(__Instance);
                    var __result0 = global::OpenXLSX.Pugi.XmlDocument.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLProperties : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLProperties@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLProperties@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLProperties@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLProperties@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty(__IntPtr __instance, __IntPtr name, __IntPtr value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty(__IntPtr __instance, __IntPtr name, int value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty_1(__IntPtr __instance, __IntPtr name, double value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?property@XLProperties@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Property(__IntPtr __instance, __IntPtr @return, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteProperty@XLProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteProperty(__IntPtr __instance, __IntPtr name);
            }

            internal static new XLProperties __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLProperties(native.ToPointer(), skipVTables);
            }

            internal static new XLProperties __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLProperties)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLProperties __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLProperties(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLProperties(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLProperties(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLProperties()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLProperties(global::OpenXLSX.OpenXLSX.XLProperties other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLProperties.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLProperties.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetProperty(string name, string value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, value);
                var __arg1 = __basicString1.__Instance;
                __Internal.SetProperty(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void SetProperty(string name, int value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetProperty(__Instance, __arg0, value);
                __basicString0.Dispose();
            }

            public void SetProperty(string name, double value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetProperty_1(__Instance, __arg0, value);
                __basicString0.Dispose();
            }

            public string Property(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Property(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public void DeleteProperty(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteProperty(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLProperties(xmlData);
            }
        }

        /// <summary>
        /// <para>This class is a specialization of the XLAbstractXMLFile, with the purpose of the representing the</para>
        /// <para>document app properties in the app.xml file (docProps folder) in the .xlsx package.</para>
        /// </summary>
        public unsafe partial class XLAppProperties : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAppProperties@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAppProperties@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLAppProperties@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLAppProperties@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddSheetName(__IntPtr __instance, __IntPtr title);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteSheetName(__IntPtr __instance, __IntPtr title);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSheetName(__IntPtr __instance, __IntPtr oldTitle, __IntPtr newTitle);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addHeadingPair@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddHeadingPair(__IntPtr __instance, __IntPtr name, int value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteHeadingPair@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteHeadingPair(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHeadingPair@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeadingPair(__IntPtr __instance, __IntPtr name, int newValue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty(__IntPtr __instance, __IntPtr name, __IntPtr value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?property@XLAppProperties@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Property(__IntPtr __instance, __IntPtr @return, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteProperty@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteProperty(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?appendSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AppendSheetName(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?prependSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PrependSheetName(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?insertSheetName@XLAppProperties@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void InsertSheetName(__IntPtr __instance, __IntPtr sheetName, uint index);
            }

            internal static new XLAppProperties __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLAppProperties(native.ToPointer(), skipVTables);
            }

            internal static new XLAppProperties __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLAppProperties)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLAppProperties __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLAppProperties(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLAppProperties(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLAppProperties(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLAppProperties()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLAppProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLAppProperties(global::OpenXLSX.OpenXLSX.XLAppProperties other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void AddSheetName(string title)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, title);
                var __arg0 = __basicString0.__Instance;
                __Internal.AddSheetName(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void DeleteSheetName(string title)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, title);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteSheetName(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void SetSheetName(string oldTitle, string newTitle)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, oldTitle);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, newTitle);
                var __arg1 = __basicString1.__Instance;
                __Internal.SetSheetName(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void AddHeadingPair(string name, int value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.AddHeadingPair(__Instance, __arg0, value);
                __basicString0.Dispose();
            }

            public void DeleteHeadingPair(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteHeadingPair(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void SetHeadingPair(string name, int newValue)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetHeadingPair(__Instance, __arg0, newValue);
                __basicString0.Dispose();
            }

            public void SetProperty(string name, string value)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, value);
                var __arg1 = __basicString1.__Instance;
                __Internal.SetProperty(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public string Property(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Property(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public void DeleteProperty(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteProperty(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void AppendSheetName(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.AppendSheetName(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void PrependSheetName(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.PrependSheetName(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void InsertSheetName(string sheetName, uint index)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.InsertSheetName(__Instance, __arg0, index);
                __basicString0.Dispose();
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLAppProperties(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLAppProperties(xmlData);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>An enum of the possible relationship (or XML document) types used in relationship (.rels) XML files.</summary>
        public enum XLRelationshipType
        {
            CoreProperties = 0,
            ExtendedProperties = 1,
            CustomProperties = 2,
            Workbook = 3,
            Worksheet = 4,
            Chartsheet = 5,
            Dialogsheet = 6,
            Macrosheet = 7,
            CalculationChain = 8,
            ExternalLink = 9,
            ExternalLinkPath = 10,
            Theme = 11,
            Styles = 12,
            Chart = 13,
            ChartStyle = 14,
            ChartColorStyle = 15,
            Image = 16,
            Drawing = 17,
            VMLDrawing = 18,
            SharedStrings = 19,
            PrinterSettings = 20,
            VBAProject = 21,
            ControlProperties = 22,
            Unknown = 23
        }

        /// <summary>An encapsulation of a relationship item, i.e. an XML file in the document, its type and an ID number.</summary>
        public unsafe partial class XLRelationshipItem : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_relationshipNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationshipItem@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationshipItem@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRelationshipItem@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLRelationshipItem@OpenXLSX@@QEBA?AW4XLRelationshipType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLRelationshipType Type(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?target@XLRelationshipItem@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Target(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?id@XLRelationshipItem@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Id(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRelationshipItem> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRelationshipItem>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRelationshipItem managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRelationshipItem managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRelationshipItem __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRelationshipItem(native.ToPointer(), skipVTables);
            }

            internal static XLRelationshipItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRelationshipItem)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRelationshipItem __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRelationshipItem(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRelationshipItem(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRelationshipItem(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLRelationshipItem()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLRelationshipItem(global::OpenXLSX.OpenXLSX.XLRelationshipItem other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the type of the current relationship item.</summary>
            /// <returns>An XLRelationshipType enum object, corresponding to the type.</returns>
            public global::OpenXLSX.OpenXLSX.XLRelationshipType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the target, i.e. the path to the XML file the relationship item refers to.</summary>
            /// <returns>An XMLAttribute object containing the Target getValue.</returns>
            public string Target
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Target(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            /// <summary>Get the id of the relationship item.</summary>
            /// <returns>An XMLAttribute object containing the Id getValue.</returns>
            public string Id
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Id(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }

        /// <summary>An encapsulation of relationship files (.rels files) in an Excel document package.</summary>
        public unsafe partial class XLRelationships : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationships@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationships@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRelationships@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRelationships@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?relationshipById@XLRelationships@OpenXLSX@@QEBA?AVXLRelationshipItem@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RelationshipById(__IntPtr __instance, __IntPtr @return, __IntPtr id);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?relationshipByTarget@XLRelationships@OpenXLSX@@QEBA?AVXLRelationshipItem@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RelationshipByTarget(__IntPtr __instance, __IntPtr @return, __IntPtr target);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteRelationship@XLRelationships@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteRelationship(__IntPtr __instance, __IntPtr relID);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteRelationship@XLRelationships@OpenXLSX@@QEAAXAEBVXLRelationshipItem@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteRelationship_1(__IntPtr __instance, __IntPtr item);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addRelationship@XLRelationships@OpenXLSX@@QEAA?AVXLRelationshipItem@2@W4XLRelationshipType@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddRelationship(__IntPtr __instance, __IntPtr @return, global::OpenXLSX.OpenXLSX.XLRelationshipType type, __IntPtr target);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?targetExists@XLRelationships@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TargetExists(__IntPtr __instance, __IntPtr target);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?idExists@XLRelationships@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IdExists(__IntPtr __instance, __IntPtr id);
            }

            internal static new XLRelationships __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRelationships(native.ToPointer(), skipVTables);
            }

            internal static new XLRelationships __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRelationships)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRelationships __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRelationships(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLRelationships(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRelationships(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            public XLRelationships()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationships.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLRelationships(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationships.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLRelationships(global::OpenXLSX.OpenXLSX.XLRelationships other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRelationships.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLRelationships.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLRelationships.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Look up a relationship item by ID.</summary>
            /// <param name="id">The ID string of the relationship item to retrieve.</param>
            /// <returns>An XLRelationshipItem object.</returns>
            public global::OpenXLSX.OpenXLSX.XLRelationshipItem RelationshipById(string id)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, id);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal();
                __Internal.RelationshipById(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLRelationshipItem.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Look up a relationship item by Target.</summary>
            /// <param name="target">The Target string of the relationship item to retrieve.</param>
            /// <returns>An XLRelationshipItem object.</returns>
            public global::OpenXLSX.OpenXLSX.XLRelationshipItem RelationshipByTarget(string target)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, target);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal();
                __Internal.RelationshipByTarget(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLRelationshipItem.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public void DeleteRelationship(string relID)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, relID);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteRelationship(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Delete an item from the Relationships register</summary>
            /// <param name="item">The XLRelationshipItem object to delete.</param>
            public void DeleteRelationship(global::OpenXLSX.OpenXLSX.XLRelationshipItem item)
            {
                if (ReferenceEquals(item, null))
                    throw new global::System.ArgumentNullException("item", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = item.__Instance;
                __Internal.DeleteRelationship_1(__Instance, __arg0);
            }

            /// <summary>Add a new relationship item to the XLRelationships object.</summary>
            /// <param name="type">The type of the new relationship item.</param>
            /// <param name="target">The target (or path) of the XML file for the relationship item.</param>
            public global::OpenXLSX.OpenXLSX.XLRelationshipItem AddRelationship(global::OpenXLSX.OpenXLSX.XLRelationshipType type, string target)
            {
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, target);
                var __arg1 = __basicString1.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal();
                __Internal.AddRelationship(__Instance, new IntPtr(&___ret), type, __arg1);
                __basicString1.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLRelationshipItem.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRelationshipItem.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Check if a XLRelationshipItem with the given Target string exists.</summary>
            /// <param name="target">The Target string to look up.</param>
            /// <returns>true if the XLRelationshipItem exists; otherwise false.</returns>
            public bool TargetExists(string target)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, target);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.TargetExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Check if a XLRelationshipItem with the given Id string exists.</summary>
            /// <param name="id">The Id string to look up.</param>
            /// <returns>true if the XLRelationshipItem exists; otherwise false.</returns>
            public bool IdExists(string id)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, id);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.IdExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLRelationships(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLRelationships(xmlData);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLSheetType class is an enumeration of the available sheet types, e.g. Worksheet (ordinary</para>
        /// <para>spreadsheets), and Chartsheet (sheets with only a chart).</para>
        /// </summary>
        public enum XLSheetType
        {
            Worksheet = 0,
            Chartsheet = 1,
            Dialogsheet = 2,
            Macrosheet = 3
        }

        /// <summary>
        /// <para>This class encapsulates the concept of a Workbook. It provides access to the individual sheets</para>
        /// <para>(worksheets or chartsheets), as well as functionality for adding, deleting, moving and renaming sheets.</para>
        /// </summary>
        public unsafe partial class XLWorkbook : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorkbook@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorkbook@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorkbook@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLWorkbook@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sheet@XLWorkbook@OpenXLSX@@QEAA?AVXLSheet@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sheet(__IntPtr __instance, __IntPtr @return, ushort index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sheet@XLWorkbook@OpenXLSX@@QEAA?AVXLSheet@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Sheet(__IntPtr __instance, __IntPtr @return, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?worksheet@XLWorkbook@OpenXLSX@@QEAA?AVXLWorksheet@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Worksheet(__IntPtr __instance, __IntPtr @return, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?chartsheet@XLWorkbook@OpenXLSX@@QEAA?AVXLChartsheet@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Chartsheet(__IntPtr __instance, __IntPtr @return, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteSheet@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteSheet(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addWorksheet@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddWorksheet(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cloneSheet@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CloneSheet(__IntPtr __instance, __IntPtr existingName, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSheetIndex@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSheetIndex(__IntPtr __instance, __IntPtr sheetName, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?indexOfSheet@XLWorkbook@OpenXLSX@@QEBAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint IndexOfSheet(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?typeOfSheet@XLWorkbook@OpenXLSX@@QEBA?AW4XLSheetType@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLSheetType TypeOfSheet(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?typeOfSheet@XLWorkbook@OpenXLSX@@QEBA?AW4XLSheetType@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLSheetType TypeOfSheet(__IntPtr __instance, uint index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sheetExists@XLWorkbook@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SheetExists(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?worksheetExists@XLWorkbook@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool WorksheetExists(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?chartsheetExists@XLWorkbook@OpenXLSX@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ChartsheetExists(__IntPtr __instance, __IntPtr sheetName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?updateSheetReferences@XLWorkbook@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateSheetReferences(__IntPtr __instance, __IntPtr oldName, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteNamedRanges@XLWorkbook@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteNamedRanges(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setFullCalculationOnLoad@XLWorkbook@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetFullCalculationOnLoad(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sheetCount@XLWorkbook@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint SheetCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?worksheetCount@XLWorkbook@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint WorksheetCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?chartsheetCount@XLWorkbook@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint ChartsheetCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?sharedStrings@XLWorkbook@OpenXLSX@@QEAA?AVXLSharedStrings@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SharedStrings(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasSharedStrings@XLWorkbook@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasSharedStrings(__IntPtr __instance);
            }

            internal static new XLWorkbook __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLWorkbook(native.ToPointer(), skipVTables);
            }

            internal static new XLWorkbook __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLWorkbook)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLWorkbook __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLWorkbook(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLWorkbook(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLWorkbook(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>Default constructor. Creates an empty ('null') XLWorkbook object.</summary>
            public XLWorkbook()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. Takes a pointer to an XLXmlData object (stored in the parent XLDocument object).</summary>
            /// <param name="xmlData">A pointer to the underlying XLXmlData object, which holds the XML data.</param>
            /// <remarks>Do not create an XLWorkbook object directly. Get access through the an XLDocument object.</remarks>
            public XLWorkbook(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <param name="other">The XLWorkbook object to be copied.</param>
            /// <remarks>The copy constructor has been explicitly defaulted.</remarks>
            public XLWorkbook(global::OpenXLSX.OpenXLSX.XLWorkbook other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get the sheet (worksheet or chartsheet) at the given index.</summary>
            /// <param name="index">The index at which the desired sheet is located.</param>
            /// <returns>A pointer to an XLAbstractSheet with the sheet at the index.</returns>
            /// <remarks>The index must be 1-based (rather than 0-based) as this is the default for Excel spreadsheets.</remarks>
            public global::OpenXLSX.OpenXLSX.XLSheet Sheet(ushort index)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLSheet.__Internal();
                __Internal.Sheet(__Instance, new IntPtr(&___ret), index);
                var _____ret = global::OpenXLSX.OpenXLSX.XLSheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLSheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the sheet (worksheet or chartsheet) with the given name.</summary>
            /// <param name="sheetName">The name at which the desired sheet is located.</param>
            /// <returns>A pointer to an XLAbstractSheet with the sheet at the index.</returns>
            public global::OpenXLSX.OpenXLSX.XLSheet Sheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLSheet.__Internal();
                __Internal.Sheet(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLSheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLSheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLWorksheet Worksheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal();
                __Internal.Worksheet(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLWorksheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLChartsheet Chartsheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal();
                __Internal.Chartsheet(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLChartsheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Delete sheet (worksheet or chartsheet) from the workbook.</summary>
            /// <param name="sheetName">Name of the sheet to delete.</param>
            /// <remarks>
            /// <para>XLException An exception will be thrown if trying to delete the last worksheet in the workbook</para>
            /// <para>A workbook must contain at least one worksheet. Trying to delete the last worksheet from the</para>
            /// <para>workbook will trow an exception.</para>
            /// </remarks>
            public void DeleteSheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteSheet(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void AddWorksheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.AddWorksheet(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void CloneSheet(string existingName, string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, existingName);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, newName);
                var __arg1 = __basicString1.__Instance;
                __Internal.CloneSheet(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void SetSheetIndex(string sheetName, uint index)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetSheetIndex(__Instance, __arg0, index);
                __basicString0.Dispose();
            }

            public uint IndexOfSheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.IndexOfSheet(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.XLSheetType TypeOfSheet(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.TypeOfSheet(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public global::OpenXLSX.OpenXLSX.XLSheetType TypeOfSheet(uint index)
            {
                var ___ret = __Internal.TypeOfSheet(__Instance, index);
                return ___ret;
            }

            public bool SheetExists(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.SheetExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool WorksheetExists(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.WorksheetExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool ChartsheetExists(string sheetName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, sheetName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.ChartsheetExists(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public void UpdateSheetReferences(string oldName, string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, oldName);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, newName);
                var __arg1 = __basicString1.__Instance;
                __Internal.UpdateSheetReferences(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void DeleteNamedRanges()
            {
                __Internal.DeleteNamedRanges(__Instance);
            }

            /// <summary>set a flag to force full calculation upon loading the file in Excel</summary>
            public void SetFullCalculationOnLoad()
            {
                __Internal.SetFullCalculationOnLoad(__Instance);
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLWorkbook(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLWorkbook(xmlData);
            }

            public uint SheetCount
            {
                get
                {
                    var ___ret = __Internal.SheetCount(__Instance);
                    return ___ret;
                }
            }

            public uint WorksheetCount
            {
                get
                {
                    var ___ret = __Internal.WorksheetCount(__Instance);
                    return ___ret;
                }
            }

            public uint ChartsheetCount
            {
                get
                {
                    var ___ret = __Internal.ChartsheetCount(__Instance);
                    return ___ret;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLSharedStrings SharedStrings
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal();
                    __Internal.SharedStrings(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLSharedStrings.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public bool HasSharedStrings
            {
                get
                {
                    var ___ret = __Internal.HasSharedStrings(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLZipArchive : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal global::Std.SharedPtr.__Internal m_archive;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLZipArchive@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLZipArchive@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLZipArchive@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?open@XLZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Open(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?close@XLZipArchive@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Close(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?save@XLZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Save(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?addEntry@XLZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AddEntry(__IntPtr __instance, __IntPtr name, __IntPtr data);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteEntry@XLZipArchive@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteEntry(__IntPtr __instance, __IntPtr entryName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getEntry@XLZipArchive@OpenXLSX@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetEntry(__IntPtr __instance, __IntPtr @return, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasEntry@XLZipArchive@OpenXLSX@@QEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasEntry(__IntPtr __instance, __IntPtr entryName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isValid@XLZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isOpen@XLZipArchive@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsOpen(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLZipArchive> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLZipArchive>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLZipArchive managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLZipArchive managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLZipArchive __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLZipArchive(native.ToPointer(), skipVTables);
            }

            internal static XLZipArchive __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLZipArchive)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLZipArchive __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLZipArchive(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLZipArchive.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLZipArchive(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLZipArchive(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLZipArchive()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLZipArchive.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLZipArchive(global::OpenXLSX.OpenXLSX.XLZipArchive other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLZipArchive.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLZipArchive __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            public void Open(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Open(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void Close()
            {
                __Internal.Close(__Instance);
            }

            public void Save(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                __Internal.Save(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public void AddEntry(string name, string data)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, data);
                var __arg1 = __basicString1.__Instance;
                __Internal.AddEntry(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void DeleteEntry(string entryName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, entryName);
                var __arg0 = __basicString0.__Instance;
                __Internal.DeleteEntry(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public string GetEntry(string name)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, name);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.GetEntry(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            public bool HasEntry(string entryName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, entryName);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.HasEntry(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            public bool IsValid
            {
                get
                {
                    var ___ret = __Internal.IsValid(__Instance);
                    return ___ret;
                }
            }

            public bool IsOpen
            {
                get
                {
                    var ___ret = __Internal.IsOpen(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace Zippy
    {
        public unsafe partial class ZipArchive
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Zippy.ZipArchive> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Zippy.ZipArchive>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.Zippy.ZipArchive managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.Zippy.ZipArchive managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static ZipArchive __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new ZipArchive(native.ToPointer(), skipVTables);
            }

            internal static ZipArchive __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (ZipArchive)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static ZipArchive __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ZipArchive(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ZipArchive(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected ZipArchive(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLDocumentProperties class is an enumeration of the possible properties (metadata) that can be set</para>
        /// <para>for a XLDocument object (and .xlsx file)</para>
        /// </summary>
        public enum XLProperty
        {
            Title = 0,
            Subject = 1,
            Creator = 2,
            Keywords = 3,
            Description = 4,
            LastModifiedBy = 5,
            LastPrinted = 6,
            CreationDate = 7,
            ModificationDate = 8,
            Category = 9,
            Application = 10,
            DocSecurity = 11,
            ScaleCrop = 12,
            Manager = 13,
            Company = 14,
            LinksUpToDate = 15,
            SharedDoc = 16,
            HyperlinkBase = 17,
            HyperlinksChanged = 18,
            AppVersion = 19
        }

        /// <summary>
        /// <para>This class encapsulates the concept of an excel file. It is different from the XLWorkbook, in that an</para>
        /// <para>XLDocument holds an XLWorkbook together with its metadata, as well as methods for opening,</para>
        /// <para>closing and saving the document.The XLDocument is the entrypoint for clients</para>
        /// <para>using the RapidXLSX library.</para>
        /// </summary>
        public unsafe partial class XLDocument : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 192)]
            public partial struct __Internal
            {
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_filePath;
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C m_realPath;
                internal global::Std.List.__Internalc__N_std_S_list____N_OpenXLSX_S_XLXmlData___N_std_S_allocator__S0_ m_data;
                internal global::Std.Deque.__Internalc__N_std_S_deque____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ m_sharedStringCache;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal global::OpenXLSX.OpenXLSX.XLRelationships.__Internal m_docRelationships;
                internal global::OpenXLSX.OpenXLSX.XLRelationships.__Internal m_wbkRelationships;
                internal global::OpenXLSX.OpenXLSX.XLContentTypes.__Internal m_contentTypes;
                internal global::OpenXLSX.OpenXLSX.XLAppProperties.__Internal m_appProperties;
                internal global::OpenXLSX.OpenXLSX.XLProperties.__Internal m_coreProperties;
                internal global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal m_workbook;
                internal global::OpenXLSX.OpenXLSX.IZipArchive.__Internal m_archive;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDocument@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLDocument@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBVIZipArchive@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr docPath, __IntPtr zipArchive);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLDocument@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?open@XLDocument@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Open(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?create@XLDocument@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Create(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?close@XLDocument@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Close(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?save@XLDocument@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Save(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?saveAs@XLDocument@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SaveAs(__IntPtr __instance, __IntPtr fileName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?property@XLDocument@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4XLProperty@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Property(__IntPtr __instance, __IntPtr @return, global::OpenXLSX.OpenXLSX.XLProperty prop);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setProperty@XLDocument@OpenXLSX@@QEAAXW4XLProperty@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetProperty(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLProperty prop, __IntPtr value);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLDocument@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?deleteProperty@XLDocument@OpenXLSX@@QEAAXW4XLProperty@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DeleteProperty(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLProperty theProperty);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?execCommand@XLDocument@OpenXLSX@@QEAAXAEBVXLCommand@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ExecCommand(__IntPtr __instance, __IntPtr command);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?execQuery@XLDocument@OpenXLSX@@QEAA?AVXLQuery@2@AEBV32@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ExecQuery(__IntPtr __instance, __IntPtr @return, __IntPtr query);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?extractXmlFromArchive@XLDocument@OpenXLSX@@IEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV34@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ExtractXmlFromArchive(__IntPtr __instance, __IntPtr @return, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getXmlData@XLDocument@OpenXLSX@@IEAAPEAVXLXmlData@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetXmlData(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hasXmlData@XLDocument@OpenXLSX@@IEBA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool HasXmlData(__IntPtr __instance, __IntPtr path);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name@XLDocument@OpenXLSX@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Name(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?path@XLDocument@OpenXLSX@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Path(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?workbook@XLDocument@OpenXLSX@@QEBA?AVXLWorkbook@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Workbook(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isOpen@XLDocument@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsOpen(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDocument> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLDocument>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLDocument managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLDocument managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLDocument __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLDocument(native.ToPointer(), skipVTables);
            }

            internal static XLDocument __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLDocument)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLDocument __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLDocument(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLDocument(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLDocument(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Constructor. The default constructor with no arguments.</summary>
            public XLDocument()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDocument.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Constructor. An alternative constructor, taking the path to the .xlsx file as an argument.</summary>
            /// <param name="docPath">A std::string with the path to the .xlsx file.</param>
            public XLDocument(string docPath, global::OpenXLSX.OpenXLSX.IZipArchive zipArchive)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLDocument.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, docPath);
                var __arg0 = __basicString0.__Instance;
                if (ReferenceEquals(zipArchive, null))
                    throw new global::System.ArgumentNullException("zipArchive", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = zipArchive.__Instance;
                __Internal.ctor(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Open the .xlsx file with the given path</summary>
            /// <param name="fileName">The path of the .xlsx file to open</param>
            public void Open(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Open(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Create a new .xlsx file with the given name.</summary>
            /// <param name="fileName">The path of the new .xlsx file.</param>
            public void Create(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Create(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Close the current document</summary>
            public void Close()
            {
                __Internal.Close(__Instance);
            }

            /// <summary>Save the current document using the current filename, overwriting the existing file.</summary>
            /// <returns>true if successful; otherwise false.</returns>
            public void Save()
            {
                __Internal.Save(__Instance);
            }

            /// <summary>Save the document with a new name. If a file exists with that name, it will be overwritten.</summary>
            /// <param name="fileName">The path of the file</param>
            /// <returns>true if successful; otherwise false.</returns>
            public void SaveAs(string fileName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, fileName);
                var __arg0 = __basicString0.__Instance;
                __Internal.SaveAs(__Instance, __arg0);
                __basicString0.Dispose();
            }

            /// <summary>Get the requested document property.</summary>
            /// <param name="prop">The name of the property to get.</param>
            /// <returns>The property as a string</returns>
            public string Property(global::OpenXLSX.OpenXLSX.XLProperty prop)
            {
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.Property(__Instance, new IntPtr(&___ret), prop);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            /// <summary>Set a property</summary>
            /// <param name="prop">The property to set.</param>
            /// <param name="value">The getValue of the property, as a string</param>
            public void SetProperty(global::OpenXLSX.OpenXLSX.XLProperty prop, string value)
            {
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, value);
                var __arg1 = __basicString1.__Instance;
                __Internal.SetProperty(__Instance, prop, __arg1);
                __basicString1.Dispose();
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLDocument __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }

            /// <summary>Delete the property from the document</summary>
            /// <param name="theProperty">The property to delete from the document</param>
            public void DeleteProperty(global::OpenXLSX.OpenXLSX.XLProperty theProperty)
            {
                __Internal.DeleteProperty(__Instance, theProperty);
            }

            public void ExecCommand(global::OpenXLSX.OpenXLSX.XLCommand command)
            {
                if (ReferenceEquals(command, null))
                    throw new global::System.ArgumentNullException("command", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = command.__Instance;
                __Internal.ExecCommand(__Instance, __arg0);
            }

            public global::OpenXLSX.OpenXLSX.XLQuery ExecQuery(global::OpenXLSX.OpenXLSX.XLQuery query)
            {
                if (ReferenceEquals(query, null))
                    throw new global::System.ArgumentNullException("query", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = query.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLQuery.__Internal();
                __Internal.ExecQuery(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::OpenXLSX.OpenXLSX.XLQuery.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLQuery.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get an XML file from the .xlsx archive.</summary>
            /// <param name="path">The relative path of the file.</param>
            /// <returns>A std::string with the content of the file</returns>
            protected string ExtractXmlFromArchive(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                __Internal.ExtractXmlFromArchive(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                __basicStringRet0.Dispose();
                return __retString0;
            }

            protected global::OpenXLSX.OpenXLSX.XLXmlData GetXmlData(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.GetXmlData(__Instance, __arg0);
                __basicString0.Dispose();
                var __result0 = global::OpenXLSX.OpenXLSX.XLXmlData.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            protected bool HasXmlData(string path)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, path);
                var __arg0 = __basicString0.__Instance;
                var ___ret = __Internal.HasXmlData(__Instance, __arg0);
                __basicString0.Dispose();
                return ___ret;
            }

            /// <summary>Get the filename of the current document, e.g. &quot;spreadsheet.xlsx&quot;.</summary>
            /// <returns>A std::string with the filename.</returns>
            public string Name
            {
                get
                {
                    var ___ret = __Internal.Name(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }
            }

            /// <summary>Get the full path of the current document, e.g. &quot;drive/blah/spreadsheet.xlsx&quot;</summary>
            /// <returns>A std::string with the path.</returns>
            public string Path
            {
                get
                {
                    var ___ret = __Internal.Path(__Instance);
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(___ret);
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }
            }

            /// <summary>Get the underlying workbook object, as a const object.</summary>
            /// <returns>A const pointer to the XLWorkbook object.</returns>
            public global::OpenXLSX.OpenXLSX.XLWorkbook Workbook
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal();
                    __Internal.Workbook(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLWorkbook.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLWorkbook.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            public bool IsOpen
            {
                get
                {
                    var ___ret = __Internal.IsOpen(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>This class encapsulates a (non-const) iterator, for iterating over the cells in a row.</summary>
        /// <remarks>Consider implementing a const iterator also</remarks>
        public unsafe partial class XLRowDataIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLRowDataRange___N_std_S_default_delete__S0_ m_dataRange;
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_cellNode;
                internal global::OpenXLSX.OpenXLSX.XLCell.__Internal m_currentCell;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowDataIterator@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowDataIterator@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??EXLRowDataIterator@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorPlusPlus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8XLRowDataIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9XLRowDataIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr __instance, __IntPtr rhs);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowDataIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowDataIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowDataIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowDataIterator(native.ToPointer(), skipVTables);
            }

            internal static XLRowDataIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowDataIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowDataIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowDataIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRowDataIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowDataIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLRowDataIterator(global::OpenXLSX.OpenXLSX.XLRowDataIterator other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Pre-increment of the iterator.</summary>
            /// <returns>Reference to the iterator object.</returns>
            public static global::OpenXLSX.OpenXLSX.XLRowDataIterator operator ++(global::OpenXLSX.OpenXLSX.XLRowDataIterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorPlusPlus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLRowDataIterator.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            /// <summary>Equality operator.</summary>
            /// <param name="rhs">XLRowDataIterator to compare to.</param>
            /// <returns>true if equal, otherwise false.</returns>
            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLRowDataIterator __op, global::OpenXLSX.OpenXLSX.XLRowDataIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return __opNull && rhsNull;
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLRowDataIterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal*) __Instance).GetHashCode();
            }

            /// <summary>Non-equality operator.</summary>
            /// <param name="rhs">XLRowDataIterator to compare to.</param>
            /// <returns>false if equal, otherwise true.</returns>
            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLRowDataIterator __op, global::OpenXLSX.OpenXLSX.XLRowDataIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return !(__opNull && rhsNull);
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>This class encapsulates the concept of a contiguous range of cells in a row.</summary>
        public unsafe partial class XLRowDataRange : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_rowNode;
                internal ushort m_firstCol;
                internal ushort m_lastCol;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowDataRange@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowDataRange@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?begin@XLRowDataRange@OpenXLSX@@QEAA?AVXLRowDataIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Begin(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?end@XLRowDataRange@OpenXLSX@@QEAA?AVXLRowDataIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?size@XLRowDataRange@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort Size(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataRange> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataRange>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowDataRange managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowDataRange managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowDataRange __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowDataRange(native.ToPointer(), skipVTables);
            }

            internal static XLRowDataRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowDataRange)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowDataRange __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowDataRange(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRowDataRange(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowDataRange(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Copy constructor.</summary>
            /// <param name="other">Object to be copied.</param>
            public XLRowDataRange(global::OpenXLSX.OpenXLSX.XLRowDataRange other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Get an iterator to the first element.</summary>
            /// <returns>An XLRowDataIterator pointing to the first element.</returns>
            public global::OpenXLSX.OpenXLSX.XLRowDataIterator Begin()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal();
                __Internal.Begin(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get an iterator to (one-past) the last element.</summary>
            /// <returns>An XLRowDataIterator pointing to (one past) the last element.</returns>
            public global::OpenXLSX.OpenXLSX.XLRowDataIterator End()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal();
                __Internal.End(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the size (length) of the range.</summary>
            /// <returns>The size of the range.</returns>
            public ushort Size
            {
                get
                {
                    var ___ret = __Internal.Size(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>The XLRowDataProxy is used as a proxy object when getting or setting row data. The class facilitates easy conversion</para>
        /// <para>to/from containers.</para>
        /// </summary>
        public unsafe partial class XLRowDataProxy : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr m_row;
                internal __IntPtr m_rowNode;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowDataProxy@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clear@XLRowDataProxy@OpenXLSX@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clear(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataProxy> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowDataProxy>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowDataProxy managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowDataProxy managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowDataProxy __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowDataProxy(native.ToPointer(), skipVTables);
            }

            internal static XLRowDataProxy __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowDataProxy)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowDataProxy __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowDataProxy(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLRowDataProxy(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowDataProxy(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Clears all values for the current row.</summary>
            public void Clear()
            {
                __Internal.Clear(__Instance);
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>
        /// <para>The XLRow class represent a row in an Excel spreadsheet. Using XLRow objects, various row formatting</para>
        /// <para>options can be set and modified.</para>
        /// </summary>
        public unsafe partial class XLRow : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_rowNode;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;
                internal global::OpenXLSX.OpenXLSX.XLRowDataProxy.__Internal m_rowDataProxy;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRow@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRow@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRow@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHeight@XLRow@OpenXLSX@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHeight(__IntPtr __instance, float height);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cells@XLRow@OpenXLSX@@QEBA?AVXLRowDataRange@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cells(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cells@XLRow@OpenXLSX@@QEBA?AVXLRowDataRange@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cells(__IntPtr __instance, __IntPtr @return, ushort cellCount);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cells@XLRow@OpenXLSX@@QEBA?AVXLRowDataRange@2@GG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cells(__IntPtr __instance, __IntPtr @return, ushort firstCell, ushort lastCell);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??MOpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLess(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??OOpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreater(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??NOpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??POpenXLSX@@YA_NAEBVXLRow@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?height@XLRow@OpenXLSX@@QEBANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double Height(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?descent@XLRow@OpenXLSX@@QEBAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float Descent(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setDescent@XLRow@OpenXLSX@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDescent(__IntPtr __instance, float descent);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?isHidden@XLRow@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsHidden(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setHidden@XLRow@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetHidden(__IntPtr __instance, bool state);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowNumber@XLRow@OpenXLSX@@QEBA_KXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ulong RowNumber(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cellCount@XLRow@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint CellCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?values@XLRow@OpenXLSX@@QEAAAEAVXLRowDataProxy@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Values(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRow> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRow>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRow managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRow managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRow __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRow(native.ToPointer(), skipVTables);
            }

            internal static XLRow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRow)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRow __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRow(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRow.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRow(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRow(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor</summary>
            public XLRow()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRow.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            /// <summary>Copy Constructor</summary>
            /// <remarks>The copy constructor is explicitly deleted</remarks>
            public XLRow(global::OpenXLSX.OpenXLSX.XLRow other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRow.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Set the height of the row.</summary>
            /// <param name="height">The height of the row.</param>
            public void SetHeight(float height)
            {
                __Internal.SetHeight(__Instance, height);
            }

            public global::OpenXLSX.OpenXLSX.XLRowDataRange Cells()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal();
                __Internal.Cells(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowDataRange Cells(ushort cellCount)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal();
                __Internal.Cells(__Instance, new IntPtr(&___ret), cellCount);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowDataRange Cells(ushort firstCell, ushort lastCell)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal();
                __Internal.Cells(__Instance, new IntPtr(&___ret), firstCell, lastCell);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowDataRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowDataRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLRow;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLRow.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator <(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLess(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator >(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreater(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator <=(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorLessEqual(__arg0, __arg1);
                return ___ret;
            }

            public static bool operator >=(global::OpenXLSX.OpenXLSX.XLRow lhs, global::OpenXLSX.OpenXLSX.XLRow rhs)
            {
                if (ReferenceEquals(lhs, null))
                    throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = lhs.__Instance;
                if (ReferenceEquals(rhs, null))
                    throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorGreaterEqual(__arg0, __arg1);
                return ___ret;
            }

            /// <summary>Get the height of the row.</summary>
            /// <returns>the row height.</returns>
            public double Height
            {
                get
                {
                    var ___ret = __Internal.Height(__Instance);
                    return ___ret;
                }
            }

            /// <summary>
            /// <para>Get the descent of the row, which is the vertical distance in pixels from the bottom of the cells</para>
            /// <para>in the current row to the typographical baseline of the cell content.</para>
            /// </summary>
            /// <param name="descent">The row descent.</param>
            /// <returns>
            /// <para>The row descent.</para>
            /// <para>Set the descent of the row, which is he vertical distance in pixels from the bottom of the cells</para>
            /// <para>in the current row to the typographical baseline of the cell content.</para>
            /// </returns>
            public float Descent
            {
                get
                {
                    var ___ret = __Internal.Descent(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetDescent(__Instance, value);
                }
            }

            /// <summary>Is the row hidden?</summary>
            /// <param name="state">The state of the row.</param>
            /// <returns>
            /// <para>The state of the row.</para>
            /// <para>Set the row to be hidden or visible.</para>
            /// </returns>
            public bool Hidden
            {
                get
                {
                    var ___ret = __Internal.IsHidden(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetHidden(__Instance, value);
                }
            }

            public ulong RowNumber
            {
                get
                {
                    var ___ret = __Internal.RowNumber(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the number of cells in the row.</summary>
            /// <returns>The number of cells in the row.</returns>
            public uint CellCount
            {
                get
                {
                    var ___ret = __Internal.CellCount(__Instance);
                    return ___ret;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLRowDataProxy Values
            {
                get
                {
                    var ___ret = __Internal.Values(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLRowDataProxy.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }

        public unsafe partial class XLRowIterator : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 72)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_dataNode;
                internal uint m_firstRow;
                internal uint m_lastRow;
                internal global::OpenXLSX.OpenXLSX.XLRow.__Internal m_currentRow;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowIterator@OpenXLSX@@QEAA@AEBVXLRowRange@1@W4XLIteratorLocation@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr rowRange, global::OpenXLSX.OpenXLSX.XLIteratorLocation loc);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowIterator@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowIterator@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??EXLRowIterator@OpenXLSX@@QEAAAEAV01@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr OperatorPlusPlus(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8XLRowIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9XLRowIterator@OpenXLSX@@QEBA_NAEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr __instance, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLRowIterator@OpenXLSX@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorConversion(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowIterator> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowIterator>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowIterator managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowIterator managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowIterator __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowIterator(native.ToPointer(), skipVTables);
            }

            internal static XLRowIterator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowIterator)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowIterator __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowIterator(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRowIterator(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowIterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLRowIterator(global::OpenXLSX.OpenXLSX.XLRowRange rowRange, global::OpenXLSX.OpenXLSX.XLIteratorLocation loc)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(rowRange, null))
                    throw new global::System.ArgumentNullException("rowRange", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rowRange.__Instance;
                __Internal.ctor(__Instance, __arg0, loc);
            }

            public XLRowIterator(global::OpenXLSX.OpenXLSX.XLRowIterator other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::OpenXLSX.OpenXLSX.XLRowIterator operator ++(global::OpenXLSX.OpenXLSX.XLRowIterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorPlusPlus(__arg0);
                var __result0 = global::OpenXLSX.OpenXLSX.XLRowIterator.__GetOrCreateInstance(___ret, false);
                return __result0;
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLRowIterator __op, global::OpenXLSX.OpenXLSX.XLRowIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return __opNull && rhsNull;
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLRowIterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLRowIterator __op, global::OpenXLSX.OpenXLSX.XLRowIterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return !(__opNull && rhsNull);
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public static implicit operator bool(global::OpenXLSX.OpenXLSX.XLRowIterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = __Internal.OperatorConversion(__arg0);
                return ___ret;
            }
        }

        public unsafe partial class XLRowRange : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::Std.UniquePtr.__Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_ m_dataNode;
                internal uint m_firstRow;
                internal uint m_lastRow;
                internal global::OpenXLSX.OpenXLSX.XLSharedStrings.__Internal m_sharedStrings;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLRowRange@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLRowRange@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?begin@XLRowRange@OpenXLSX@@QEAA?AVXLRowIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Begin(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?end@XLRowRange@OpenXLSX@@QEAA?AVXLRowIterator@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowCount@XLRowRange@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint RowCount(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowRange> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLRowRange>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLRowRange managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLRowRange managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLRowRange __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLRowRange(native.ToPointer(), skipVTables);
            }

            internal static XLRowRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLRowRange)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLRowRange __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLRowRange(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLRowRange.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLRowRange(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLRowRange(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLRowRange(global::OpenXLSX.OpenXLSX.XLRowRange other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLRowRange.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::OpenXLSX.OpenXLSX.XLRowIterator Begin()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal();
                __Internal.Begin(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowIterator End()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal();
                __Internal.End(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowIterator.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowIterator.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public uint RowCount
            {
                get
                {
                    var ___ret = __Internal.RowCount(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLColor : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 4)]
            public partial struct __Internal
            {
                internal byte m_alpha;
                internal byte m_red;
                internal byte m_green;
                internal byte m_blue;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@EEEE@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, byte alpha, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@EEE@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr hexCode);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLColor@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLColor@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set@XLColor@OpenXLSX@@QEAAXEEEE@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Set(__IntPtr __instance, byte alpha, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set@XLColor@OpenXLSX@@QEAAXEEE@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Set(__IntPtr __instance, byte red, byte green, byte blue);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?set@XLColor@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Set(__IntPtr __instance, __IntPtr hexCode);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??8OpenXLSX@@YA_NAEBVXLColor@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??9OpenXLSX@@YA_NAEBVXLColor@0@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(__IntPtr lhs, __IntPtr rhs);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?alpha@XLColor@OpenXLSX@@QEBAEXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte Alpha(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?red@XLColor@OpenXLSX@@QEBAEXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte Red(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?green@XLColor@OpenXLSX@@QEBAEXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte Green(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?blue@XLColor@OpenXLSX@@QEBAEXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte Blue(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?hex@XLColor@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Hex(__IntPtr __instance, __IntPtr @return);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLColor> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLColor>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLColor managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLColor managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLColor __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLColor(native.ToPointer(), skipVTables);
            }

            internal static XLColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLColor)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLColor __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLColor(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLColor.__Internal.cctor_1(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLColor(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLColor(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLColor()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLColor(byte alpha, byte red, byte green, byte blue)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, alpha, red, green, blue);
            }

            public XLColor(byte red, byte green, byte blue)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, red, green, blue);
            }

            public XLColor(string hexCode)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, hexCode);
                var __arg0 = __basicString0.__Instance;
                __Internal.ctor(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public XLColor(global::OpenXLSX.OpenXLSX.XLColor other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLColor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(other, null))
                    throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = other.__Instance;
                __Internal.cctor_1(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void Set(byte alpha, byte red, byte green, byte blue)
            {
                __Internal.Set(__Instance, alpha, red, green, blue);
            }

            public void Set(byte red, byte green, byte blue)
            {
                __Internal.Set(__Instance, red, green, blue);
            }

            public void Set(string hexCode)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, hexCode);
                var __arg0 = __basicString0.__Instance;
                __Internal.Set(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLColor(string hexCode)
            {
                return new global::OpenXLSX.OpenXLSX.XLColor(hexCode);
            }

            public static bool operator ==(global::OpenXLSX.OpenXLSX.XLColor lhs, global::OpenXLSX.OpenXLSX.XLColor rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return lhsNull && rhsNull;
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return ___ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenXLSX.OpenXLSX.XLColor;
            }

            public override int GetHashCode()
            {
                if (__Instance == __IntPtr.Zero)
                    return __IntPtr.Zero.GetHashCode();
                return (*(global::OpenXLSX.OpenXLSX.XLColor.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenXLSX.OpenXLSX.XLColor lhs, global::OpenXLSX.OpenXLSX.XLColor rhs)
            {
                bool lhsNull = ReferenceEquals(lhs, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (lhsNull || rhsNull)
                    return !(lhsNull && rhsNull);
                var __arg0 = lhs.__Instance;
                var __arg1 = rhs.__Instance;
                var ___ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return ___ret;
            }

            public byte Alpha
            {
                get
                {
                    var ___ret = __Internal.Alpha(__Instance);
                    return ___ret;
                }
            }

            public byte Red
            {
                get
                {
                    var ___ret = __Internal.Red(__Instance);
                    return ___ret;
                }
            }

            public byte Green
            {
                get
                {
                    var ___ret = __Internal.Green(__Instance);
                    return ___ret;
                }
            }

            public byte Blue
            {
                get
                {
                    var ___ret = __Internal.Blue(__Instance);
                    return ___ret;
                }
            }

            public string Hex
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Hex(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        /// <summary>The XLSheetState is an enumeration of the possible (visibility) states, e.g. Visible or Hidden.</summary>
        public enum XLSheetState
        {
            Visible = 0,
            Hidden = 1,
            VeryHidden = 2
        }

        /// <summary>A class encapsulating an Excel worksheet. Access to XLWorksheet objects should be via the workbook object.</summary>
        public unsafe partial class XLWorksheet : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorksheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorksheet@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLWorksheet@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLWorksheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cell@XLWorksheet@OpenXLSX@@QEBA?AVXLCell@2@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cell(__IntPtr __instance, __IntPtr @return, __IntPtr @ref);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cell@XLWorksheet@OpenXLSX@@QEBA?AVXLCell@2@AEBVXLCellReference@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cell_1(__IntPtr __instance, __IntPtr @return, __IntPtr @ref);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?cell@XLWorksheet@OpenXLSX@@QEBA?AVXLCell@2@IG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Cell(__IntPtr __instance, __IntPtr @return, uint rowNumber, ushort columnNumber);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?range@XLWorksheet@OpenXLSX@@QEBA?AVXLCellRange@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Range(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?range@XLWorksheet@OpenXLSX@@QEBA?AVXLCellRange@2@AEBVXLCellReference@2@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Range(__IntPtr __instance, __IntPtr @return, __IntPtr topLeft, __IntPtr bottomRight);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rows@XLWorksheet@OpenXLSX@@QEBA?AVXLRowRange@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rows(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rows@XLWorksheet@OpenXLSX@@QEBA?AVXLRowRange@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rows(__IntPtr __instance, __IntPtr @return, uint rowCount);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rows@XLWorksheet@OpenXLSX@@QEBA?AVXLRowRange@2@II@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Rows(__IntPtr __instance, __IntPtr @return, uint firstRow, uint lastRow);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?row@XLWorksheet@OpenXLSX@@QEBA?AVXLRow@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Row(__IntPtr __instance, __IntPtr @return, uint rowNumber);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?column@XLWorksheet@OpenXLSX@@QEBA?AVXLColumn@2@G@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Column(__IntPtr __instance, __IntPtr @return, ushort columnNumber);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?updateSheetName@XLWorksheet@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateSheetName(__IntPtr __instance, __IntPtr oldName, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?iterateAllCells@XLWorksheet@OpenXLSX@@QEBAXP6AX_KPEAX01@Z@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void IterateAllCells(__IntPtr __instance, __IntPtr onReadSheetData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?lastCell@XLWorksheet@OpenXLSX@@QEBA?AVXLCellReference@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LastCell(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?columnCount@XLWorksheet@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort ColumnCount(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?rowCount@XLWorksheet@OpenXLSX@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint RowCount(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLWorksheet> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLWorksheet>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLWorksheet managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLWorksheet managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLWorksheet __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLWorksheet(native.ToPointer(), skipVTables);
            }

            internal static XLWorksheet __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLWorksheet)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLWorksheet __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLWorksheet(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLWorksheet(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLWorksheet(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor</summary>
            public XLWorksheet()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLWorksheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>Copy Constructor.</summary>
            /// <remarks>The copy constructor has been explicitly deleted.</remarks>
            public XLWorksheet(global::OpenXLSX.OpenXLSX.XLWorksheet other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal*) other.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::OpenXLSX.OpenXLSX.XLCell Cell(string @ref)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, @ref);
                var __arg0 = __basicString0.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCell.__Internal();
                __Internal.Cell(__Instance, new IntPtr(&___ret), __arg0);
                __basicString0.Dispose();
                var _____ret = global::OpenXLSX.OpenXLSX.XLCell.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCell.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get a pointer to the XLCell object for the given cell reference.</summary>
            /// <param name="ref">An XLCellReference object with the address of the cell to get.</param>
            /// <returns>A const reference to the requested XLCell object.</returns>
            public global::OpenXLSX.OpenXLSX.XLCell Cell(global::OpenXLSX.OpenXLSX.XLCellReference @ref)
            {
                if (ReferenceEquals(@ref, null))
                    throw new global::System.ArgumentNullException("@ref", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @ref.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCell.__Internal();
                __Internal.Cell_1(__Instance, new IntPtr(&___ret), __arg0);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCell.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCell.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the cell at the given coordinates.</summary>
            /// <param name="rowNumber">The row number (index base 1).</param>
            /// <param name="columnNumber">The column number (index base 1).</param>
            /// <returns>A reference to the XLCell object at the given coordinates.</returns>
            public global::OpenXLSX.OpenXLSX.XLCell Cell(uint rowNumber, ushort columnNumber)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCell.__Internal();
                __Internal.Cell(__Instance, new IntPtr(&___ret), rowNumber, columnNumber);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCell.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCell.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get a range for the area currently in use (i.e. from cell A1 to the last cell being in use).</summary>
            /// <returns>A const XLCellRange object with the entire range.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellRange Range()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellRange.__Internal();
                __Internal.Range(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get a range with the given coordinates.</summary>
            /// <param name="topLeft">An XLCellReference object with the coordinates to the top left cell.</param>
            /// <param name="bottomRight">An XLCellReference object with the coordinates to the bottom right cell.</param>
            /// <returns>A const XLCellRange object with the requested range.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellRange Range(global::OpenXLSX.OpenXLSX.XLCellReference topLeft, global::OpenXLSX.OpenXLSX.XLCellReference bottomRight)
            {
                if (ReferenceEquals(topLeft, null))
                    throw new global::System.ArgumentNullException("topLeft", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = topLeft.__Instance;
                if (ReferenceEquals(bottomRight, null))
                    throw new global::System.ArgumentNullException("bottomRight", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = bottomRight.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLCellRange.__Internal();
                __Internal.Range(__Instance, new IntPtr(&___ret), __arg0, __arg1);
                var _____ret = global::OpenXLSX.OpenXLSX.XLCellRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLCellRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowRange Rows()
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowRange.__Internal();
                __Internal.Rows(__Instance, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowRange Rows(uint rowCount)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowRange.__Internal();
                __Internal.Rows(__Instance, new IntPtr(&___ret), rowCount);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public global::OpenXLSX.OpenXLSX.XLRowRange Rows(uint firstRow, uint lastRow)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRowRange.__Internal();
                __Internal.Rows(__Instance, new IntPtr(&___ret), firstRow, lastRow);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRowRange.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRowRange.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the row with the given row number.</summary>
            /// <param name="rowNumber">The number of the row to retrieve.</param>
            /// <returns>A pointer to the XLRow object.</returns>
            public global::OpenXLSX.OpenXLSX.XLRow Row(uint rowNumber)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLRow.__Internal();
                __Internal.Row(__Instance, new IntPtr(&___ret), rowNumber);
                var _____ret = global::OpenXLSX.OpenXLSX.XLRow.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLRow.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            /// <summary>Get the column with the given column number.</summary>
            /// <param name="columnNumber">The number of the column to retrieve.</param>
            /// <returns>A pointer to the XLColumn object.</returns>
            public global::OpenXLSX.OpenXLSX.XLColumn Column(ushort columnNumber)
            {
                var ___ret = new global::OpenXLSX.OpenXLSX.XLColumn.__Internal();
                __Internal.Column(__Instance, new IntPtr(&___ret), columnNumber);
                var _____ret = global::OpenXLSX.OpenXLSX.XLColumn.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLColumn.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public void UpdateSheetName(string oldName, string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, oldName);
                var __arg0 = __basicString0.__Instance;
                var __basicString1 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString1, newName);
                var __arg1 = __basicString1.__Instance;
                __Internal.UpdateSheetName(__Instance, __arg0, __arg1);
                __basicString0.Dispose();
                __basicString1.Dispose();
            }

            public void IterateAllCells(global::OpenXLSX.OnReadSheetData onReadSheetData)
            {
                var __arg0 = onReadSheetData == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(onReadSheetData);
                __Internal.IterateAllCells(__Instance, __arg0);
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLWorksheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLWorksheet(xmlData);
            }

            /// <summary>Get an XLCellReference to the last (bottom right) cell in the worksheet.</summary>
            /// <returns>An XLCellReference for the last cell.</returns>
            public global::OpenXLSX.OpenXLSX.XLCellReference LastCell
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLCellReference.__Internal();
                    __Internal.LastCell(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLCellReference.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLCellReference.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }
            }

            /// <summary>Get the number of columns in the worksheet.</summary>
            /// <returns>The number of columns.</returns>
            public ushort ColumnCount
            {
                get
                {
                    var ___ret = __Internal.ColumnCount(__Instance);
                    return ___ret;
                }
            }

            /// <summary>Get the number of rows in the worksheet.</summary>
            /// <returns>The number of rows.</returns>
            public uint RowCount
            {
                get
                {
                    var ___ret = __Internal.RowCount(__Instance);
                    return ___ret;
                }
            }
        }

        /// <summary>Class representing the an Excel chartsheet.</summary>
        /// <remarks>This class is largely unimplemented and works just as a placeholder.</remarks>
        public unsafe partial class XLChartsheet : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr m_xmlData;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLChartsheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLChartsheet@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLChartsheet@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLChartsheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLChartsheet> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLChartsheet>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLChartsheet managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLChartsheet managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLChartsheet __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLChartsheet(native.ToPointer(), skipVTables);
            }

            internal static XLChartsheet __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLChartsheet)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLChartsheet __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLChartsheet(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLChartsheet(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLChartsheet(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            /// <summary>Default constructor</summary>
            public XLChartsheet()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance);
            }

            public XLChartsheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            public XLChartsheet(global::OpenXLSX.OpenXLSX.XLChartsheet other)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal*) other.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLChartsheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLChartsheet(xmlData);
            }
        }

        /// <summary>
        /// <para>The XLAbstractSheet is a generalized sheet class, which functions as superclass for specialized classes,</para>
        /// <para>such as XLWorksheet. It implements functionality common to all sheet types. This is a pure abstract class,</para>
        /// <para>so it cannot be instantiated.</para>
        /// </summary>
        public unsafe partial class XLSheet : global::OpenXLSX.OpenXLSX.XLXmlFile, IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public new partial struct __Internal
            {
                internal __IntPtr m_xmlData;
                internal global::OpenXLSX.OpenXLSX.XLContentType sheet_type;
                internal global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal m_sheet_WorkSheet;
                internal global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal m_sheet_ChartSheet;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSheet@OpenXLSX@@QEAA@PEAVXLXmlData@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr xmlData);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLSheet@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr other);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLSheet@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setSelected@XLSheet@OpenXLSX@@QEAAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetSelected(__IntPtr __instance, bool selected);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?clone@XLSheet@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Clone(__IntPtr __instance, __IntPtr newName);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLSheet@OpenXLSX@@QEBA?AVXLWorksheet@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??BXLSheet@OpenXLSX@@QEBA?AVXLChartsheet@1@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OperatorConversion_1(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?visibility@XLSheet@OpenXLSX@@QEBA?AW4XLSheetState@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLSheetState Visibility(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setVisibility@XLSheet@OpenXLSX@@QEAAXW4XLSheetState@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVisibility(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLSheetState state);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?color@XLSheet@OpenXLSX@@QEBA?AVXLColor@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Color(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setColor@XLSheet@OpenXLSX@@QEAAXAEBVXLColor@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColor(__IntPtr __instance, __IntPtr color);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?index@XLSheet@OpenXLSX@@QEBAGXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort Index(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setIndex@XLSheet@OpenXLSX@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndex(__IntPtr __instance, ushort index);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?name@XLSheet@OpenXLSX@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Name(__IntPtr __instance, __IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?setName@XLSheet@OpenXLSX@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(__IntPtr __instance, __IntPtr name);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getWorkSheet@XLSheet@OpenXLSX@@QEAAAEAVXLWorksheet@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetWorkSheet(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?getChartsheet@XLSheet@OpenXLSX@@QEAAAEAVXLChartsheet@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetChartsheet(__IntPtr __instance);
            }

            internal static new XLSheet __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLSheet(native.ToPointer(), skipVTables);
            }

            internal static new XLSheet __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLSheet)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLSheet __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLSheet(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XLSheet(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLSheet(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            /// <summary>
            /// <para>The constructor. There are no default constructor, so all parameters must be provided for</para>
            /// <para>constructing an XLAbstractSheet object. Since this is a pure abstract class, instantiation is only</para>
            /// <para>possible via one of the derived classes.</para>
            /// </summary>
            public XLSheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                var __arg0 = xmlData is null ? __IntPtr.Zero : xmlData.__Instance;
                __Internal.ctor(__Instance, __arg0);
            }

            /// <summary>The copy constructor.</summary>
            /// <param name="other">The object to be copied.</param>
            /// <remarks>The default copy constructor is used, i.e. only shallow copying of pointer data members.</remarks>
            public XLSheet(global::OpenXLSX.OpenXLSX.XLSheet other)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLSheet.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::OpenXLSX.OpenXLSX.XLSheet.__Internal*) __Instance) = *((global::OpenXLSX.OpenXLSX.XLSheet.__Internal*) other.__Instance);
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public void SetSelected(bool selected)
            {
                __Internal.SetSelected(__Instance, selected);
            }

            /// <summary>Method for cloning the sheet.</summary>
            /// <param name="newName">A std::string with the name of the clone</param>
            /// <returns>A pointer to the cloned object.</returns>
            /// <remarks>This is a pure abstract method. I.e. it is implemented in subclasses.</remarks>
            public void Clone(string newName)
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, newName);
                var __arg0 = __basicString0.__Instance;
                __Internal.Clone(__Instance, __arg0);
                __basicString0.Dispose();
            }

            public static implicit operator global::OpenXLSX.OpenXLSX.XLWorksheet(global::OpenXLSX.OpenXLSX.XLSheet __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal();
                __Internal.OperatorConversion(__arg0, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLWorksheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLWorksheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static implicit operator global::OpenXLSX.OpenXLSX.XLChartsheet(global::OpenXLSX.OpenXLSX.XLSheet __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var ___ret = new global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal();
                __Internal.OperatorConversion_1(__arg0, new IntPtr(&___ret));
                var _____ret = global::OpenXLSX.OpenXLSX.XLChartsheet.__CreateInstance(___ret);
                global::OpenXLSX.OpenXLSX.XLChartsheet.__Internal.dtor(new __IntPtr(&___ret));
                return _____ret;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLSheet(global::OpenXLSX.OpenXLSX.XLXmlData xmlData)
            {
                return new global::OpenXLSX.OpenXLSX.XLSheet(xmlData);
            }

            /// <summary>Method for getting the current visibility state of the sheet.</summary>
            /// <param name="state">An XLSheetState enum object with the new state.</param>
            /// <returns>
            /// <para>An XLSheetState enum object, with the current sheet state.</para>
            /// <para>Method for setting the state of the sheet.</para>
            /// </returns>
            /// <remarks>
            /// <para>For some reason, this method doesn't work. The data is written correctly to the xml file, but the sheet</para>
            /// <para>is not hidden when opening the file in Excel.</para>
            /// </remarks>
            public global::OpenXLSX.OpenXLSX.XLSheetState Visibility
            {
                get
                {
                    var ___ret = __Internal.Visibility(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetVisibility(__Instance, value);
                }
            }

            public global::OpenXLSX.OpenXLSX.XLColor Color
            {
                get
                {
                    var ___ret = new global::OpenXLSX.OpenXLSX.XLColor.__Internal();
                    __Internal.Color(__Instance, new IntPtr(&___ret));
                    var _____ret = global::OpenXLSX.OpenXLSX.XLColor.__CreateInstance(___ret);
                    global::OpenXLSX.OpenXLSX.XLColor.__Internal.dtor(new __IntPtr(&___ret));
                    return _____ret;
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = value.__Instance;
                    __Internal.SetColor(__Instance, __arg0);
                }
            }

            /// <summary>Method for getting the index of the sheet.</summary>
            /// <returns>
            /// <para>An int with the index of the sheet.</para>
            /// <para>Method for setting the index of the sheet. This effectively moves the sheet to a different position.</para>
            /// </returns>
            public ushort Index
            {
                get
                {
                    var ___ret = __Internal.Index(__Instance);
                    return ___ret;
                }

                set
                {
                    __Internal.SetIndex(__Instance, value);
                }
            }

            /// <summary>Method to retrieve the name of the sheet.</summary>
            /// <param name="name">A std::string with the new name.</param>
            /// <returns>
            /// <para>A std::string with the sheet name.</para>
            /// <para>Method for renaming the sheet.</para>
            /// </returns>
            public string Name
            {
                get
                {
                    var ___ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.Name(__Instance, new IntPtr(&___ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&___ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }

                set
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, value);
                    var __arg0 = __basicString0.__Instance;
                    __Internal.SetName(__Instance, __arg0);
                    __basicString0.Dispose();
                }
            }

            public global::OpenXLSX.OpenXLSX.XLWorksheet WorkSheet
            {
                get
                {
                    var ___ret = __Internal.GetWorkSheet(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLWorksheet.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }

            public global::OpenXLSX.OpenXLSX.XLChartsheet Chartsheet
            {
                get
                {
                    var ___ret = __Internal.GetChartsheet(__Instance);
                    var __result0 = global::OpenXLSX.OpenXLSX.XLChartsheet.__GetOrCreateInstance(___ret, false);
                    return __result0;
                }
            }
        }
    }

    namespace Pugi
    {
        public unsafe partial class XmlNode
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Pugi.XmlNode> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Pugi.XmlNode>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.Pugi.XmlNode managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.Pugi.XmlNode managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XmlNode __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XmlNode(native.ToPointer(), skipVTables);
            }

            internal static XmlNode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XmlNode)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XmlNode __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XmlNode(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XmlNode(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XmlNode(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }

        public unsafe partial class XmlAttribute
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Pugi.XmlAttribute> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Pugi.XmlAttribute>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.Pugi.XmlAttribute managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.Pugi.XmlAttribute managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XmlAttribute __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XmlAttribute(native.ToPointer(), skipVTables);
            }

            internal static XmlAttribute __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XmlAttribute)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XmlAttribute __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XmlAttribute(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XmlAttribute(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XmlAttribute(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }

        public unsafe partial class XmlDocument
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Pugi.XmlDocument> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.Pugi.XmlDocument>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.Pugi.XmlDocument managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.Pugi.XmlDocument managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XmlDocument __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XmlDocument(native.ToPointer(), skipVTables);
            }

            internal static XmlDocument __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XmlDocument)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XmlDocument __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XmlDocument(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private XmlDocument(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XmlDocument(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }
    }

    namespace OpenXLSX
    {
    }

    namespace OpenXLSX
    {
        public enum XLIteratorLocation
        {
            Begin = 0,
            End = 1
        }

        public enum XLIteratorDirection
        {
            Forward = 0,
            Reverse = 1
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void OnReadSheetData(ulong rowInfoCount, __IntPtr rowInfos, ulong cellTotalCount, __IntPtr CellsData);

    namespace OpenXLSX
    {
        public enum XLCommandType
        {
            SetSheetName = 0,
            SetSheetColor = 1,
            SetSheetVisibility = 2,
            SetSheetIndex = 3,
            SetSheetActive = 4,
            ResetCalcChain = 5,
            AddSharedStrings = 6,
            AddWorksheet = 7,
            AddChartsheet = 8,
            DeleteSheet = 9,
            CloneSheet = 10
        }

        public enum XLQueryType
        {
            QuerySheetName = 0,
            QuerySheetIndex = 1,
            QuerySheetVisibility = 2,
            QuerySheetIsActive = 3,
            QuerySheetType = 4,
            QuerySheetID = 5,
            QuerySheetRelsID = 6,
            QuerySheetRelsTarget = 7,
            QuerySharedStrings = 8,
            QueryXmlData = 9
        }

        public unsafe partial class XLCommand : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal global::OpenXLSX.OpenXLSX.XLCommandType m_type;
                internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_any___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_params;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCommand@OpenXLSX@@QEAA@W4XLCommandType@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLCommandType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLCommand@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLCommand@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLCommand@OpenXLSX@@QEBA?AW4XLCommandType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLCommandType Type(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCommand> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLCommand>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLCommand managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLCommand managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLCommand __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLCommand(native.ToPointer(), skipVTables);
            }

            internal static XLCommand __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLCommand)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLCommand __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLCommand(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLCommand.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLCommand(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLCommand(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLCommand(global::OpenXLSX.OpenXLSX.XLCommandType type)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCommand.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, type);
            }

            public XLCommand(global::OpenXLSX.OpenXLSX.XLCommand _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLCommand.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLCommand(global::OpenXLSX.OpenXLSX.XLCommandType type)
            {
                return new global::OpenXLSX.OpenXLSX.XLCommand(type);
            }

            public global::OpenXLSX.OpenXLSX.XLCommandType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }
        }

        public unsafe partial class XLQuery : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 88)]
            public partial struct __Internal
            {
                internal global::OpenXLSX.OpenXLSX.XLQueryType m_type;
                internal global::Std.Any.__Internal m_result;
                internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_any___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ m_params;

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLQuery@OpenXLSX@@QEAA@W4XLQueryType@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, global::OpenXLSX.OpenXLSX.XLQueryType type);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??0XLQuery@OpenXLSX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "??1XLQuery@OpenXLSX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void dtor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("OpenXLSX", EntryPoint = "?type@XLQuery@OpenXLSX@@QEBA?AW4XLQueryType@2@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::OpenXLSX.OpenXLSX.XLQueryType Type(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLQuery> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenXLSX.OpenXLSX.XLQuery>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::OpenXLSX.OpenXLSX.XLQuery managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::OpenXLSX.OpenXLSX.XLQuery managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static XLQuery __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new XLQuery(native.ToPointer(), skipVTables);
            }

            internal static XLQuery __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (XLQuery)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static XLQuery __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new XLQuery(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                global::OpenXLSX.OpenXLSX.XLQuery.__Internal.cctor(ret, new __IntPtr(&native));
                return ret.ToPointer();
            }

            private XLQuery(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected XLQuery(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public XLQuery(global::OpenXLSX.OpenXLSX.XLQueryType type)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLQuery.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                __Internal.ctor(__Instance, type);
            }

            public XLQuery(global::OpenXLSX.OpenXLSX.XLQuery _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenXLSX.OpenXLSX.XLQuery.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (callNativeDtor)
                    __Internal.dtor(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static explicit operator global::OpenXLSX.OpenXLSX.XLQuery(global::OpenXLSX.OpenXLSX.XLQueryType type)
            {
                return new global::OpenXLSX.OpenXLSX.XLQuery(type);
            }

            public global::OpenXLSX.OpenXLSX.XLQueryType Type
            {
                get
                {
                    var ___ret = __Internal.Type(__Instance);
                    return ___ret;
                }
            }
        }
    }

    namespace OpenXLSX
    {
        public unsafe partial class XLConstants
        {
            public partial struct __Internal
            {
            }

            public const ushort MAX_COLS = 16384;
            public const uint MAX_ROWS = 1048576;        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);
    }
}

namespace Std
{
    namespace CompressedPair
    {
        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_pugi_S_xml_document__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_IZipArchive_S_Concept__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLRowDataRange__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_node____N_OpenXLSX_S_XLXmlData__v___N_std_S__List_val____N_std_S__List_simple_types__S2__Vb1
        {
            internal global::Std.ListVal.__Internal _Myval2;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_pugi_S_xml_node__S1__Vb1
        {
            internal __IntPtr _Myval2;
        }
    }

}
namespace Std
{
    namespace UniquePtr
    {
        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_pugi_S_xml_document___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_pugi_S_xml_document__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_IZipArchive_S_Concept___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_IZipArchive_S_Concept__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_OpenXLSX_S_XLRowDataRange___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_OpenXLSX_S_XLRowDataRange__S1__Vb1 _Mypair;
        }

        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_unique_ptr____N_pugi_S_xml_node___N_std_S_default_delete__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_default_delete____N_pugi_S_xml_node__S1__Vb1 _Mypair;
        }
    }

}
namespace Std
{
    namespace List
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public unsafe partial struct __Internalc__N_std_S_list____N_OpenXLSX_S_XLXmlData___N_std_S_allocator__S0_
        {
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S_allocator____N_std_S__List_node____N_OpenXLSX_S_XLXmlData__v___N_std_S__List_val____N_std_S__List_simple_types__S2__Vb1 _Mypair;
        }
    }
}
